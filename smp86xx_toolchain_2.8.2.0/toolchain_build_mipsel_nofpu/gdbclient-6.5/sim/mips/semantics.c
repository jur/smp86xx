/* This file is part of GDB.

   Copyright 2002 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
 
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.

   --

   This file was generated by the program igen */

#ifndef SEMANTICS_C
#define SEMANTICS_C


#include "sim-inline.c"

#if C_REVEALS_MODULE_P (ITABLE_INLINE)
#include "itable.c"
#else
#include "itable.h"
#endif

#if C_REVEALS_MODULE_P (IDECODE_INLINE)
#include "idecode.c"
#else
#include "idecode.h"
#endif

#if C_REVEALS_MODULE_P (SUPPORT_INLINE)
#include "support.c"
#else
#include "support.h"
#endif

#include "semantics.h"


EXTERN_SEMANTICS\
(instruction_address)
semantic_RSVD_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_RSVD_SPECIAL
#undef RSVD_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX RSVD_SPECIAL
#undef MY_NAME
#define MY_NAME "RSVD_SPECIAL"

  /* Extraction: RSVD
       #define do-not-use-icache
       6.0x0,5.*,5.*,5.*,5.OP,6.0x5 */

#undef OP
#define OP ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#line 72 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.*,5.*,5.*,5.OP,6.0x5 */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 93 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "rsvd %ld", \
                    (long) OP);
#line 89 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_RSVD_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 95 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    SignalException (ReservedInstruction, instruction_0);
  }
#line 117 "semantics.c"
  return nia;
  /* Extraction: RSVD
       #undef do-not-use-icache
       6.0x0,5.*,5.*,5.*,5.OP,6.0x5 */

#undef OP
#line 124 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SYSCALL_SPECIAL (SIM_DESC sd,
                          instruction_word instruction_0,
                          instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SYSCALL_SPECIAL
#undef SYSCALL_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SYSCALL_SPECIAL
#undef MY_NAME
#define MY_NAME "SYSCALL_SPECIAL"

  /* Extraction: SYSCALL
       #define do-not-use-icache
       6.0x0,20.CODE,6.0xc */

#undef CODE
#define CODE ((unsigned) EXTRACTED32 (instruction_0, 25, 6)) /* cache - extraction */
#line 147 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,20.CODE,6.0xc */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3592 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "syscall %#lx", \
                    (unsigned long) CODE);
#line 164 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SYSCALL_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3606 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    SignalException (SystemCall, instruction_0);
  }
#line 192 "semantics.c"
  return nia;
  /* Extraction: SYSCALL
       #undef do-not-use-icache
       6.0x0,20.CODE,6.0xc */

#undef CODE
#line 199 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BREAK_SPECIAL (SIM_DESC sd,
                        instruction_word instruction_0,
                        instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BREAK_SPECIAL
#undef BREAK_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX BREAK_SPECIAL
#undef MY_NAME
#define MY_NAME "BREAK_SPECIAL"

  /* Extraction: BREAK
       #define do-not-use-icache
       6.0x0,20.CODE,6.0xd */

#undef CODE
#define CODE ((unsigned) EXTRACTED32 (instruction_0, 25, 6)) /* cache - extraction */
#line 222 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,20.CODE,6.0xd */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1094 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "break %#lx", \
                    (unsigned long) CODE);
#line 239 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BREAK_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1108 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    /* Check for some break instruction which are reserved for use by the simulator.  */
    unsigned int break_code = instruction_0 & HALT_INSTRUCTION_MASK;
    if (break_code == (HALT_INSTRUCTION  & HALT_INSTRUCTION_MASK) ||
        break_code == (HALT_INSTRUCTION2 & HALT_INSTRUCTION_MASK))
      {
        sim_engine_halt (SD, CPU, NULL, cia,
                         sim_exited, (unsigned int)(A0 & 0xFFFFFFFF));
      }
    else if (break_code == (BREAKPOINT_INSTRUCTION  & HALT_INSTRUCTION_MASK) ||
             break_code == (BREAKPOINT_INSTRUCTION2 & HALT_INSTRUCTION_MASK))
      {
        if (STATE & simDELAYSLOT)
          PC = cia - 4; /* reference the branch instruction */
        else
          PC = cia;
        SignalException (BreakPoint, instruction_0);
      }

    else
      {
        /* If we get this far, we're not an instruction reserved by the sim.  Raise
    	 the exception. */
        SignalException (BreakPoint, instruction_0);
      }
  }
#line 290 "semantics.c"
  return nia;
  /* Extraction: BREAK
       #undef do-not-use-icache
       6.0x0,20.CODE,6.0xd */

#undef CODE
#line 297 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TGE_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TGE_SPECIAL
#undef TGE_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX TGE_SPECIAL
#undef MY_NAME
#define MY_NAME "TGE_SPECIAL"

  /* Extraction: TGE
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x30 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef CODE
#define CODE ((unsigned) EXTRACTED32 (instruction_0, 15, 6)) /* cache - extraction */
#line 324 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.CODE,6.0x30 */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3647 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tge r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 342 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TGE_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3659 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    if ((signed_word) GPR[RS] >= (signed_word) GPR[RT])
      SignalException (Trap, instruction_0);
  }
#line 371 "semantics.c"
  return nia;
  /* Extraction: TGE
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x30 */

#undef RS
#undef RT
#undef CODE
#line 380 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TGEU_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TGEU_SPECIAL
#undef TGEU_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX TGEU_SPECIAL
#undef MY_NAME
#define MY_NAME "TGEU_SPECIAL"

  /* Extraction: TGEU
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x31 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef CODE
#define CODE ((unsigned) EXTRACTED32 (instruction_0, 15, 6)) /* cache - extraction */
#line 407 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.CODE,6.0x31 */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3701 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tgeu r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 425 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TGEU_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3713 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    if ((unsigned_word) GPR[RS] >= (unsigned_word) GPR[RT])
      SignalException (Trap, instruction_0);
  }
#line 454 "semantics.c"
  return nia;
  /* Extraction: TGEU
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x31 */

#undef RS
#undef RT
#undef CODE
#line 463 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TLT_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TLT_SPECIAL
#undef TLT_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX TLT_SPECIAL
#undef MY_NAME
#define MY_NAME "TLT_SPECIAL"

  /* Extraction: TLT
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x32 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef CODE
#define CODE ((unsigned) EXTRACTED32 (instruction_0, 15, 6)) /* cache - extraction */
#line 490 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.CODE,6.0x32 */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3719 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tlt r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 508 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TLT_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3731 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    if ((signed_word) GPR[RS] < (signed_word) GPR[RT])
      SignalException (Trap, instruction_0);
  }
#line 537 "semantics.c"
  return nia;
  /* Extraction: TLT
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x32 */

#undef RS
#undef RT
#undef CODE
#line 546 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TLTU_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TLTU_SPECIAL
#undef TLTU_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX TLTU_SPECIAL
#undef MY_NAME
#define MY_NAME "TLTU_SPECIAL"

  /* Extraction: TLTU
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x33 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef CODE
#define CODE ((unsigned) EXTRACTED32 (instruction_0, 15, 6)) /* cache - extraction */
#line 573 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.CODE,6.0x33 */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3773 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tltu r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 591 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TLTU_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3785 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    if ((unsigned_word) GPR[RS] < (unsigned_word) GPR[RT])
      SignalException (Trap, instruction_0);
  }
#line 620 "semantics.c"
  return nia;
  /* Extraction: TLTU
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x33 */

#undef RS
#undef RT
#undef CODE
#line 629 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TEQ_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TEQ_SPECIAL
#undef TEQ_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX TEQ_SPECIAL
#undef MY_NAME
#define MY_NAME "TEQ_SPECIAL"

  /* Extraction: TEQ
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x34 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef CODE
#define CODE ((unsigned) EXTRACTED32 (instruction_0, 15, 6)) /* cache - extraction */
#line 656 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.CODE,6.0x34 */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3611 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "teq r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 674 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TEQ_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3623 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    if ((signed_word) GPR[RS] == (signed_word) GPR[RT])
      SignalException (Trap, instruction_0);
  }
#line 703 "semantics.c"
  return nia;
  /* Extraction: TEQ
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x34 */

#undef RS
#undef RT
#undef CODE
#line 712 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TNE_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TNE_SPECIAL
#undef TNE_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX TNE_SPECIAL
#undef MY_NAME
#define MY_NAME "TNE_SPECIAL"

  /* Extraction: TNE
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x36 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef CODE
#define CODE ((unsigned) EXTRACTED32 (instruction_0, 15, 6)) /* cache - extraction */
#line 739 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.CODE,6.0x36 */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3791 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tne r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 757 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TNE_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3803 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    if ((signed_word) GPR[RS] != (signed_word) GPR[RT])
      SignalException (Trap, instruction_0);
  }
#line 786 "semantics.c"
  return nia;
  /* Extraction: TNE
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x36 */

#undef RS
#undef RT
#undef CODE
#line 795 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SLLV_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SLLV_SPECIAL
#undef SLLV_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SLLV_SPECIAL
#undef MY_NAME
#define MY_NAME "SLLV_SPECIAL"

  /* Extraction: SLLV
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x4 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 822 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x4 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3198 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sllv r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RT, \
                    (long) RS);
#line 846 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SLLV_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3212 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    do_sllv (SD_, RS, RT, RD);
  }
#line 874 "semantics.c"
  return nia;
  /* Extraction: SLLV
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x4 */

#undef RS
#undef RT
#undef RD
#line 883 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SRLV_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SRLV_SPECIAL
#undef SRLV_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SRLV_SPECIAL
#undef MY_NAME
#define MY_NAME "SRLV_SPECIAL"

  /* Extraction: SRLV
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x6 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 910 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x6 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3423 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "srlv r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RT, \
                    (long) RS);
#line 934 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SRLV_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3437 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    do_srlv (SD_, RS, RT, RD);
  }
#line 962 "semantics.c"
  return nia;
  /* Extraction: SRLV
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x6 */

#undef RS
#undef RT
#undef RD
#line 971 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SRAV_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SRAV_SPECIAL
#undef SRAV_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SRAV_SPECIAL
#undef MY_NAME
#define MY_NAME "SRAV_SPECIAL"

  /* Extraction: SRAV
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x7 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 998 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x7 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3363 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "srav r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RT, \
                    (long) RS);
#line 1022 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SRAV_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3377 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    do_srav (SD_, RS, RT, RD);
  }
#line 1050 "semantics.c"
  return nia;
  /* Extraction: SRAV
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x7 */

#undef RS
#undef RT
#undef RD
#line 1059 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MOVZ_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MOVZ_SPECIAL
#undef MOVZ_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX MOVZ_SPECIAL
#undef MY_NAME
#define MY_NAME "MOVZ_SPECIAL"

  /* Extraction: MOVZ
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0xa */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 1086 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0xa */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2534 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "movz r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 1110 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MOVZ_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2543 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    if (GPR[RT] == 0)
      {
        GPR[RD] = GPR[RS];
        TRACE_ALU_RESULT (GPR[RD]);
      }
  }
#line 1142 "semantics.c"
  return nia;
  /* Extraction: MOVZ
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0xa */

#undef RS
#undef RT
#undef RD
#line 1151 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MOVN_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MOVN_SPECIAL
#undef MOVN_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX MOVN_SPECIAL
#undef MY_NAME
#define MY_NAME "MOVN_SPECIAL"

  /* Extraction: MOVN
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0xb */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 1178 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0xb */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2515 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "movn r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 1202 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MOVN_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2524 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    if (GPR[RT] != 0)
      {
        GPR[RD] = GPR[RS];
        TRACE_ALU_RESULT (GPR[RD]);
      }
  }
#line 1234 "semantics.c"
  return nia;
  /* Extraction: MOVN
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0xb */

#undef RS
#undef RT
#undef RD
#line 1243 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ADD_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ADD_SPECIAL
#undef ADD_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX ADD_SPECIAL
#undef MY_NAME
#define MY_NAME "ADD_SPECIAL"

  /* Extraction: ADD
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x20 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 1270 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x20 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 517 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "add r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 1294 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ADD_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 531 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    if (NotWordValue (GPR[RS]) || NotWordValue (GPR[RT]))
      Unpredictable ();
    TRACE_ALU_INPUT2 (GPR[RS], GPR[RT]);
    {
      ALU32_BEGIN (GPR[RS]);
      ALU32_ADD (GPR[RT]);
      ALU32_END (GPR[RD]);   /* This checks for overflow.  */
    }
    TRACE_ALU_RESULT (GPR[RD]);
  }
#line 1330 "semantics.c"
  return nia;
  /* Extraction: ADD
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x20 */

#undef RS
#undef RT
#undef RD
#line 1339 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ADDU_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ADDU_SPECIAL
#undef ADDU_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX ADDU_SPECIAL
#undef MY_NAME
#define MY_NAME "ADDU_SPECIAL"

  /* Extraction: ADDU
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x21 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 1366 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x21 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 611 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "addu r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 1390 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ADDU_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 625 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    do_addu (SD_, RS, RT, RD);
  }
#line 1418 "semantics.c"
  return nia;
  /* Extraction: ADDU
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x21 */

#undef RS
#undef RT
#undef RD
#line 1427 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SUB_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SUB_SPECIAL
#undef SUB_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SUB_SPECIAL
#undef MY_NAME
#define MY_NAME "SUB_SPECIAL"

  /* Extraction: SUB
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x22 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 1454 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x22 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3442 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sub r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 1478 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SUB_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3456 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    if (NotWordValue (GPR[RS]) || NotWordValue (GPR[RT]))
      Unpredictable ();
    TRACE_ALU_INPUT2 (GPR[RS], GPR[RT]);
    {
      ALU32_BEGIN (GPR[RS]);
      ALU32_SUB (GPR[RT]);
      ALU32_END (GPR[RD]);   /* This checks for overflow.  */
    }
    TRACE_ALU_RESULT (GPR[RD]);
  }
#line 1514 "semantics.c"
  return nia;
  /* Extraction: SUB
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x22 */

#undef RS
#undef RT
#undef RD
#line 1523 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SUBU_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SUBU_SPECIAL
#undef SUBU_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SUBU_SPECIAL
#undef MY_NAME
#define MY_NAME "SUBU_SPECIAL"

  /* Extraction: SUBU
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x23 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 1550 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x23 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3478 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "subu r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 1574 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SUBU_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3492 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    do_subu (SD_, RS, RT, RD);
  }
#line 1602 "semantics.c"
  return nia;
  /* Extraction: SUBU
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x23 */

#undef RS
#undef RT
#undef RD
#line 1611 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_AND_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_AND_SPECIAL
#undef AND_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX AND_SPECIAL
#undef MY_NAME
#define MY_NAME "AND_SPECIAL"

  /* Extraction: AND
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x24 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 1638 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x24 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 638 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "and r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 1662 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_AND_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 652 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    do_and (SD_, RS, RT, RD);
  }
#line 1690 "semantics.c"
  return nia;
  /* Extraction: AND
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x24 */

#undef RS
#undef RT
#undef RD
#line 1699 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_OR_SPECIAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_OR_SPECIAL
#undef OR_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX OR_SPECIAL
#undef MY_NAME
#define MY_NAME "OR_SPECIAL"

  /* Extraction: OR
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x25 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 1726 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x25 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2769 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "or r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 1750 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_OR_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2783 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    do_or (SD_, RS, RT, RD);
  }
#line 1778 "semantics.c"
  return nia;
  /* Extraction: OR
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x25 */

#undef RS
#undef RT
#undef RD
#line 1787 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_XOR_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_XOR_SPECIAL
#undef XOR_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX XOR_SPECIAL
#undef MY_NAME
#define MY_NAME "XOR_SPECIAL"

  /* Extraction: XOR
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x26 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 1814 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x26 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3834 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "xor r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 1838 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_XOR_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3848 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    do_xor (SD_, RS, RT, RD);
  }
#line 1866 "semantics.c"
  return nia;
  /* Extraction: XOR
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x26 */

#undef RS
#undef RT
#undef RD
#line 1875 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_NOR_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_NOR_SPECIAL
#undef NOR_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX NOR_SPECIAL
#undef MY_NAME
#define MY_NAME "NOR_SPECIAL"

  /* Extraction: NOR
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x27 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 1902 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x27 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2743 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "nor r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 1926 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_NOR_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2757 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    do_nor (SD_, RS, RT, RD);
  }
#line 1954 "semantics.c"
  return nia;
  /* Extraction: NOR
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x27 */

#undef RS
#undef RT
#undef RD
#line 1963 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SLT_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SLT_SPECIAL
#undef SLT_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SLT_SPECIAL
#undef MY_NAME
#define MY_NAME "SLT_SPECIAL"

  /* Extraction: SLT
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x2a */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 1990 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x2a */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3224 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "slt r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 2014 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SLT_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3238 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    do_slt (SD_, RS, RT, RD);
  }
#line 2042 "semantics.c"
  return nia;
  /* Extraction: SLT
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x2a */

#undef RS
#undef RT
#undef RD
#line 2051 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SLTU_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SLTU_SPECIAL
#undef SLTU_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SLTU_SPECIAL
#undef MY_NAME
#define MY_NAME "SLTU_SPECIAL"

  /* Extraction: SLTU
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x2b */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 2078 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x2b */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3303 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sltu r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 2102 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SLTU_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3317 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    do_sltu (SD_, RS, RT, RD);
  }
#line 2130 "semantics.c"
  return nia;
  /* Extraction: SLTU
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x2b */

#undef RS
#undef RT
#undef RD
#line 2139 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MULT_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MULT_SPECIAL
#undef MULT_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX MULT_SPECIAL
#undef MY_NAME
#define MY_NAME "MULT_SPECIAL"

  /* Extraction: MULT
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.0x0,6.0x18 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#line 2164 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.0x0,6.0x18 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x0000ffc0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2667 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mult r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 2187 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MULT_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2679 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    do_mult (SD_, RS, RT, 0);
  }
#line 2215 "semantics.c"
  return nia;
  /* Extraction: MULT
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.0x0,6.0x18 */

#undef RS
#undef RT
#line 2223 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MULTU_SPECIAL (SIM_DESC sd,
                        instruction_word instruction_0,
                        instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MULTU_SPECIAL
#undef MULTU_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX MULTU_SPECIAL
#undef MY_NAME
#define MY_NAME "MULTU_SPECIAL"

  /* Extraction: MULTU
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.0x0,6.0x19 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#line 2248 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.0x0,6.0x19 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x0000ffc0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2710 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "multu r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 2271 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MULTU_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2722 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    do_multu (SD_, RS, RT, 0);
  }
#line 2299 "semantics.c"
  return nia;
  /* Extraction: MULTU
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.0x0,6.0x19 */

#undef RS
#undef RT
#line 2307 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_DIV_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_DIV_SPECIAL
#undef DIV_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX DIV_SPECIAL
#undef MY_NAME
#define MY_NAME "DIV_SPECIAL"

  /* Extraction: DIV
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.0x0,6.0x1a */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#line 2332 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.0x0,6.0x1a */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x0000ffc0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1442 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "div r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 2355 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_DIV_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1456 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    do_div (SD_, RS, RT);
  }
#line 2383 "semantics.c"
  return nia;
  /* Extraction: DIV
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.0x0,6.0x1a */

#undef RS
#undef RT
#line 2391 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_DIVU_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_DIVU_SPECIAL
#undef DIVU_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX DIVU_SPECIAL
#undef MY_NAME
#define MY_NAME "DIVU_SPECIAL"

  /* Extraction: DIVU
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.0x0,6.0x1b */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#line 2416 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.0x0,6.0x1b */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x0000ffc0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1483 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "divu r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 2439 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_DIVU_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1497 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    do_divu (SD_, RS, RT);
  }
#line 2467 "semantics.c"
  return nia;
  /* Extraction: DIVU
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.0x0,6.0x1b */

#undef RS
#undef RT
#line 2475 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MOVtf_SPECIAL (SIM_DESC sd,
                        instruction_word instruction_0,
                        instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MOVtf_SPECIAL
#undef MOVtf_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX MOVtf_SPECIAL
#undef MY_NAME
#define MY_NAME "MOVtf_SPECIAL"

  /* Extraction: MOVtf
       #define do-not-use-icache
       6.0x0,5.RS,3.CC,1.0x0,1.TF,5.RD,5.0x0,6.0x1 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef CC
#define CC ((unsigned) EXTRACTED32 (instruction_0, 20, 18)) /* cache - extraction */
#undef TF
#define TF ((unsigned) EXTRACTED32 (instruction_0, 16, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 2504 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,3.CC,1.0x0,1.TF,5.RD,5.0x0,6.0x1 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000207c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4807 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mov%s r%ld, r%ld, %ld", \
                    str_TF (SD_, TF), \
                    (long) RD, \
                    (long) RS, \
                    (long) CC);
#line 2543 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MOVtf_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4816 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    check_fpu (SD_);
    if (GETFCC(CC) == TF)
      GPR[RD] = GPR[RS];
  }
#line 2573 "semantics.c"
  return nia;
  /* Extraction: MOVtf
       #undef do-not-use-icache
       6.0x0,5.RS,3.CC,1.0x0,1.TF,5.RD,5.0x0,6.0x1 */

#undef RS
#undef CC
#undef TF
#undef RD
#line 2583 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_JALR_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_JALR_SPECIAL
#undef JALR_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX JALR_SPECIAL
#undef MY_NAME
#define MY_NAME "JALR_SPECIAL"

  /* Extraction: JALR
       #define do-not-use-icache
       6.0x0,5.RS,5.0x0,5.RD,5.0x0,6.0x9 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 2608 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.0x0,5.RD,5.0x0,6.0x9 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f07c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
      if (RD == 31)
#line 1938 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
        trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                      itable[MY_INDEX].file, \
                      itable[MY_INDEX].line_nr, \
                      "jalr r%ld", \
                      (long) RS);
#line 2631 "semantics.c"
      else
#line 1939 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
        trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                      itable[MY_INDEX].file, \
                      itable[MY_INDEX].line_nr, \
                      "jalr r%ld, r%ld", \
                      (long) RD, \
                      (long) RS);
#line 2640 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_JALR_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1953 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    address_word temp = GPR[RS];
    GPR[RD] = CIA + 8;
    DELAY_SLOT (temp);
  }
#line 2670 "semantics.c"
  return nia;
  /* Extraction: JALR
       #undef do-not-use-icache
       6.0x0,5.RS,5.0x0,5.RD,5.0x0,6.0x9 */

#undef RS
#undef RD
#line 2678 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_JR_SPECIAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_JR_SPECIAL
#undef JR_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX JR_SPECIAL
#undef MY_NAME
#define MY_NAME "JR_SPECIAL"

  /* Extraction: JR
       #define do-not-use-icache
       6.0x0,5.RS,15.0x0,6.0x8 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#line 2701 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,15.0x0,6.0x8 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001fffc0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1960 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "jr r%ld", \
                    (long) RS);
#line 2723 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_JR_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1974 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    DELAY_SLOT (GPR[RS]);
  }
#line 2751 "semantics.c"
  return nia;
  /* Extraction: JR
       #undef do-not-use-icache
       6.0x0,5.RS,15.0x0,6.0x8 */

#undef RS
#line 2758 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MTHI_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MTHI_SPECIAL
#undef MTHI_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX MTHI_SPECIAL
#undef MY_NAME
#define MY_NAME "MTHI_SPECIAL"

  /* Extraction: MTHI
       #define do-not-use-icache
       6.0x0,5.RS,15.0x0,6.0x11 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#line 2781 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,15.0x0,6.0x11 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001fffc0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2597 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mthi r%ld", \
                    (long) RS);
#line 2803 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MTHI_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2607 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    check_mt_hilo (SD_, HIHISTORY);
    HI = GPR[RS];
  }
#line 2832 "semantics.c"
  return nia;
  /* Extraction: MTHI
       #undef do-not-use-icache
       6.0x0,5.RS,15.0x0,6.0x11 */

#undef RS
#line 2839 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MTLO_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MTLO_SPECIAL
#undef MTLO_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX MTLO_SPECIAL
#undef MY_NAME
#define MY_NAME "MTLO_SPECIAL"

  /* Extraction: MTLO
       #define do-not-use-icache
       6.0x0,5.RS,15.0x0,6.0x13 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#line 2862 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,15.0x0,6.0x13 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001fffc0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2614 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mtlo r%ld", \
                    (long) RS);
#line 2884 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MTLO_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2624 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    check_mt_hilo (SD_, LOHISTORY);
    LO = GPR[RS];
  }
#line 2913 "semantics.c"
  return nia;
  /* Extraction: MTLO
       #undef do-not-use-icache
       6.0x0,5.RS,15.0x0,6.0x13 */

#undef RS
#line 2920 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SLLa_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SLLa_SPECIAL
#undef SLLa_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SLLa_SPECIAL
#undef MY_NAME
#define MY_NAME "SLLa_SPECIAL"

  /* Extraction: SLLa
       #define do-not-use-icache
       6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x0 */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef SHIFT
#define SHIFT ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#line 2947 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x0 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x03e00000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
      if (RD == 0 && RT == 0 && SHIFT == 0)
#line 3155 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
        trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                      itable[MY_INDEX].file, \
                      itable[MY_INDEX].line_nr, \
                      "nop");
#line 2969 "semantics.c"
      else
#line 3156 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
        trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                      itable[MY_INDEX].file, \
                      itable[MY_INDEX].line_nr, \
                      "sll r%ld, r%ld, %ld", \
                      (long) RD, \
                      (long) RT, \
                      (long) SHIFT);
#line 2979 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SLLa_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3166 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    /* Skip shift for NOP, so that there won't be lots of extraneous
       trace output.  */
    if (RD != 0 || RT != 0 || SHIFT != 0)
      do_sll (SD_, RT, RD, SHIFT);
  }
#line 3010 "semantics.c"
  return nia;
  /* Extraction: SLLa
       #undef do-not-use-icache
       6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x0 */

#undef RT
#undef RD
#undef SHIFT
#line 3019 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SRL_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SRL_SPECIAL
#undef SRL_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SRL_SPECIAL
#undef MY_NAME
#define MY_NAME "SRL_SPECIAL"

  /* Extraction: SRL
       #define do-not-use-icache
       6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x2 */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef SHIFT
#define SHIFT ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#line 3046 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x2 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x03e00000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3393 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "srl r%ld, r%ld, %ld", \
                    (long) RD, \
                    (long) RT, \
                    (long) SHIFT);
#line 3070 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SRL_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3407 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    do_srl (SD_, RT, RD, SHIFT);
  }
#line 3098 "semantics.c"
  return nia;
  /* Extraction: SRL
       #undef do-not-use-icache
       6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x2 */

#undef RT
#undef RD
#undef SHIFT
#line 3107 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SRA_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SRA_SPECIAL
#undef SRA_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SRA_SPECIAL
#undef MY_NAME
#define MY_NAME "SRA_SPECIAL"

  /* Extraction: SRA
       #define do-not-use-icache
       6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x3 */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef SHIFT
#define SHIFT ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#line 3134 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x3 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x03e00000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3332 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sra r%ld, r%ld, %ld", \
                    (long) RD, \
                    (long) RT, \
                    (long) SHIFT);
#line 3158 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SRA_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3346 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    do_sra (SD_, RT, RD, SHIFT);
  }
#line 3186 "semantics.c"
  return nia;
  /* Extraction: SRA
       #undef do-not-use-icache
       6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x3 */

#undef RT
#undef RD
#undef SHIFT
#line 3195 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MFHI_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MFHI_SPECIAL
#undef MFHI_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX MFHI_SPECIAL
#undef MY_NAME
#define MY_NAME "MFHI_SPECIAL"

  /* Extraction: MFHI
       #define do-not-use-icache
       6.0x0,10.0x0,5.RD,5.0x0,6.0x10 */

#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 3218 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,10.0x0,5.RD,5.0x0,6.0x10 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x03ff07c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2475 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mfhi r%ld", \
                    (long) RD);
#line 3240 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MFHI_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2485 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    do_mfhi (SD_, RD);
  }
#line 3268 "semantics.c"
  return nia;
  /* Extraction: MFHI
       #undef do-not-use-icache
       6.0x0,10.0x0,5.RD,5.0x0,6.0x10 */

#undef RD
#line 3275 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MFLO_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MFLO_SPECIAL
#undef MFLO_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX MFLO_SPECIAL
#undef MY_NAME
#define MY_NAME "MFLO_SPECIAL"

  /* Extraction: MFLO
       #define do-not-use-icache
       6.0x0,10.0x0,5.RD,5.0x0,6.0x12 */

#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 3298 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,10.0x0,5.RD,5.0x0,6.0x12 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x03ff07c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2499 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mflo r%ld", \
                    (long) RD);
#line 3320 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MFLO_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2509 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    do_mflo (SD_, RD);
  }
#line 3348 "semantics.c"
  return nia;
  /* Extraction: MFLO
       #undef do-not-use-icache
       6.0x0,10.0x0,5.RD,5.0x0,6.0x12 */

#undef RD
#line 3355 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SYNC_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SYNC_SPECIAL
#undef SYNC_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SYNC_SPECIAL
#undef MY_NAME
#define MY_NAME "SYNC_SPECIAL"

  /* Extraction: SYNC
       #define do-not-use-icache
       6.0x0,15.0x0,5.STYPE,6.0xf */

#undef STYPE
#define STYPE ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#line 3378 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,15.0x0,5.STYPE,6.0xf */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x03fff800) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
      if (STYPE == 0)
#line 3573 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
        trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                      itable[MY_INDEX].file, \
                      itable[MY_INDEX].line_nr, \
                      "sync");
#line 3400 "semantics.c"
      else
#line 3574 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
        trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                      itable[MY_INDEX].file, \
                      itable[MY_INDEX].line_nr, \
                      "sync %ld", \
                      (long) STYPE);
#line 3408 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SYNC_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3587 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    SyncOperation (STYPE);
  }
#line 3436 "semantics.c"
  return nia;
  /* Extraction: SYNC
       #undef do-not-use-icache
       6.0x0,15.0x0,5.STYPE,6.0xf */

#undef STYPE
#line 3443 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BLTZ_REGIMM (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BLTZ_REGIMM
#undef BLTZ_REGIMM
#undef MY_PREFIX
#define MY_PREFIX BLTZ_REGIMM
#undef MY_NAME
#define MY_NAME "BLTZ_REGIMM"

  /* Extraction: BLTZ
       #define do-not-use-icache
       6.0x1,5.RS,5.0x0,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 3468 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0x0,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 937 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bltz r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 3486 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BLTZ_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 951 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if ((signed_word) GPR[RS] < 0)
      {
        DELAY_SLOT (NIA + offset);
      }
  }
#line 3518 "semantics.c"
  return nia;
  /* Extraction: BLTZ
       #undef do-not-use-icache
       6.0x1,5.RS,5.0x0,16.OFFSET */

#undef RS
#undef OFFSET
#line 3526 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BGEZ_REGIMM (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BGEZ_REGIMM
#undef BGEZ_REGIMM
#undef MY_PREFIX
#define MY_PREFIX BGEZ_REGIMM
#undef MY_NAME
#define MY_NAME "BGEZ_REGIMM"

  /* Extraction: BGEZ
       #define do-not-use-icache
       6.0x1,5.RS,5.0x1,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 3551 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0x1,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 729 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bgez r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 3569 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BGEZ_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 743 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if ((signed_word) GPR[RS] >= 0)
      {
        DELAY_SLOT (NIA + offset);
      }
  }
#line 3601 "semantics.c"
  return nia;
  /* Extraction: BGEZ
       #undef do-not-use-icache
       6.0x1,5.RS,5.0x1,16.OFFSET */

#undef RS
#undef OFFSET
#line 3609 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BLTZL_REGIMM (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BLTZL_REGIMM
#undef BLTZL_REGIMM
#undef MY_PREFIX
#define MY_PREFIX BLTZL_REGIMM
#undef MY_NAME
#define MY_NAME "BLTZL_REGIMM"

  /* Extraction: BLTZL
       #define do-not-use-icache
       6.0x1,5.RS,5.0x2,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 3634 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0x2,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1018 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bltzl r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 3652 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BLTZL_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1031 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    /* NOTE: The branch occurs AFTER the next instruction has been
       executed */
    if ((signed_word) GPR[RS] < 0)
      {
        DELAY_SLOT (NIA + offset);
      }
    else
      NULLIFY_NEXT_INSTRUCTION ();
  }
#line 3688 "semantics.c"
  return nia;
  /* Extraction: BLTZL
       #undef do-not-use-icache
       6.0x1,5.RS,5.0x2,16.OFFSET */

#undef RS
#undef OFFSET
#line 3696 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BGEZL_REGIMM (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BGEZL_REGIMM
#undef BGEZL_REGIMM
#undef MY_PREFIX
#define MY_PREFIX BGEZL_REGIMM
#undef MY_NAME
#define MY_NAME "BGEZL_REGIMM"

  /* Extraction: BGEZL
       #define do-not-use-icache
       6.0x1,5.RS,5.0x3,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 3721 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0x3,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 810 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bgezl r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 3739 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BGEZL_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 823 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if ((signed_word) GPR[RS] >= 0)
      {
        DELAY_SLOT (NIA + offset);
      }
    else
      NULLIFY_NEXT_INSTRUCTION ();
  }
#line 3773 "semantics.c"
  return nia;
  /* Extraction: BGEZL
       #undef do-not-use-icache
       6.0x1,5.RS,5.0x3,16.OFFSET */

#undef RS
#undef OFFSET
#line 3781 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TGEI_REGIMM (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TGEI_REGIMM
#undef TGEI_REGIMM
#undef MY_PREFIX
#define MY_PREFIX TGEI_REGIMM
#undef MY_NAME
#define MY_NAME "TGEI_REGIMM"

  /* Extraction: TGEI
       #define do-not-use-icache
       6.0x1,5.RS,5.0x8,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 3806 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0x8,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3665 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tgei r%ld, %ld", \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 3824 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TGEI_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3677 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    if ((signed_word) GPR[RS] >= (signed_word) EXTEND16 (IMMEDIATE))
      SignalException (Trap, instruction_0);
  }
#line 3853 "semantics.c"
  return nia;
  /* Extraction: TGEI
       #undef do-not-use-icache
       6.0x1,5.RS,5.0x8,16.IMMEDIATE */

#undef RS
#undef IMMEDIATE
#line 3861 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TGEIU_REGIMM (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TGEIU_REGIMM
#undef TGEIU_REGIMM
#undef MY_PREFIX
#define MY_PREFIX TGEIU_REGIMM
#undef MY_NAME
#define MY_NAME "TGEIU_REGIMM"

  /* Extraction: TGEIU
       #define do-not-use-icache
       6.0x1,5.RS,5.0x9,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 3886 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0x9,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3683 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tgeiu r%ld, %ld", \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 3904 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TGEIU_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3695 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    if ((unsigned_word) GPR[RS] >= (unsigned_word) EXTEND16 (IMMEDIATE))
      SignalException (Trap, instruction_0);
  }
#line 3933 "semantics.c"
  return nia;
  /* Extraction: TGEIU
       #undef do-not-use-icache
       6.0x1,5.RS,5.0x9,16.IMMEDIATE */

#undef RS
#undef IMMEDIATE
#line 3941 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TLTI_REGIMM (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TLTI_REGIMM
#undef TLTI_REGIMM
#undef MY_PREFIX
#define MY_PREFIX TLTI_REGIMM
#undef MY_NAME
#define MY_NAME "TLTI_REGIMM"

  /* Extraction: TLTI
       #define do-not-use-icache
       6.0x1,5.RS,5.0xa,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 3966 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0xa,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3737 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tlti r%ld, %ld", \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 3984 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TLTI_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3749 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    if ((signed_word) GPR[RS] < (signed_word) EXTEND16 (IMMEDIATE))
      SignalException (Trap, instruction_0);
  }
#line 4013 "semantics.c"
  return nia;
  /* Extraction: TLTI
       #undef do-not-use-icache
       6.0x1,5.RS,5.0xa,16.IMMEDIATE */

#undef RS
#undef IMMEDIATE
#line 4021 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TLTIU_REGIMM (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TLTIU_REGIMM
#undef TLTIU_REGIMM
#undef MY_PREFIX
#define MY_PREFIX TLTIU_REGIMM
#undef MY_NAME
#define MY_NAME "TLTIU_REGIMM"

  /* Extraction: TLTIU
       #define do-not-use-icache
       6.0x1,5.RS,5.0xb,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 4046 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0xb,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3755 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tltiu r%ld, %ld", \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 4064 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TLTIU_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3767 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    if ((unsigned_word) GPR[RS] < (unsigned_word) EXTEND16 (IMMEDIATE))
      SignalException (Trap, instruction_0);
  }
#line 4093 "semantics.c"
  return nia;
  /* Extraction: TLTIU
       #undef do-not-use-icache
       6.0x1,5.RS,5.0xb,16.IMMEDIATE */

#undef RS
#undef IMMEDIATE
#line 4101 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TEQI_REGIMM (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TEQI_REGIMM
#undef TEQI_REGIMM
#undef MY_PREFIX
#define MY_PREFIX TEQI_REGIMM
#undef MY_NAME
#define MY_NAME "TEQI_REGIMM"

  /* Extraction: TEQI
       #define do-not-use-icache
       6.0x1,5.RS,5.0xc,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 4126 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0xc,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3629 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "teqi r%ld, %ld", \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 4144 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TEQI_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3641 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    if ((signed_word) GPR[RS] == (signed_word) EXTEND16 (IMMEDIATE))
      SignalException (Trap, instruction_0);
  }
#line 4173 "semantics.c"
  return nia;
  /* Extraction: TEQI
       #undef do-not-use-icache
       6.0x1,5.RS,5.0xc,16.IMMEDIATE */

#undef RS
#undef IMMEDIATE
#line 4181 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TNEI_REGIMM (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TNEI_REGIMM
#undef TNEI_REGIMM
#undef MY_PREFIX
#define MY_PREFIX TNEI_REGIMM
#undef MY_NAME
#define MY_NAME "TNEI_REGIMM"

  /* Extraction: TNEI
       #define do-not-use-icache
       6.0x1,5.RS,5.0xe,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 4206 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0xe,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3809 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tnei r%ld, %ld", \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 4224 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TNEI_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3821 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    if ((signed_word) GPR[RS] != (signed_word) EXTEND16 (IMMEDIATE))
      SignalException (Trap, instruction_0);
  }
#line 4253 "semantics.c"
  return nia;
  /* Extraction: TNEI
       #undef do-not-use-icache
       6.0x1,5.RS,5.0xe,16.IMMEDIATE */

#undef RS
#undef IMMEDIATE
#line 4261 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BLTZAL_REGIMM (SIM_DESC sd,
                        instruction_word instruction_0,
                        instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BLTZAL_REGIMM
#undef BLTZAL_REGIMM
#undef MY_PREFIX
#define MY_PREFIX BLTZAL_REGIMM
#undef MY_NAME
#define MY_NAME "BLTZAL_REGIMM"

  /* Extraction: BLTZAL
       #define do-not-use-icache
       6.0x1,5.RS,5.0x10,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 4286 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0x10,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 961 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bltzal r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 4304 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BLTZAL_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 975 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if (RS == 31)
      Unpredictable ();
    RA = (CIA + 8);
    /* NOTE: The branch occurs AFTER the next instruction has been
       executed */
    if ((signed_word) GPR[RS] < 0)
      {
        DELAY_SLOT (NIA + offset);
      }
  }
#line 4341 "semantics.c"
  return nia;
  /* Extraction: BLTZAL
       #undef do-not-use-icache
       6.0x1,5.RS,5.0x10,16.OFFSET */

#undef RS
#undef OFFSET
#line 4349 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BGEZAL_REGIMM (SIM_DESC sd,
                        instruction_word instruction_0,
                        instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BGEZAL_REGIMM
#undef BGEZAL_REGIMM
#undef MY_PREFIX
#define MY_PREFIX BGEZAL_REGIMM
#undef MY_NAME
#define MY_NAME "BGEZAL_REGIMM"

  /* Extraction: BGEZAL
       #define do-not-use-icache
       6.0x1,5.RS,5.0x11,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 4374 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0x11,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 753 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bgezal r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 4392 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BGEZAL_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 767 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if (RS == 31)
      Unpredictable ();
    RA = (CIA + 8);
    if ((signed_word) GPR[RS] >= 0)
      {
        DELAY_SLOT (NIA + offset);
      }
  }
#line 4427 "semantics.c"
  return nia;
  /* Extraction: BGEZAL
       #undef do-not-use-icache
       6.0x1,5.RS,5.0x11,16.OFFSET */

#undef RS
#undef OFFSET
#line 4435 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BLTZALL_REGIMM (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BLTZALL_REGIMM
#undef BLTZALL_REGIMM
#undef MY_PREFIX
#define MY_PREFIX BLTZALL_REGIMM
#undef MY_NAME
#define MY_NAME "BLTZALL_REGIMM"

  /* Extraction: BLTZALL
       #define do-not-use-icache
       6.0x1,5.RS,5.0x12,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 4460 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0x12,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 990 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bltzall r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 4478 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BLTZALL_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1003 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if (RS == 31)
      Unpredictable ();
    RA = (CIA + 8);
    if ((signed_word) GPR[RS] < 0)
      {
        DELAY_SLOT (NIA + offset);
      }
    else
      NULLIFY_NEXT_INSTRUCTION ();
  }
#line 4515 "semantics.c"
  return nia;
  /* Extraction: BLTZALL
       #undef do-not-use-icache
       6.0x1,5.RS,5.0x12,16.OFFSET */

#undef RS
#undef OFFSET
#line 4523 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BGEZALL_REGIMM (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BGEZALL_REGIMM
#undef BGEZALL_REGIMM
#undef MY_PREFIX
#define MY_PREFIX BGEZALL_REGIMM
#undef MY_NAME
#define MY_NAME "BGEZALL_REGIMM"

  /* Extraction: BGEZALL
       #define do-not-use-icache
       6.0x1,5.RS,5.0x13,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 4548 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0x13,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 780 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bgezall r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 4566 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BGEZALL_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 793 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if (RS == 31)
      Unpredictable ();
    RA = (CIA + 8);
    /* NOTE: The branch occurs AFTER the next instruction has been
       executed */
    if ((signed_word) GPR[RS] >= 0)
      {
        DELAY_SLOT (NIA + offset);
      }
    else
      NULLIFY_NEXT_INSTRUCTION ();
  }
#line 4605 "semantics.c"
  return nia;
  /* Extraction: BGEZALL
       #undef do-not-use-icache
       6.0x1,5.RS,5.0x13,16.OFFSET */

#undef RS
#undef OFFSET
#line 4613 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_J_NORMAL (SIM_DESC sd,
                   instruction_word instruction_0,
                   instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_J_NORMAL
#undef J_NORMAL
#undef MY_PREFIX
#define MY_PREFIX J_NORMAL
#undef MY_NAME
#define MY_NAME "J_NORMAL"

  /* Extraction: J
       #define do-not-use-icache
       6.0x2,26.INSTR_INDEX */

#undef INSTR_INDEX
#define INSTR_INDEX ((unsigned) MASKED32 (instruction_0, 25, 0)) /* cache - extraction */
#line 4636 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x2,26.INSTR_INDEX */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1894 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "j %ld", \
                    (long) INSTR_INDEX);
#line 4653 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_J_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1908 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    /* NOTE: The region used is that of the delay slot NIA and NOT the
       current instruction */
    address_word region = (NIA & MASK (63, 28));
    DELAY_SLOT (region | (INSTR_INDEX << 2));
  }
#line 4684 "semantics.c"
  return nia;
  /* Extraction: J
       #undef do-not-use-icache
       6.0x2,26.INSTR_INDEX */

#undef INSTR_INDEX
#line 4691 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_JAL_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_JAL_NORMAL
#undef JAL_NORMAL
#undef MY_PREFIX
#define MY_PREFIX JAL_NORMAL
#undef MY_NAME
#define MY_NAME "JAL_NORMAL"

  /* Extraction: JAL
       #define do-not-use-icache
       6.0x3,26.INSTR_INDEX */

#undef INSTR_INDEX
#define INSTR_INDEX ((unsigned) MASKED32 (instruction_0, 25, 0)) /* cache - extraction */
#line 4714 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x3,26.INSTR_INDEX */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1916 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "jal %ld", \
                    (long) INSTR_INDEX);
#line 4731 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_JAL_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1930 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    /* NOTE: The region used is that of the delay slot and NOT the
       current instruction */
    address_word region = (NIA & MASK (63, 28));
    GPR[31] = CIA + 8;
    DELAY_SLOT (region | (INSTR_INDEX << 2));
  }
#line 4763 "semantics.c"
  return nia;
  /* Extraction: JAL
       #undef do-not-use-icache
       6.0x3,26.INSTR_INDEX */

#undef INSTR_INDEX
#line 4770 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BEQ_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BEQ_NORMAL
#undef BEQ_NORMAL
#undef MY_PREFIX
#define MY_PREFIX BEQ_NORMAL
#undef MY_NAME
#define MY_NAME "BEQ_NORMAL"

  /* Extraction: BEQ
       #define do-not-use-icache
       6.0x4,5.RS,5.RT,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 4797 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x4,5.RS,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 680 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "beq r%ld, r%ld, %ld", \
                    (long) RS, \
                    (long) RT, \
                    (long) OFFSET);
#line 4816 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BEQ_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 694 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if ((signed_word) GPR[RS] == (signed_word) GPR[RT])
      {
        DELAY_SLOT (NIA + offset);
      }
  }
#line 4848 "semantics.c"
  return nia;
  /* Extraction: BEQ
       #undef do-not-use-icache
       6.0x4,5.RS,5.RT,16.OFFSET */

#undef RS
#undef RT
#undef OFFSET
#line 4857 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BNE_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BNE_NORMAL
#undef BNE_NORMAL
#undef MY_PREFIX
#define MY_PREFIX BNE_NORMAL
#undef MY_NAME
#define MY_NAME "BNE_NORMAL"

  /* Extraction: BNE
       #define do-not-use-icache
       6.0x5,5.RS,5.RT,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 4884 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x5,5.RS,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1045 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bne r%ld, r%ld, %ld", \
                    (long) RS, \
                    (long) RT, \
                    (long) OFFSET);
#line 4903 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BNE_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1059 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if ((signed_word) GPR[RS] != (signed_word) GPR[RT])
      {
        DELAY_SLOT (NIA + offset);
      }
  }
#line 4935 "semantics.c"
  return nia;
  /* Extraction: BNE
       #undef do-not-use-icache
       6.0x5,5.RS,5.RT,16.OFFSET */

#undef RS
#undef RT
#undef OFFSET
#line 4944 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BLEZ_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BLEZ_NORMAL
#undef BLEZ_NORMAL
#undef MY_PREFIX
#define MY_PREFIX BLEZ_NORMAL
#undef MY_NAME
#define MY_NAME "BLEZ_NORMAL"

  /* Extraction: BLEZ
       #define do-not-use-icache
       6.0x6,5.RS,5.0x0,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 4969 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x6,5.RS,5.0x0,16.OFFSET */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 886 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "blez r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 4992 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BLEZ_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 900 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    /* NOTE: The branch occurs AFTER the next instruction has been
       executed */
    if ((signed_word) GPR[RS] <= 0)
      {
        DELAY_SLOT (NIA + offset);
      }
  }
#line 5026 "semantics.c"
  return nia;
  /* Extraction: BLEZ
       #undef do-not-use-icache
       6.0x6,5.RS,5.0x0,16.OFFSET */

#undef RS
#undef OFFSET
#line 5034 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BGTZ_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BGTZ_NORMAL
#undef BGTZ_NORMAL
#undef MY_PREFIX
#define MY_PREFIX BGTZ_NORMAL
#undef MY_NAME
#define MY_NAME "BGTZ_NORMAL"

  /* Extraction: BGTZ
       #define do-not-use-icache
       6.0x7,5.RS,5.0x0,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 5059 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x7,5.RS,5.0x0,16.OFFSET */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 835 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bgtz r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 5082 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BGTZ_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 849 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if ((signed_word) GPR[RS] > 0)
      {
        DELAY_SLOT (NIA + offset);
      }
  }
#line 5114 "semantics.c"
  return nia;
  /* Extraction: BGTZ
       #undef do-not-use-icache
       6.0x7,5.RS,5.0x0,16.OFFSET */

#undef RS
#undef OFFSET
#line 5122 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ADDI_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ADDI_NORMAL
#undef ADDI_NORMAL
#undef MY_PREFIX
#define MY_PREFIX ADDI_NORMAL
#undef MY_NAME
#define MY_NAME "ADDI_NORMAL"

  /* Extraction: ADDI
       #define do-not-use-icache
       6.0x8,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 5149 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x8,5.RS,5.RT,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 545 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "addi r%ld, r%ld, %ld", \
                    (long) RT, \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 5168 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ADDI_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 559 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    if (NotWordValue (GPR[RS]))
      Unpredictable ();
    TRACE_ALU_INPUT2 (GPR[RS], EXTEND16 (IMMEDIATE));
    {
      ALU32_BEGIN (GPR[RS]);
      ALU32_ADD (EXTEND16 (IMMEDIATE));
      ALU32_END (GPR[RT]);   /* This checks for overflow.  */
    }
    TRACE_ALU_RESULT (GPR[RT]);
  }
#line 5204 "semantics.c"
  return nia;
  /* Extraction: ADDI
       #undef do-not-use-icache
       6.0x8,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#undef RT
#undef IMMEDIATE
#line 5213 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ADDIU_NORMAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ADDIU_NORMAL
#undef ADDIU_NORMAL
#undef MY_PREFIX
#define MY_PREFIX ADDIU_NORMAL
#undef MY_NAME
#define MY_NAME "ADDIU_NORMAL"

  /* Extraction: ADDIU
       #define do-not-use-icache
       6.0x9,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 5240 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x9,5.RS,5.RT,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 582 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "addiu r%ld, r%ld, %ld", \
                    (long) RT, \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 5259 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ADDIU_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 596 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    do_addiu (SD_, RS, RT, IMMEDIATE);
  }
#line 5287 "semantics.c"
  return nia;
  /* Extraction: ADDIU
       #undef do-not-use-icache
       6.0x9,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#undef RT
#undef IMMEDIATE
#line 5296 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SLTI_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SLTI_NORMAL
#undef SLTI_NORMAL
#undef MY_PREFIX
#define MY_PREFIX SLTI_NORMAL
#undef MY_NAME
#define MY_NAME "SLTI_NORMAL"

  /* Extraction: SLTI
       #define do-not-use-icache
       6.0xa,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 5323 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0xa,5.RS,5.RT,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3250 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "slti r%ld, r%ld, %ld", \
                    (long) RT, \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 5342 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SLTI_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3264 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    do_slti (SD_, RS, RT, IMMEDIATE);
  }
#line 5370 "semantics.c"
  return nia;
  /* Extraction: SLTI
       #undef do-not-use-icache
       6.0xa,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#undef RT
#undef IMMEDIATE
#line 5379 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SLTIU_NORMAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SLTIU_NORMAL
#undef SLTIU_NORMAL
#undef MY_PREFIX
#define MY_PREFIX SLTIU_NORMAL
#undef MY_NAME
#define MY_NAME "SLTIU_NORMAL"

  /* Extraction: SLTIU
       #define do-not-use-icache
       6.0xb,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 5406 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0xb,5.RS,5.RT,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3276 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sltiu r%ld, r%ld, %ld", \
                    (long) RT, \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 5425 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SLTIU_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3290 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    do_sltiu (SD_, RS, RT, IMMEDIATE);
  }
#line 5453 "semantics.c"
  return nia;
  /* Extraction: SLTIU
       #undef do-not-use-icache
       6.0xb,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#undef RT
#undef IMMEDIATE
#line 5462 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ANDI_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ANDI_NORMAL
#undef ANDI_NORMAL
#undef MY_PREFIX
#define MY_PREFIX ANDI_NORMAL
#undef MY_NAME
#define MY_NAME "ANDI_NORMAL"

  /* Extraction: ANDI
       #define do-not-use-icache
       6.0xc,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 5489 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0xc,5.RS,5.RT,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 658 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "andi r%ld, r%ld, %#lx", \
                    (long) RT, \
                    (long) RS, \
                    (unsigned long) IMMEDIATE);
#line 5508 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ANDI_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 672 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    TRACE_ALU_INPUT2 (GPR[RS], IMMEDIATE);
    GPR[RT] = GPR[RS] & IMMEDIATE;
    TRACE_ALU_RESULT (GPR[RT]);
  }
#line 5538 "semantics.c"
  return nia;
  /* Extraction: ANDI
       #undef do-not-use-icache
       6.0xc,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#undef RT
#undef IMMEDIATE
#line 5547 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ORI_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ORI_NORMAL
#undef ORI_NORMAL
#undef MY_PREFIX
#define MY_PREFIX ORI_NORMAL
#undef MY_NAME
#define MY_NAME "ORI_NORMAL"

  /* Extraction: ORI
       #define do-not-use-icache
       6.0xd,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 5574 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0xd,5.RS,5.RT,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2796 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "ori r%ld, r%ld, %#lx", \
                    (long) RT, \
                    (long) RS, \
                    (unsigned long) IMMEDIATE);
#line 5593 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ORI_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2810 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    do_ori (SD_, RS, RT, IMMEDIATE);
  }
#line 5621 "semantics.c"
  return nia;
  /* Extraction: ORI
       #undef do-not-use-icache
       6.0xd,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#undef RT
#undef IMMEDIATE
#line 5630 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_XORI_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_XORI_NORMAL
#undef XORI_NORMAL
#undef MY_PREFIX
#define MY_PREFIX XORI_NORMAL
#undef MY_NAME
#define MY_NAME "XORI_NORMAL"

  /* Extraction: XORI
       #define do-not-use-icache
       6.0xe,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 5657 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0xe,5.RS,5.RT,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3860 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "xori r%ld, r%ld, %#lx", \
                    (long) RT, \
                    (long) RS, \
                    (unsigned long) IMMEDIATE);
#line 5676 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_XORI_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3874 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    do_xori (SD_, RS, RT, IMMEDIATE);
  }
#line 5704 "semantics.c"
  return nia;
  /* Extraction: XORI
       #undef do-not-use-icache
       6.0xe,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#undef RT
#undef IMMEDIATE
#line 5713 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LUI_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LUI_NORMAL
#undef LUI_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LUI_NORMAL
#undef MY_NAME
#define MY_NAME "LUI_NORMAL"

  /* Extraction: LUI
       #define do-not-use-icache
       6.0xf,5.0x0,5.RT,16.IMMEDIATE */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 5738 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0xf,5.0x0,5.RT,16.IMMEDIATE */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x03e00000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2311 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lui r%ld, %#lx", \
                    (long) RT, \
                    (unsigned long) IMMEDIATE);
#line 5761 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LUI_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2325 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    TRACE_ALU_INPUT1 (IMMEDIATE);
    GPR[RT] = EXTEND32 (IMMEDIATE << 16);
    TRACE_ALU_RESULT (GPR[RT]);
  }
#line 5791 "semantics.c"
  return nia;
  /* Extraction: LUI
       #undef do-not-use-icache
       6.0xf,5.0x0,5.RT,16.IMMEDIATE */

#undef RT
#undef IMMEDIATE
#line 5799 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_COPz_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_COPz_NORMAL
#undef COPz_NORMAL
#undef MY_PREFIX
#define MY_PREFIX COPz_NORMAL
#undef MY_NAME
#define MY_NAME "COPz_NORMAL"

  /* Extraction: COPz
       #define do-not-use-icache
       4.0x4,2.ZZ,5.COP_FUN0,5.COP_FUN1,16.COP_FUN2 */

#undef ZZ
#define ZZ ((unsigned) EXTRACTED32 (instruction_0, 27, 26)) /* cache - extraction */
#undef COP_FUN0
#define COP_FUN0 ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef COP_FUN1
#define COP_FUN1 ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef COP_FUN2
#define COP_FUN2 ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 5828 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 4.0x4,2.ZZ,5.COP_FUN0,5.COP_FUN1,16.COP_FUN2 */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5599 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "cop%ld %ld%ld%ld", \
                    (long) ZZ, \
                    (long) COP_FUN0, \
                    (long) COP_FUN1, \
                    (long) COP_FUN2);
#line 5848 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_COPz_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5612 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    DecodeCoproc (instruction_0);
  }
#line 5876 "semantics.c"
  return nia;
  /* Extraction: COPz
       #undef do-not-use-icache
       4.0x4,2.ZZ,5.COP_FUN0,5.COP_FUN1,16.COP_FUN2 */

#undef ZZ
#undef COP_FUN0
#undef COP_FUN1
#undef COP_FUN2
#line 5886 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MFC0_COP0 (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MFC0_COP0
#undef MFC0_COP0
#undef MY_PREFIX
#define MY_PREFIX MFC0_COP0
#undef MY_NAME
#define MY_NAME "MFC0_COP0"

  /* Extraction: MFC0
       #define do-not-use-icache
       6.0x10,5.0x0,5.RT,5.RD,5.0x0,6.REGX */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef REGX
#define REGX ((unsigned) MASKED32 (instruction_0, 5, 0)) /* cache - extraction */
#line 5913 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,5.0x0,5.RT,5.RD,5.0x0,6.REGX */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x026007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5545 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mfc0 r%ld, r%ld # %ld", \
                    (long) RT, \
                    (long) RD, \
                    (long) REGX);
#line 5937 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MFC0_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5559 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    TRACE_ALU_INPUT0 ();
    DecodeCoproc (instruction_0);
    TRACE_ALU_RESULT (GPR[RT]);
  }
#line 5967 "semantics.c"
  return nia;
  /* Extraction: MFC0
       #undef do-not-use-icache
       6.0x10,5.0x0,5.RT,5.RD,5.0x0,6.REGX */

#undef RT
#undef RD
#undef REGX
#line 5976 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MTC0_COP0 (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MTC0_COP0
#undef MTC0_COP0
#undef MY_PREFIX
#define MY_PREFIX MTC0_COP0
#undef MY_NAME
#define MY_NAME "MTC0_COP0"

  /* Extraction: MTC0
       #define do-not-use-icache
       6.0x10,5.0x4,5.RT,5.RD,5.0x0,6.REGX */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef REGX
#define REGX ((unsigned) MASKED32 (instruction_0, 5, 0)) /* cache - extraction */
#line 6003 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,5.0x4,5.RT,5.RD,5.0x0,6.REGX */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x026007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5565 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mtc0 r%ld, r%ld # %ld", \
                    (long) RT, \
                    (long) RD, \
                    (long) REGX);
#line 6027 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MTC0_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5579 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    DecodeCoproc (instruction_0);
  }
#line 6055 "semantics.c"
  return nia;
  /* Extraction: MTC0
       #undef do-not-use-icache
       6.0x10,5.0x4,5.RT,5.RD,5.0x0,6.REGX */

#undef RT
#undef RD
#undef REGX
#line 6064 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BC0F_COP0 (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BC0F_COP0
#undef BC0F_COP0
#undef MY_PREFIX
#define MY_PREFIX BC0F_COP0
#undef MY_NAME
#define MY_NAME "BC0F_COP0"

  /* Extraction: BC0F
       #define do-not-use-icache
       6.0x10,5.0x8,5.0x0,16.OFFSET */

#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 6087 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,5.0x8,5.0x0,16.OFFSET */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x027c0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5400 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bc0f %ld", \
                    (long) OFFSET);
#line 6109 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BC0F_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
#line 5399 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  sim_engine_abort (SD, CPU, cia, \
                    "mips.igen:5399:0x%08lx:%s unimplemented\n", \
                    (long) CIA, \
                    itable[MY_INDEX].name);
#line 6138 "semantics.c"
  return nia;
  /* Extraction: BC0F
       #undef do-not-use-icache
       6.0x10,5.0x8,5.0x0,16.OFFSET */

#undef OFFSET
#line 6145 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BC0T_COP0 (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BC0T_COP0
#undef BC0T_COP0
#undef MY_PREFIX
#define MY_PREFIX BC0T_COP0
#undef MY_NAME
#define MY_NAME "BC0T_COP0"

  /* Extraction: BC0T
       #define do-not-use-icache
       6.0x10,5.0x8,5.0x1,16.OFFSET */

#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 6168 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,5.0x8,5.0x1,16.OFFSET */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x027c0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5438 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bc0t %ld", \
                    (long) OFFSET);
#line 6190 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BC0T_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
#line 5437 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  sim_engine_abort (SD, CPU, cia, \
                    "mips.igen:5437:0x%08lx:%s unimplemented\n", \
                    (long) CIA, \
                    itable[MY_INDEX].name);
#line 6219 "semantics.c"
  return nia;
  /* Extraction: BC0T
       #undef do-not-use-icache
       6.0x10,5.0x8,5.0x1,16.OFFSET */

#undef OFFSET
#line 6226 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BC0FL_COP0 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BC0FL_COP0
#undef BC0FL_COP0
#undef MY_PREFIX
#define MY_PREFIX BC0FL_COP0
#undef MY_NAME
#define MY_NAME "BC0FL_COP0"

  /* Extraction: BC0FL
       #define do-not-use-icache
       6.0x10,5.0x8,5.0x2,16.OFFSET */

#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 6249 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,5.0x8,5.0x2,16.OFFSET */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x027c0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5423 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bc0fl %ld", \
                    (long) OFFSET);
#line 6271 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BC0FL_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
#line 5422 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  sim_engine_abort (SD, CPU, cia, \
                    "mips.igen:5422:0x%08lx:%s unimplemented\n", \
                    (long) CIA, \
                    itable[MY_INDEX].name);
#line 6300 "semantics.c"
  return nia;
  /* Extraction: BC0FL
       #undef do-not-use-icache
       6.0x10,5.0x8,5.0x2,16.OFFSET */

#undef OFFSET
#line 6307 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BC0TL_COP0 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BC0TL_COP0
#undef BC0TL_COP0
#undef MY_PREFIX
#define MY_PREFIX BC0TL_COP0
#undef MY_NAME
#define MY_NAME "BC0TL_COP0"

  /* Extraction: BC0TL
       #define do-not-use-icache
       6.0x10,5.0x8,5.0x3,16.OFFSET */

#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 6330 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,5.0x8,5.0x3,16.OFFSET */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x027c0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5452 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bc0tl %ld", \
                    (long) OFFSET);
#line 6352 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BC0TL_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
#line 5451 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  sim_engine_abort (SD, CPU, cia, \
                    "mips.igen:5451:0x%08lx:%s unimplemented\n", \
                    (long) CIA, \
                    itable[MY_INDEX].name);
#line 6381 "semantics.c"
  return nia;
  /* Extraction: BC0TL
       #undef do-not-use-icache
       6.0x10,5.0x8,5.0x3,16.OFFSET */

#undef OFFSET
#line 6388 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TLBR_COP0 (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TLBR_COP0
#undef TLBR_COP0
#undef MY_PREFIX
#define MY_PREFIX TLBR_COP0
#undef MY_NAME
#define MY_NAME "TLBR_COP0"

  /* Extraction: TLBR
       #define do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x1 */

#line 6409 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,1.0x1,19.0x0,6.0x1 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x007cffe0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5633 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tlbr");
#line 6430 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TLBR_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
#line 5632 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  sim_engine_abort (SD, CPU, cia, \
                    "mips.igen:5632:0x%08lx:%s unimplemented\n", \
                    (long) CIA, \
                    itable[MY_INDEX].name);
#line 6459 "semantics.c"
  return nia;
  /* Extraction: TLBR
       #undef do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x1 */

#line 6465 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TLBWI_COP0 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TLBWI_COP0
#undef TLBWI_COP0
#undef MY_PREFIX
#define MY_PREFIX TLBWI_COP0
#undef MY_NAME
#define MY_NAME "TLBWI_COP0"

  /* Extraction: TLBWI
       #define do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x2 */

#line 6486 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,1.0x1,19.0x0,6.0x2 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x007cffe0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5648 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tlbwi");
#line 6507 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TLBWI_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
#line 5647 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  sim_engine_abort (SD, CPU, cia, \
                    "mips.igen:5647:0x%08lx:%s unimplemented\n", \
                    (long) CIA, \
                    itable[MY_INDEX].name);
#line 6536 "semantics.c"
  return nia;
  /* Extraction: TLBWI
       #undef do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x2 */

#line 6542 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TLBWR_COP0 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TLBWR_COP0
#undef TLBWR_COP0
#undef MY_PREFIX
#define MY_PREFIX TLBWR_COP0
#undef MY_NAME
#define MY_NAME "TLBWR_COP0"

  /* Extraction: TLBWR
       #define do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x6 */

#line 6563 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,1.0x1,19.0x0,6.0x6 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x007cffe0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5663 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tlbwr");
#line 6584 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TLBWR_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
#line 5662 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  sim_engine_abort (SD, CPU, cia, \
                    "mips.igen:5662:0x%08lx:%s unimplemented\n", \
                    (long) CIA, \
                    itable[MY_INDEX].name);
#line 6613 "semantics.c"
  return nia;
  /* Extraction: TLBWR
       #undef do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x6 */

#line 6619 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TLBP_COP0 (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TLBP_COP0
#undef TLBP_COP0
#undef MY_PREFIX
#define MY_PREFIX TLBP_COP0
#undef MY_NAME
#define MY_NAME "TLBP_COP0"

  /* Extraction: TLBP
       #define do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x8 */

#line 6640 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,1.0x1,19.0x0,6.0x8 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x007cffe0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5618 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tlbp");
#line 6661 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TLBP_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
#line 5617 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  sim_engine_abort (SD, CPU, cia, \
                    "mips.igen:5617:0x%08lx:%s unimplemented\n", \
                    (long) CIA, \
                    itable[MY_INDEX].name);
#line 6690 "semantics.c"
  return nia;
  /* Extraction: TLBP
       #undef do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x8 */

#line 6696 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_RFE_COP0 (SIM_DESC sd,
                   instruction_word instruction_0,
                   instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_RFE_COP0
#undef RFE_COP0
#undef MY_PREFIX
#define MY_PREFIX RFE_COP0
#undef MY_NAME
#define MY_NAME "RFE_COP0"

  /* Extraction: RFE
       #define do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x10 */

#line 6717 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,1.0x1,19.0x0,6.0x10 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x007cffe0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5584 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "rfe");
#line 6738 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_RFE_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5594 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    DecodeCoproc (instruction_0);
  }
#line 6766 "semantics.c"
  return nia;
  /* Extraction: RFE
       #undef do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x10 */

#line 6772 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ERET_COP0 (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ERET_COP0
#undef ERET_COP0
#undef MY_PREFIX
#define MY_PREFIX ERET_COP0
#undef MY_NAME
#define MY_NAME "ERET_COP0"

  /* Extraction: ERET
       #define do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x18 */

#line 6793 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,1.0x1,19.0x0,6.0x18 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x007cffe0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5518 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "eret");
#line 6814 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ERET_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5529 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    if (SR & status_ERL)
      {
        /* Oops, not yet available */
        sim_io_printf (SD, "Warning: ERET when SR[ERL] set not supported");
        NIA = EPC;
        SR &= ~status_ERL;
      }
    else
      {
        NIA = EPC;
        SR &= ~status_EXL;
      }
  }
#line 6853 "semantics.c"
  return nia;
  /* Extraction: ERET
       #undef do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x18 */

#line 6859 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MFC1b_COP1 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MFC1b_COP1
#undef MFC1b_COP1
#undef MY_PREFIX
#define MY_PREFIX MFC1b_COP1
#undef MY_NAME
#define MY_NAME "MFC1b_COP1"

  /* Extraction: MFC1b
       #define do-not-use-icache
       6.0x11,5.0x0,5.RT,5.FS,11.0x0 */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 6884 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,5.0x0,5.RT,5.FS,11.0x0 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4765 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mfc1 r%ld, f%ld", \
                    (long) RT, \
                    (long) FS);
#line 6921 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MFC1b_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4776 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    check_fpu (SD_);
    GPR[RT] = EXTEND32 (FGR[FS]);
    TRACE_ALU_RESULT (GPR[RT]);
  }
#line 6951 "semantics.c"
  return nia;
  /* Extraction: MFC1b
       #undef do-not-use-icache
       6.0x11,5.0x0,5.RT,5.FS,11.0x0 */

#undef RT
#undef FS
#line 6959 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_CFC1b_COP1 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_CFC1b_COP1
#undef CFC1b_COP1
#undef MY_PREFIX
#define MY_PREFIX CFC1b_COP1
#undef MY_NAME
#define MY_NAME "CFC1b_COP1"

  /* Extraction: CFC1b
       #define do-not-use-icache
       6.0x11,5.0x2,5.RT,5.FS,11.0x0 */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 6984 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,5.0x2,5.RT,5.FS,11.0x0 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4288 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "cfc1 r%ld, f%ld", \
                    (long) RT, \
                    (long) FS);
#line 7021 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_CFC1b_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4294 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    check_fpu (SD_);
    if (FS == 0 || FS == 31)
      {
        unsigned_word  fcr = ValueFCR (FS);
        TRACE_ALU_INPUT1 (fcr);
        GPR[RT] = fcr;
      }
    /* else NOP */
    TRACE_ALU_RESULT (GPR[RT]);
  }
#line 7057 "semantics.c"
  return nia;
  /* Extraction: CFC1b
       #undef do-not-use-icache
       6.0x11,5.0x2,5.RT,5.FS,11.0x0 */

#undef RT
#undef FS
#line 7065 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MTC1b_COP1 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MTC1b_COP1
#undef MTC1b_COP1
#undef MY_PREFIX
#define MY_PREFIX MTC1b_COP1
#undef MY_NAME
#define MY_NAME "MTC1b_COP1"

  /* Extraction: MTC1b
       #define do-not-use-icache
       6.0x11,5.0x4,5.RT,5.FS,11.0x0 */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 7090 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,5.0x4,5.RT,5.FS,11.0x0 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4930 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mtc1 r%ld, f%ld", \
                    (long) RT, \
                    (long) FS);
#line 7127 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MTC1b_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4941 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    check_fpu (SD_); 
    StoreFPR (FS, fmt_uninterpreted_32, VL4_8 (GPR[RT]));
  }
#line 7156 "semantics.c"
  return nia;
  /* Extraction: MTC1b
       #undef do-not-use-icache
       6.0x11,5.0x4,5.RT,5.FS,11.0x0 */

#undef RT
#undef FS
#line 7164 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_CTC1b_COP1 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_CTC1b_COP1
#undef CTC1b_COP1
#undef MY_PREFIX
#define MY_PREFIX CTC1b_COP1
#undef MY_NAME
#define MY_NAME "CTC1b_COP1"

  /* Extraction: CTC1b
       #define do-not-use-icache
       6.0x11,5.0x6,5.RT,5.FS,11.0x0 */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 7189 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,5.0x6,5.RT,5.FS,11.0x0 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4337 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "ctc1 r%ld, f%ld", \
                    (long) RT, \
                    (long) FS);
#line 7226 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_CTC1b_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4343 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    check_fpu (SD_);
    TRACE_ALU_INPUT1 (GPR[RT]);
    if (FS == 31)
      StoreFCR (FS, GPR[RT]);
    /* else NOP */
  }
#line 7258 "semantics.c"
  return nia;
  /* Extraction: CTC1b
       #undef do-not-use-icache
       6.0x11,5.0x6,5.RT,5.FS,11.0x0 */

#undef RT
#undef FS
#line 7266 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BC1b_COP1S (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BC1b_COP1S
#undef BC1b_COP1S
#undef MY_PREFIX
#define MY_PREFIX BC1b_COP1S
#undef MY_NAME
#define MY_NAME "BC1b_COP1S"

  /* Extraction: BC1b
       #define do-not-use-icache
       6.0x11,5.0x8,3.CC,1.ND,1.TF,16.OFFSET */

#undef CC
#define CC ((unsigned) EXTRACTED32 (instruction_0, 20, 18)) /* cache - extraction */
#undef ND
#define ND ((unsigned) EXTRACTED32 (instruction_0, 17, 17)) /* cache - extraction */
#undef TF
#define TF ((unsigned) EXTRACTED32 (instruction_0, 16, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 7295 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,5.0x8,3.CC,1.ND,1.TF,16.OFFSET */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x03e00000) != 0x01000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
      if (CC == 0)
#line 4176 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
        trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                      itable[MY_INDEX].file, \
                      itable[MY_INDEX].line_nr, \
                      "bc1%s%s %ld", \
                      str_TF (SD_, TF), \
                      str_ND (SD_, ND), \
                      (long) OFFSET);
#line 7334 "semantics.c"
      else
#line 4177 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
        trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                      itable[MY_INDEX].file, \
                      itable[MY_INDEX].line_nr, \
                      "bc1%s%s %ld, %ld", \
                      str_TF (SD_, TF), \
                      str_ND (SD_, ND), \
                      (long) CC, \
                      (long) OFFSET);
#line 7345 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BC1b_COP1S, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4188 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    check_fpu (SD_);
    if (GETFCC(CC) == TF)
      {
        address_word dest = NIA + (EXTEND16 (OFFSET) << 2);
        DELAY_SLOT (dest);
      }
    else if (ND)
      {
        NULLIFY_NEXT_INSTRUCTION ();
      }
  }
#line 7382 "semantics.c"
  return nia;
  /* Extraction: BC1b
       #undef do-not-use-icache
       6.0x11,5.0x8,3.CC,1.ND,1.TF,16.OFFSET */

#undef CC
#undef ND
#undef TF
#undef OFFSET
#line 7392 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ADD_fmt_COP1 (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ADD_fmt_COP1
#undef ADD_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX ADD_fmt_COP1
#undef MY_NAME
#define MY_NAME "ADD_fmt_COP1"

  /* Extraction: ADD.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.FT,5.FS,5.FD,6.0x0 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#line 7421 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.FT,5.FS,5.FD,6.0x0 */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4096 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "add.%s f%ld, f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS, \
                    (long) FT);
#line 7455 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ADD_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4110 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    check_fmt_p (SD_, fmt, instruction_0);
    StoreFPR (FD, fmt, Add (ValueFPR (FS, fmt), ValueFPR (FT, fmt), fmt));
  }
#line 7486 "semantics.c"
  return nia;
  /* Extraction: ADD.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.FT,5.FS,5.FD,6.0x0 */

#undef FMT
#undef FT
#undef FS
#undef FD
#line 7496 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SUB_fmt_COP1 (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SUB_fmt_COP1
#undef SUB_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX SUB_fmt_COP1
#undef MY_NAME
#define MY_NAME "SUB_fmt_COP1"

  /* Extraction: SUB.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.FT,5.FS,5.FD,6.0x1 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#line 7525 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.FT,5.FS,5.FD,6.0x1 */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5244 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sub.%s f%ld, f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS, \
                    (long) FT);
#line 7559 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SUB_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5258 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    check_fmt_p (SD_, fmt, instruction_0);
    StoreFPR (FD, fmt, Sub (ValueFPR (FS, fmt), ValueFPR (FT, fmt), fmt));
  }
#line 7590 "semantics.c"
  return nia;
  /* Extraction: SUB.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.FT,5.FS,5.FD,6.0x1 */

#undef FMT
#undef FT
#undef FS
#undef FD
#line 7600 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MUL_fmt_COP1 (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MUL_fmt_COP1
#undef MUL_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX MUL_fmt_COP1
#undef MY_NAME
#define MY_NAME "MUL_fmt_COP1"

  /* Extraction: MUL.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.FT,5.FS,5.FD,6.0x2 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#line 7629 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.FT,5.FS,5.FD,6.0x2 */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4947 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mul.%s f%ld, f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS, \
                    (long) FT);
#line 7663 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MUL_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4961 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    check_fmt_p (SD_, fmt, instruction_0);
    StoreFPR (FD, fmt, Multiply (ValueFPR (FS, fmt), ValueFPR (FT, fmt), fmt));
  }
#line 7694 "semantics.c"
  return nia;
  /* Extraction: MUL.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.FT,5.FS,5.FD,6.0x2 */

#undef FMT
#undef FT
#undef FS
#undef FD
#line 7704 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_DIV_fmt_COP1 (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_DIV_fmt_COP1
#undef DIV_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX DIV_fmt_COP1
#undef MY_NAME
#define MY_NAME "DIV_fmt_COP1"

  /* Extraction: DIV.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.FT,5.FS,5.FD,6.0x3 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#line 7733 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.FT,5.FS,5.FD,6.0x3 */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4502 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "div.%s f%ld, f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS, \
                    (long) FT);
#line 7767 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_DIV_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4516 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    StoreFPR (FD, fmt, Divide (ValueFPR (FS, fmt), ValueFPR (FT, fmt), fmt));
  }
#line 7797 "semantics.c"
  return nia;
  /* Extraction: DIV.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.FT,5.FS,5.FD,6.0x3 */

#undef FMT
#undef FT
#undef FS
#undef FD
#line 7807 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MOVZ_fmt_COP1 (SIM_DESC sd,
                        instruction_word instruction_0,
                        instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MOVZ_fmt_COP1
#undef MOVZ_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX MOVZ_fmt_COP1
#undef MY_NAME
#define MY_NAME "MOVZ_fmt_COP1"

  /* Extraction: MOVZ.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.RT,5.FS,5.FD,6.0x12 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#line 7836 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.RT,5.FS,5.FD,6.0x12 */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4881 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "movz.%s f%ld, f%ld, r%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS, \
                    (long) RT);
#line 7870 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MOVZ_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4890 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    check_fpu (SD_);
    if (GPR[RT] == 0)
      StoreFPR (FD, FMT, ValueFPR (FS, FMT));
    else
      StoreFPR (FD, FMT, ValueFPR (FD, FMT));
  }
#line 7902 "semantics.c"
  return nia;
  /* Extraction: MOVZ.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.RT,5.FS,5.FD,6.0x12 */

#undef FMT
#undef RT
#undef FS
#undef FD
#line 7912 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MOVN_fmt_COP1 (SIM_DESC sd,
                        instruction_word instruction_0,
                        instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MOVN_fmt_COP1
#undef MOVN_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX MOVN_fmt_COP1
#undef MY_NAME
#define MY_NAME "MOVN_fmt_COP1"

  /* Extraction: MOVN.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.RT,5.FS,5.FD,6.0x13 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#line 7941 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.RT,5.FS,5.FD,6.0x13 */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4856 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "movn.%s f%ld, f%ld, r%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS, \
                    (long) RT);
#line 7975 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MOVN_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4865 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    check_fpu (SD_);
    if (GPR[RT] != 0)
      StoreFPR (FD, FMT, ValueFPR (FS, FMT));
    else
      StoreFPR (FD, FMT, ValueFPR (FD, FMT));
  }
#line 8007 "semantics.c"
  return nia;
  /* Extraction: MOVN.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.RT,5.FS,5.FD,6.0x13 */

#undef FMT
#undef RT
#undef FS
#undef FD
#line 8017 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_C_cond_fmtb_COP1 (SIM_DESC sd,
                           instruction_word instruction_0,
                           instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_C_cond_fmtb_COP1
#undef C_cond_fmtb_COP1
#undef MY_PREFIX
#define MY_PREFIX C_cond_fmtb_COP1
#undef MY_NAME
#define MY_NAME "C_cond_fmtb_COP1"

  /* Extraction: C.cond.fmtb
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.FT,5.FS,3.CC,2.0x0,2.0x3,4.COND */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef CC
#define CC ((unsigned) EXTRACTED32 (instruction_0, 10, 8)) /* cache - extraction */
#undef COND
#define COND ((unsigned) MASKED32 (instruction_0, 3, 0)) /* cache - extraction */
#line 8048 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.FT,5.FS,3.CC,2.0x0,2.0x3,4.COND */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000000c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
      if (CC == 0)
#line 4214 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
        trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                      itable[MY_INDEX].file, \
                      itable[MY_INDEX].line_nr, \
                      "c.%s.%s f%ld, f%ld", \
                      str_COND (SD_, COND), \
                      str_FMT (SD_, FMT), \
                      (long) FS, \
                      (long) FT);
#line 8088 "semantics.c"
      else
#line 4215 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
        trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                      itable[MY_INDEX].file, \
                      itable[MY_INDEX].line_nr, \
                      "c.%s.%s %ld, f%ld, f%ld", \
                      str_COND (SD_, COND), \
                      str_FMT (SD_, FMT), \
                      (long) CC, \
                      (long) FS, \
                      (long) FT);
#line 8100 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_C_cond_fmtb_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4226 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    check_fmt_p (SD_, fmt, instruction_0);
    Compare (ValueFPR (FS, fmt), ValueFPR (FT, fmt), fmt, COND, CC);
    TRACE_ALU_RESULT (ValueFCR (31));
  }
#line 8132 "semantics.c"
  return nia;
  /* Extraction: C.cond.fmtb
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.FT,5.FS,3.CC,2.0x0,2.0x3,4.COND */

#undef FMT
#undef FT
#undef FS
#undef CC
#undef COND
#line 8143 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MOVtf_fmt_COP1 (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MOVtf_fmt_COP1
#undef MOVtf_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX MOVtf_fmt_COP1
#undef MY_NAME
#define MY_NAME "MOVtf_fmt_COP1"

  /* Extraction: MOVtf.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,3.CC,1.0x0,1.TF,5.FS,5.FD,6.0x11 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef CC
#define CC ((unsigned) EXTRACTED32 (instruction_0, 20, 18)) /* cache - extraction */
#undef TF
#define TF ((unsigned) EXTRACTED32 (instruction_0, 16, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#line 8174 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,3.CC,1.0x0,1.TF,5.FS,5.FD,6.0x11 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x00020000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4825 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mov%s.%s f%ld, f%ld, %ld", \
                    str_TF (SD_, TF), \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS, \
                    (long) CC);
#line 8214 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MOVtf_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4834 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    if (fmt != fmt_ps)
      {
        if (GETFCC(CC) == TF)
    	StoreFPR (FD, fmt, ValueFPR (FS, fmt));
        else
    	StoreFPR (FD, fmt, ValueFPR (FD, fmt));   /* set fmt */
      }
    else
      {
        unsigned64 fd;
        fd = PackPS (PSUpper (ValueFPR ((GETFCC (CC+1) == TF) ? FS : FD,
    				      fmt_ps)),
    		   PSLower (ValueFPR ((GETFCC (CC+0) == TF) ? FS : FD,
    				      fmt_ps)));
        StoreFPR (FD, fmt_ps, fd);
      }
  }
#line 8259 "semantics.c"
  return nia;
  /* Extraction: MOVtf.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,3.CC,1.0x0,1.TF,5.FS,5.FD,6.0x11 */

#undef FMT
#undef CC
#undef TF
#undef FS
#undef FD
#line 8270 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SQRT_fmt_COP1 (SIM_DESC sd,
                        instruction_word instruction_0,
                        instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SQRT_fmt_COP1
#undef SQRT_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX SQRT_fmt_COP1
#undef MY_NAME
#define MY_NAME "SQRT_fmt_COP1"

  /* Extraction: SQRT.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x4 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#line 8297 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x4 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5224 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sqrt.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 8335 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SQRT_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5237 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    StoreFPR (FD, fmt,  (SquareRoot (ValueFPR (FS, fmt), fmt)));
  }
#line 8365 "semantics.c"
  return nia;
  /* Extraction: SQRT.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x4 */

#undef FMT
#undef FS
#undef FD
#line 8374 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ABS_fmt_COP1 (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ABS_fmt_COP1
#undef ABS_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX ABS_fmt_COP1
#undef MY_NAME
#define MY_NAME "ABS_fmt_COP1"

  /* Extraction: ABS.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x5 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#line 8401 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x5 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4073 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "abs.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 8439 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ABS_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4087 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    check_fmt_p (SD_, fmt, instruction_0);
    StoreFPR (FD, fmt, AbsoluteValue (ValueFPR (FS, fmt), fmt));
  }
#line 8470 "semantics.c"
  return nia;
  /* Extraction: ABS.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x5 */

#undef FMT
#undef FS
#undef FD
#line 8479 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MOV_fmt_COP1 (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MOV_fmt_COP1
#undef MOV_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX MOV_fmt_COP1
#undef MY_NAME
#define MY_NAME "MOV_fmt_COP1"

  /* Extraction: MOV.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x6 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#line 8506 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x6 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4783 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mov.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 8544 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MOV_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4797 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    check_fmt_p (SD_, fmt, instruction_0);
    StoreFPR (FD, fmt, ValueFPR (FS, fmt));
  }
#line 8575 "semantics.c"
  return nia;
  /* Extraction: MOV.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x6 */

#undef FMT
#undef FS
#undef FD
#line 8584 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_NEG_fmt_COP1 (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_NEG_fmt_COP1
#undef NEG_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX NEG_fmt_COP1
#undef MY_NAME
#define MY_NAME "NEG_fmt_COP1"

  /* Extraction: NEG.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x7 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#line 8611 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x7 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4969 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "neg.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 8649 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_NEG_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4983 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    check_fmt_p (SD_, fmt, instruction_0);
    StoreFPR (FD, fmt, Negate (ValueFPR (FS, fmt), fmt));
  }
#line 8680 "semantics.c"
  return nia;
  /* Extraction: NEG.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x7 */

#undef FMT
#undef FS
#undef FD
#line 8689 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ROUND_W_fmt_COP1 (SIM_DESC sd,
                           instruction_word instruction_0,
                           instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ROUND_W_fmt_COP1
#undef ROUND_W_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX ROUND_W_fmt_COP1
#undef MY_NAME
#define MY_NAME "ROUND_W_fmt_COP1"

  /* Extraction: ROUND.W.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0xc */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#line 8716 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0xc */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5129 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "round.w.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 8754 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ROUND_W_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5142 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    StoreFPR (FD, fmt_word, Convert (FP_RM_NEAREST, ValueFPR (FS, fmt), fmt,
    	    fmt_word));
  }
#line 8785 "semantics.c"
  return nia;
  /* Extraction: ROUND.W.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0xc */

#undef FMT
#undef FS
#undef FD
#line 8794 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TRUNC_W_COP1 (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TRUNC_W_COP1
#undef TRUNC_W_COP1
#undef MY_PREFIX
#define MY_PREFIX TRUNC_W_COP1
#undef MY_NAME
#define MY_NAME "TRUNC_W_COP1"

  /* Extraction: TRUNC.W
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0xd */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#line 8821 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0xd */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5372 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "trunc.w.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 8859 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TRUNC_W_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5385 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    StoreFPR (FD, fmt_word, Convert (FP_RM_TOZERO, ValueFPR (FS, fmt), fmt,
    	    fmt_word));
  }
#line 8890 "semantics.c"
  return nia;
  /* Extraction: TRUNC.W
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0xd */

#undef FMT
#undef FS
#undef FD
#line 8899 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_CEIL_W_COP1 (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_CEIL_W_COP1
#undef CEIL_W_COP1
#undef MY_PREFIX
#define MY_PREFIX CEIL_W_COP1
#undef MY_NAME
#define MY_NAME "CEIL_W_COP1"

  /* Extraction: CEIL.W
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0xe */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#line 8926 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0xe */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4253 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "ceil.w.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 8964 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_CEIL_W_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4266 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    StoreFPR (FD, fmt_word, Convert (FP_RM_TOPINF, ValueFPR (FS, fmt), fmt,
    	    fmt_word));
  }
#line 8995 "semantics.c"
  return nia;
  /* Extraction: CEIL.W
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0xe */

#undef FMT
#undef FS
#undef FD
#line 9004 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_FLOOR_W_fmt_COP1 (SIM_DESC sd,
                           instruction_word instruction_0,
                           instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_FLOOR_W_fmt_COP1
#undef FLOOR_W_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX FLOOR_W_fmt_COP1
#undef MY_NAME
#define MY_NAME "FLOOR_W_fmt_COP1"

  /* Extraction: FLOOR.W.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0xf */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#line 9031 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0xf */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4620 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "floor.w.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 9069 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_FLOOR_W_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4633 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    StoreFPR (FD, fmt_word, Convert (FP_RM_TOMINF, ValueFPR (FS, fmt), fmt,
    	    fmt_word));
  }
#line 9100 "semantics.c"
  return nia;
  /* Extraction: FLOOR.W.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0xf */

#undef FMT
#undef FS
#undef FD
#line 9109 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_RECIP_fmt_COP1 (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_RECIP_fmt_COP1
#undef RECIP_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX RECIP_fmt_COP1
#undef MY_NAME
#define MY_NAME "RECIP_fmt_COP1"

  /* Extraction: RECIP.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x15 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#line 9136 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x15 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5097 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "recip.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 9174 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_RECIP_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5104 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    StoreFPR (FD, fmt, Recip (ValueFPR (FS, fmt), fmt));
  }
#line 9204 "semantics.c"
  return nia;
  /* Extraction: RECIP.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x15 */

#undef FMT
#undef FS
#undef FD
#line 9213 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_RSQRT_fmt_COP1 (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_RSQRT_fmt_COP1
#undef RSQRT_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX RSQRT_fmt_COP1
#undef MY_NAME
#define MY_NAME "RSQRT_fmt_COP1"

  /* Extraction: RSQRT.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x16 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#line 9240 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x16 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5150 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "rsqrt.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 9278 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_RSQRT_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5157 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    StoreFPR (FD, fmt, RSquareRoot (ValueFPR (FS, fmt), fmt));
  }
#line 9308 "semantics.c"
  return nia;
  /* Extraction: RSQRT.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x16 */

#undef FMT
#undef FS
#undef FD
#line 9317 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_CVT_S_fmt_COP1 (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_CVT_S_fmt_COP1
#undef CVT_S_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX CVT_S_fmt_COP1
#undef MY_NAME
#define MY_NAME "CVT_S_fmt_COP1"

  /* Extraction: CVT.S.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x20 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#line 9344 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x20 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4430 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "cvt.s.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 9382 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_CVT_S_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4444 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    if ((fmt == fmt_single) | 0)
      SignalException (ReservedInstruction, instruction_0);
    StoreFPR (FD, fmt_single, Convert (GETRM (), ValueFPR (FS, fmt), fmt,
    	    fmt_single));
  }
#line 9415 "semantics.c"
  return nia;
  /* Extraction: CVT.S.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x20 */

#undef FMT
#undef FS
#undef FD
#line 9424 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_CVT_D_fmt_COP1 (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_CVT_D_fmt_COP1
#undef CVT_D_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX CVT_D_fmt_COP1
#undef MY_NAME
#define MY_NAME "CVT_D_fmt_COP1"

  /* Extraction: CVT.D.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x21 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#line 9451 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x21 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4370 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "cvt.d.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 9489 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_CVT_D_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4384 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    if ((fmt == fmt_double) | 0)
      SignalException (ReservedInstruction, instruction_0);
    StoreFPR (FD, fmt_double, Convert (GETRM (), ValueFPR (FS, fmt), fmt,
    	    fmt_double));
  }
#line 9522 "semantics.c"
  return nia;
  /* Extraction: CVT.D.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x21 */

#undef FMT
#undef FS
#undef FD
#line 9531 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_CVT_W_fmt_COP1 (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_CVT_W_fmt_COP1
#undef CVT_W_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX CVT_W_fmt_COP1
#undef MY_NAME
#define MY_NAME "CVT_W_fmt_COP1"

  /* Extraction: CVT.W.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x24 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#line 9558 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x24 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4478 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "cvt.w.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 9596 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_CVT_W_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4492 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    if ((fmt == fmt_word) | ((fmt == fmt_long) || (fmt == fmt_word)))
      SignalException (ReservedInstruction, instruction_0);
    StoreFPR (FD, fmt_word, Convert (GETRM (), ValueFPR (FS, fmt), fmt,
    	    fmt_word));
  }
#line 9629 "semantics.c"
  return nia;
  /* Extraction: CVT.W.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x24 */

#undef FMT
#undef FS
#undef FD
#line 9638 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SWXC1_COP1X (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SWXC1_COP1X
#undef SWXC1_COP1X
#undef MY_PREFIX
#define MY_PREFIX SWXC1_COP1X
#undef MY_NAME
#define MY_NAME "SWXC1_COP1X"

  /* Extraction: SWXC1
       #define do-not-use-icache
       6.0x13,5.BASE,5.INDEX,5.FS,5.0x0,6.0x8 */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef INDEX
#define INDEX ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 9665 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x13,5.BASE,5.INDEX,5.FS,5.0x0,6.0x8 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007ff) != 0x00000008)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5313 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "swxc1 f%ld, r%ld(r%ld)", \
                    (long) FS, \
                    (long) INDEX, \
                    (long) BASE);
#line 9703 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SWXC1_COP1X, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5320 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"

    address_word base = GPR[BASE];
    address_word index = GPR[INDEX];
    check_fpu (SD_);
    check_u64 (SD_, instruction_0);
    {
     address_word vaddr = loadstore_ea (SD_, base, index);
     address_word paddr;
     int uncached;
     if ((vaddr & 3) != 0)
       {
         SIM_CORE_SIGNAL (SD, CPU, cia, read_map, 4, vaddr, write_transfer, sim_core_unaligned_signal);
       }
     else
     {
      if (AddressTranslation(vaddr,isDATA,isSTORE,&paddr,&uncached,isTARGET,isREAL))
      {
       unsigned64 memval = 0;
       unsigned64 memval1 = 0;
       unsigned64 mask = 0x7;
       unsigned int byte;
       paddr = ((paddr & ~mask) | ((paddr & mask) ^ (ReverseEndian << 2)));
       byte = ((vaddr & mask) ^ (BigEndianCPU << 2));
       memval = (((unsigned64)COP_SW(1,FS)) << (8 * byte));
        {
         StoreMemory(uncached,AccessLength_WORD,memval,memval1,paddr,vaddr,isREAL);
        }
      }
     }
    }
  }
#line 9760 "semantics.c"
  return nia;
  /* Extraction: SWXC1
       #undef do-not-use-icache
       6.0x13,5.BASE,5.INDEX,5.FS,5.0x0,6.0x8 */

#undef BASE
#undef INDEX
#undef FS
#line 9769 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BEQL_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BEQL_NORMAL
#undef BEQL_NORMAL
#undef MY_PREFIX
#define MY_PREFIX BEQL_NORMAL
#undef MY_NAME
#define MY_NAME "BEQL_NORMAL"

  /* Extraction: BEQL
       #define do-not-use-icache
       6.0x14,5.RS,5.RT,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 9796 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x14,5.RS,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 704 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "beql r%ld, r%ld, %ld", \
                    (long) RS, \
                    (long) RT, \
                    (long) OFFSET);
#line 9815 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BEQL_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 717 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if ((signed_word) GPR[RS] == (signed_word) GPR[RT])
      {
        DELAY_SLOT (NIA + offset);
      }
    else
      NULLIFY_NEXT_INSTRUCTION ();
  }
#line 9849 "semantics.c"
  return nia;
  /* Extraction: BEQL
       #undef do-not-use-icache
       6.0x14,5.RS,5.RT,16.OFFSET */

#undef RS
#undef RT
#undef OFFSET
#line 9858 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BNEL_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BNEL_NORMAL
#undef BNEL_NORMAL
#undef MY_PREFIX
#define MY_PREFIX BNEL_NORMAL
#undef MY_NAME
#define MY_NAME "BNEL_NORMAL"

  /* Extraction: BNEL
       #define do-not-use-icache
       6.0x15,5.RS,5.RT,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 9885 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x15,5.RS,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1069 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bnel r%ld, r%ld, %ld", \
                    (long) RS, \
                    (long) RT, \
                    (long) OFFSET);
#line 9904 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BNEL_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1082 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if ((signed_word) GPR[RS] != (signed_word) GPR[RT])
      {
        DELAY_SLOT (NIA + offset);
      }
    else
      NULLIFY_NEXT_INSTRUCTION ();
  }
#line 9938 "semantics.c"
  return nia;
  /* Extraction: BNEL
       #undef do-not-use-icache
       6.0x15,5.RS,5.RT,16.OFFSET */

#undef RS
#undef RT
#undef OFFSET
#line 9947 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BLEZL_NORMAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BLEZL_NORMAL
#undef BLEZL_NORMAL
#undef MY_PREFIX
#define MY_PREFIX BLEZL_NORMAL
#undef MY_NAME
#define MY_NAME "BLEZL_NORMAL"

  /* Extraction: BLEZL
       #define do-not-use-icache
       6.0x16,5.RS,5.0x0,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 9972 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x16,5.RS,5.0x0,16.OFFSET */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 912 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bgezl r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 9995 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BLEZL_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 925 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if ((signed_word) GPR[RS] <= 0)
      {
        DELAY_SLOT (NIA + offset);
      }
    else
      NULLIFY_NEXT_INSTRUCTION ();
  }
#line 10029 "semantics.c"
  return nia;
  /* Extraction: BLEZL
       #undef do-not-use-icache
       6.0x16,5.RS,5.0x0,16.OFFSET */

#undef RS
#undef OFFSET
#line 10037 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BGTZL_NORMAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BGTZL_NORMAL
#undef BGTZL_NORMAL
#undef MY_PREFIX
#define MY_PREFIX BGTZL_NORMAL
#undef MY_NAME
#define MY_NAME "BGTZL_NORMAL"

  /* Extraction: BGTZL
       #define do-not-use-icache
       6.0x17,5.RS,5.0x0,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 10062 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x17,5.RS,5.0x0,16.OFFSET */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 859 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bgtzl r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 10085 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BGTZL_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 872 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    /* NOTE: The branch occurs AFTER the next instruction has been
       executed */
    if ((signed_word) GPR[RS] > 0)
      {
        DELAY_SLOT (NIA + offset);
      }
    else
      NULLIFY_NEXT_INSTRUCTION ();
  }
#line 10121 "semantics.c"
  return nia;
  /* Extraction: BGTZL
       #undef do-not-use-icache
       6.0x17,5.RS,5.0x0,16.OFFSET */

#undef RS
#undef OFFSET
#line 10129 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LB_NORMAL (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LB_NORMAL
#undef LB_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LB_NORMAL
#undef MY_NAME
#define MY_NAME "LB_NORMAL"

  /* Extraction: LB
       #define do-not-use-icache
       6.0x20,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 10156 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x20,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2089 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lb r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 10175 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LB_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2103 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    GPR[RT] = EXTEND8 (do_load (SD_, AccessLength_BYTE, GPR[BASE], EXTEND16 (OFFSET)));
  }
#line 10203 "semantics.c"
  return nia;
  /* Extraction: LB
       #undef do-not-use-icache
       6.0x20,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 10212 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LH_NORMAL (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LH_NORMAL
#undef LH_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LH_NORMAL
#undef MY_NAME
#define MY_NAME "LH_NORMAL"

  /* Extraction: LH
       #define do-not-use-icache
       6.0x21,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 10239 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x21,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2192 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lh r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 10258 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LH_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2206 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    GPR[RT] = EXTEND16 (do_load (SD_, AccessLength_HALFWORD, GPR[BASE], EXTEND16 (OFFSET)));
  }
#line 10286 "semantics.c"
  return nia;
  /* Extraction: LH
       #undef do-not-use-icache
       6.0x21,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 10295 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LWL_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LWL_NORMAL
#undef LWL_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LWL_NORMAL
#undef MY_NAME
#define MY_NAME "LWL_NORMAL"

  /* Extraction: LWL
       #define do-not-use-icache
       6.0x22,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 10322 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x22,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2370 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lwl r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 10341 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LWL_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2384 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    GPR[RT] = EXTEND32 (do_load_left (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (OFFSET), GPR[RT]));
  }
#line 10369 "semantics.c"
  return nia;
  /* Extraction: LWL
       #undef do-not-use-icache
       6.0x22,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 10378 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LW_NORMAL (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LW_NORMAL
#undef LW_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LW_NORMAL
#undef MY_NAME
#define MY_NAME "LW_NORMAL"

  /* Extraction: LW
       #define do-not-use-icache
       6.0x23,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 10405 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x23,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2332 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lw r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 10424 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LW_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2346 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    GPR[RT] = EXTEND32 (do_load (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (OFFSET)));
  }
#line 10452 "semantics.c"
  return nia;
  /* Extraction: LW
       #undef do-not-use-icache
       6.0x23,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 10461 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LBU_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LBU_NORMAL
#undef LBU_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LBU_NORMAL
#undef MY_NAME
#define MY_NAME "LBU_NORMAL"

  /* Extraction: LBU
       #define do-not-use-icache
       6.0x24,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 10488 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x24,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2108 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lbu r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 10507 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LBU_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2122 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    GPR[RT] = do_load (SD_, AccessLength_BYTE, GPR[BASE], EXTEND16 (OFFSET));
  }
#line 10535 "semantics.c"
  return nia;
  /* Extraction: LBU
       #undef do-not-use-icache
       6.0x24,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 10544 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LHU_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LHU_NORMAL
#undef LHU_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LHU_NORMAL
#undef MY_NAME
#define MY_NAME "LHU_NORMAL"

  /* Extraction: LHU
       #define do-not-use-icache
       6.0x25,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 10571 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x25,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2211 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lhu r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 10590 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LHU_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2225 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    GPR[RT] = do_load (SD_, AccessLength_HALFWORD, GPR[BASE], EXTEND16 (OFFSET));
  }
#line 10618 "semantics.c"
  return nia;
  /* Extraction: LHU
       #undef do-not-use-icache
       6.0x25,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 10627 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LWR_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LWR_NORMAL
#undef LWR_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LWR_NORMAL
#undef MY_NAME
#define MY_NAME "LWR_NORMAL"

  /* Extraction: LWR
       #define do-not-use-icache
       6.0x26,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 10654 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x26,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2389 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lwr r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 10673 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LWR_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2403 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    GPR[RT] = EXTEND32 (do_load_right (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (OFFSET), GPR[RT]));
  }
#line 10701 "semantics.c"
  return nia;
  /* Extraction: LWR
       #undef do-not-use-icache
       6.0x26,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 10710 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SB_NORMAL (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SB_NORMAL
#undef SB_NORMAL
#undef MY_PREFIX
#define MY_PREFIX SB_NORMAL
#undef MY_NAME
#define MY_NAME "SB_NORMAL"

  /* Extraction: SB
       #define do-not-use-icache
       6.0x28,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 10737 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x28,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2961 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sb r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 10756 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SB_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2975 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    do_store (SD_, AccessLength_BYTE, GPR[BASE], EXTEND16 (OFFSET), GPR[RT]);
  }
#line 10784 "semantics.c"
  return nia;
  /* Extraction: SB
       #undef do-not-use-icache
       6.0x28,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 10793 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SH_NORMAL (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SH_NORMAL
#undef SH_NORMAL
#undef MY_PREFIX
#define MY_PREFIX SH_NORMAL
#undef MY_NAME
#define MY_NAME "SH_NORMAL"

  /* Extraction: SH
       #define do-not-use-icache
       6.0x29,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 10820 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x29,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3128 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sh r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 10839 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SH_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3142 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    do_store (SD_, AccessLength_HALFWORD, GPR[BASE], EXTEND16 (OFFSET), GPR[RT]);
  }
#line 10867 "semantics.c"
  return nia;
  /* Extraction: SH
       #undef do-not-use-icache
       6.0x29,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 10876 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SWL_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SWL_NORMAL
#undef SWL_NORMAL
#undef MY_PREFIX
#define MY_PREFIX SWL_NORMAL
#undef MY_NAME
#define MY_NAME "SWL_NORMAL"

  /* Extraction: SWL
       #define do-not-use-icache
       6.0x2a,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 10903 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x2a,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3535 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "swl r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 10922 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SWL_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3549 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    do_store_left (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (OFFSET), GPR[RT]);
  }
#line 10950 "semantics.c"
  return nia;
  /* Extraction: SWL
       #undef do-not-use-icache
       6.0x2a,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 10959 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SW_NORMAL (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SW_NORMAL
#undef SW_NORMAL
#undef MY_PREFIX
#define MY_PREFIX SW_NORMAL
#undef MY_NAME
#define MY_NAME "SW_NORMAL"

  /* Extraction: SW
       #define do-not-use-icache
       6.0x2b,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 10986 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x2b,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3497 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sw r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 11005 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SW_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3511 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    do_store (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (OFFSET), GPR[RT]);
  }
#line 11033 "semantics.c"
  return nia;
  /* Extraction: SW
       #undef do-not-use-icache
       6.0x2b,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 11042 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SWR_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SWR_NORMAL
#undef SWR_NORMAL
#undef MY_PREFIX
#define MY_PREFIX SWR_NORMAL
#undef MY_NAME
#define MY_NAME "SWR_NORMAL"

  /* Extraction: SWR
       #define do-not-use-icache
       6.0x2e,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 11069 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x2e,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3554 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "swr r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 11088 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SWR_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3568 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    do_store_right (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (OFFSET), GPR[RT]);
  }
#line 11116 "semantics.c"
  return nia;
  /* Extraction: SWR
       #undef do-not-use-icache
       6.0x2e,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 11125 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_CACHE_NORMAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_CACHE_NORMAL
#undef CACHE_NORMAL
#undef MY_PREFIX
#define MY_PREFIX CACHE_NORMAL
#undef MY_NAME
#define MY_NAME "CACHE_NORMAL"

  /* Extraction: CACHE
       #define do-not-use-icache
       6.0x2f,5.BASE,5.OP,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OP
#define OP ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 11152 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x2f,5.BASE,5.OP,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5467 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "cache %ld, %ld(r%ld)", \
                    (long) OP, \
                    (long) OFFSET, \
                    (long) BASE);
#line 11171 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_CACHE_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5479 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    address_word base = GPR[BASE];
    address_word offset = EXTEND16 (OFFSET);
    {
      address_word vaddr = loadstore_ea (SD_, base, offset);
      address_word paddr;
      int uncached;
      if (AddressTranslation(vaddr,isDATA,isLOAD,&paddr,&uncached,isTARGET,isREAL))
        CacheOp(OP,vaddr,paddr,instruction_0);
    }
  }
#line 11207 "semantics.c"
  return nia;
  /* Extraction: CACHE
       #undef do-not-use-icache
       6.0x2f,5.BASE,5.OP,16.OFFSET */

#undef BASE
#undef OP
#undef OFFSET
#line 11216 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LWCz_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LWCz_NORMAL
#undef LWCz_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LWCz_NORMAL
#undef MY_NAME
#define MY_NAME "LWCz_NORMAL"

  /* Extraction: LWCz
       #define do-not-use-icache
       4.0xc,2.ZZ,5.BASE,5.RT,16.OFFSET */

#undef ZZ
#define ZZ ((unsigned) EXTRACTED32 (instruction_0, 27, 26)) /* cache - extraction */
#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 11245 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 4.0xc,2.ZZ,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2351 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lwc%ld r%ld, %ld(r%ld)", \
                    (long) ZZ, \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 11265 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LWCz_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2365 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    COP_LW (ZZ, RT, do_load (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (OFFSET)));
  }
#line 11293 "semantics.c"
  return nia;
  /* Extraction: LWCz
       #undef do-not-use-icache
       4.0xc,2.ZZ,5.BASE,5.RT,16.OFFSET */

#undef ZZ
#undef BASE
#undef RT
#undef OFFSET
#line 11303 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LL_NORMAL (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LL_NORMAL
#undef LL_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LL_NORMAL
#undef MY_NAME
#define MY_NAME "LL_NORMAL"

  /* Extraction: LL
       #define do-not-use-icache
       6.0x30,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 11330 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x30,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2230 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "ll r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 11349 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LL_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2242 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    address_word base = GPR[BASE];
    address_word offset = EXTEND16 (OFFSET);
    {
      address_word vaddr = loadstore_ea (SD_, base, offset);
      address_word paddr;
      int uncached;
      if ((vaddr & 3) != 0)
        {
          SIM_CORE_SIGNAL (SD, CPU, cia, read_map, 4, vaddr, read_transfer, sim_core_unaligned_signal);
        }
      else
        {
    	if (AddressTranslation(vaddr,isDATA,isLOAD,&paddr,&uncached,isTARGET,isREAL))
    	  {
    	    unsigned64 memval = 0;
    	    unsigned64 memval1 = 0;
    	    unsigned64 mask = 0x7;
    	    unsigned int shift = 2;
    	    unsigned int reverse = (ReverseEndian ? (mask >> shift) : 0);
    	    unsigned int bigend = (BigEndianCPU ? (mask >> shift) : 0);
    	    unsigned int byte;
    	    paddr = ((paddr & ~mask) | ((paddr & mask) ^ (reverse << shift)));
    	    LoadMemory(&memval,&memval1,uncached,AccessLength_WORD,paddr,vaddr,isDATA,isREAL);
    	    byte = ((vaddr & mask) ^ (bigend << shift));
    	    GPR[RT] = EXTEND32 (memval >> (8 * byte));
    	    LLBIT = 1;
    	  }
        }
    }
  }
#line 11405 "semantics.c"
  return nia;
  /* Extraction: LL
       #undef do-not-use-icache
       6.0x30,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 11414 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LWC1_COP1 (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LWC1_COP1
#undef LWC1_COP1
#undef MY_PREFIX
#define MY_PREFIX LWC1_COP1
#undef MY_NAME
#define MY_NAME "LWC1_COP1"

  /* Extraction: LWC1
       #define do-not-use-icache
       6.0x31,5.BASE,5.FT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 11441 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x31,5.BASE,5.FT,16.OFFSET */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4700 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lwc1 f%ld, %ld(r%ld)", \
                    (long) FT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 11474 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LWC1_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4714 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    check_fpu (SD_);
    COP_LW (1, FT, do_load (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (OFFSET)));
  }
#line 11503 "semantics.c"
  return nia;
  /* Extraction: LWC1
       #undef do-not-use-icache
       6.0x31,5.BASE,5.FT,16.OFFSET */

#undef BASE
#undef FT
#undef OFFSET
#line 11512 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_PREF_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_PREF_NORMAL
#undef PREF_NORMAL
#undef MY_PREFIX
#define MY_PREFIX PREF_NORMAL
#undef MY_NAME
#define MY_NAME "PREF_NORMAL"

  /* Extraction: PREF
       #define do-not-use-icache
       6.0x33,5.BASE,5.HINT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef HINT
#define HINT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 11539 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x33,5.BASE,5.HINT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2815 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "pref %ld, %ld(r%ld)", \
                    (long) HINT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 11558 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_PREF_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2824 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    address_word base = GPR[BASE];
    address_word offset = EXTEND16 (OFFSET);
    {
      address_word vaddr = loadstore_ea (SD_, base, offset);
      address_word paddr;
      int uncached;
      {
        if (AddressTranslation(vaddr,isDATA,isLOAD,&paddr,&uncached,isTARGET,isREAL))
    	Prefetch(uncached,paddr,vaddr,isDATA,HINT);
      }
    }
  }
#line 11596 "semantics.c"
  return nia;
  /* Extraction: PREF
       #undef do-not-use-icache
       6.0x33,5.BASE,5.HINT,16.OFFSET */

#undef BASE
#undef HINT
#undef OFFSET
#line 11605 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LDC1b_COP1 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LDC1b_COP1
#undef LDC1b_COP1
#undef MY_PREFIX
#define MY_PREFIX LDC1b_COP1
#undef MY_NAME
#define MY_NAME "LDC1b_COP1"

  /* Extraction: LDC1b
       #define do-not-use-icache
       6.0x35,5.BASE,5.FT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 11632 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x35,5.BASE,5.FT,16.OFFSET */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4652 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "ldc1 f%ld, %ld(r%ld)", \
                    (long) FT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 11665 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LDC1b_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4662 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    check_fpu (SD_);
    COP_LD (1, FT, do_load (SD_, AccessLength_DOUBLEWORD, GPR[BASE], EXTEND16 (OFFSET)));
  }
#line 11694 "semantics.c"
  return nia;
  /* Extraction: LDC1b
       #undef do-not-use-icache
       6.0x35,5.BASE,5.FT,16.OFFSET */

#undef BASE
#undef FT
#undef OFFSET
#line 11703 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SWCz_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SWCz_NORMAL
#undef SWCz_NORMAL
#undef MY_PREFIX
#define MY_PREFIX SWCz_NORMAL
#undef MY_NAME
#define MY_NAME "SWCz_NORMAL"

  /* Extraction: SWCz
       #define do-not-use-icache
       4.0xe,2.ZZ,5.BASE,5.RT,16.OFFSET */

#undef ZZ
#define ZZ ((unsigned) EXTRACTED32 (instruction_0, 27, 26)) /* cache - extraction */
#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 11732 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 4.0xe,2.ZZ,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3516 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "swc%ld r%ld, %ld(r%ld)", \
                    (long) ZZ, \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 11752 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SWCz_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3530 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    do_store (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (OFFSET), COP_SW (ZZ, RT));
  }
#line 11780 "semantics.c"
  return nia;
  /* Extraction: SWCz
       #undef do-not-use-icache
       4.0xe,2.ZZ,5.BASE,5.RT,16.OFFSET */

#undef ZZ
#undef BASE
#undef RT
#undef OFFSET
#line 11790 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SC_NORMAL (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SC_NORMAL
#undef SC_NORMAL
#undef MY_PREFIX
#define MY_PREFIX SC_NORMAL
#undef MY_NAME
#define MY_NAME "SC_NORMAL"

  /* Extraction: SC
       #define do-not-use-icache
       6.0x38,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 11817 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x38,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2980 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sc r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 11836 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SC_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2992 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    unsigned32 instruction = instruction_0;
    address_word base = GPR[BASE];
    address_word offset = EXTEND16 (OFFSET);
    {
      address_word vaddr = loadstore_ea (SD_, base, offset);
      address_word paddr;
      int uncached;
      if ((vaddr & 3) != 0)
        {
    	SIM_CORE_SIGNAL (SD, CPU, cia, read_map, 4, vaddr, write_transfer, sim_core_unaligned_signal);
        }
      else
        {
    	if (AddressTranslation(vaddr,isDATA,isSTORE,&paddr,&uncached,isTARGET,isREAL))
    	  {
    	    unsigned64 memval = 0;
    	    unsigned64 memval1 = 0;
    	    unsigned64 mask = 0x7;
    	    unsigned int byte;
    	    paddr = ((paddr & ~mask) | ((paddr & mask) ^ (ReverseEndian << 2)));
    	    byte = ((vaddr & mask) ^ (BigEndianCPU << 2));
    	    memval = ((unsigned64) GPR[RT] << (8 * byte));
    	    if (LLBIT)
    	      {
    		StoreMemory(uncached,AccessLength_WORD,memval,memval1,paddr,vaddr,isREAL);
    	      }
    	    GPR[RT] = LLBIT;
    	  }
        }
    }
  }
#line 11893 "semantics.c"
  return nia;
  /* Extraction: SC
       #undef do-not-use-icache
       6.0x38,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 11902 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SWC1_COP1 (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SWC1_COP1
#undef SWC1_COP1
#undef MY_PREFIX
#define MY_PREFIX SWC1_COP1
#undef MY_NAME
#define MY_NAME "SWC1_COP1"

  /* Extraction: SWC1
       #define do-not-use-icache
       6.0x39,5.BASE,5.FT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 11929 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x39,5.BASE,5.FT,16.OFFSET */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5267 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "swc1 f%ld, %ld(r%ld)", \
                    (long) FT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 11962 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SWC1_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5281 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    address_word base = GPR[BASE];
    address_word offset = EXTEND16 (OFFSET);
    check_fpu (SD_);
    {
      address_word vaddr = loadstore_ea (SD_, base, offset);
      address_word paddr;
      int uncached;
      if ((vaddr & 3) != 0)
        {
    	SIM_CORE_SIGNAL (SD, CPU, cia, read_map, AccessLength_WORD+1, vaddr, write_transfer, sim_core_unaligned_signal);
        }
      else
        {
    	if (AddressTranslation(vaddr,isDATA,isSTORE,&paddr,&uncached,isTARGET,isREAL))
    	  {
    	    uword64 memval = 0;
    	    uword64 memval1 = 0;
    	    uword64 mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
    	    address_word reverseendian = (ReverseEndian ?(mask ^ AccessLength_WORD): 0);
    	    address_word bigendiancpu = (BigEndianCPU ?(mask ^ AccessLength_WORD): 0);
    	    unsigned int byte;
    	    paddr = ((paddr & ~mask) | ((paddr & mask) ^ reverseendian));
    	    byte = ((vaddr & mask) ^ bigendiancpu);
    	    memval = (((uword64)COP_SW(((instruction_0 >> 26) & 0x3),FT)) << (8 * byte));
    	    StoreMemory(uncached,AccessLength_WORD,memval,memval1,paddr,vaddr,isREAL);
    	  }
        }
    }
  }
#line 12017 "semantics.c"
  return nia;
  /* Extraction: SWC1
       #undef do-not-use-icache
       6.0x39,5.BASE,5.FT,16.OFFSET */

#undef BASE
#undef FT
#undef OFFSET
#line 12026 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SDC1b_COP1 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SDC1b_COP1
#undef SDC1b_COP1
#undef MY_PREFIX
#define MY_PREFIX SDC1b_COP1
#undef MY_NAME
#define MY_NAME "SDC1b_COP1"

  /* Extraction: SDC1b
       #define do-not-use-icache
       6.0x3d,5.BASE,5.FT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 12053 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x3d,5.BASE,5.FT,16.OFFSET */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5175 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sdc1 f%ld, %ld(r%ld)", \
                    (long) FT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 12086 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SDC1b_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5185 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
    check_fpu (SD_);
    do_store (SD_, AccessLength_DOUBLEWORD, GPR[BASE], EXTEND16 (OFFSET), COP_SD (1, FT));
  }
#line 12115 "semantics.c"
  return nia;
  /* Extraction: SDC1b
       #undef do-not-use-icache
       6.0x3d,5.BASE,5.FT,16.OFFSET */

#undef BASE
#undef FT
#undef OFFSET
#line 12124 "semantics.c"
}

#endif /* _SEMANTICS_C_*/
