/* This file is part of GDB.

   Copyright 2002 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
 
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.

   --

   This file was generated by the program igen */

#ifndef SUPPORT_C
#define SUPPORT_C

#include "sim-main.h"
#include "idecode.h"
#include "itable.h"
#include "support.h"

INLINE_SUPPORT\
(instruction_address)
semantic_illegal
(SIM_DESC sd,
 instruction_address cia)
{
#line 86 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  SignalException (ReservedInstruction, 0);
  sim_engine_abort (SD, CPU, cia, "Internal function must longjump\n");
  return cia;
}
#line 44 "support.c"

INLINE_SUPPORT\
(address_word)
delayslot32
(SIM_DESC sd, instruction_address cia, int MY_INDEX, address_word target)
{
#line 107 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  instruction_word delay_insn;
  sim_events_slip (SD, 1);
  DSPC = CIA;
  CIA = CIA + 4; /* NOTE not mips16 */
  STATE |= simDELAYSLOT;
  delay_insn = IMEM32 (CIA); /* NOTE not mips16 */
  ENGINE_ISSUE_PREFIX_HOOK();
  idecode_issue (CPU_, delay_insn, (CIA));
  STATE &= ~simDELAYSLOT;
  return target;
}
#line 63 "support.c"

INLINE_SUPPORT\
(address_word)
nullify_next_insn32
(SIM_DESC sd, instruction_address cia, int MY_INDEX)
{
#line 121 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  sim_events_slip (SD, 1);
  dotrace (SD, CPU, tracefh, 2, CIA + 4, 4, "load instruction");
  return CIA + 8;
}
#line 75 "support.c"

INLINE_SUPPORT\
(address_word)
loadstore_ea
(SIM_DESC sd, instruction_address cia, int MY_INDEX, address_word base, address_word offset)
{
#line 144 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  return base + offset;
}
#line 85 "support.c"

INLINE_SUPPORT\
(int)
not_word_value
(SIM_DESC sd, instruction_address cia, int MY_INDEX, unsigned_word value)
{
#line 179 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  /* For historical simulator compatibility (until documentation is
     found that makes these operations unpredictable on some of these
     architectures), this check never returns true.  */
  return 0;
}
#line 98 "support.c"

INLINE_SUPPORT\
(void)
unpredictable
(SIM_DESC sd, instruction_address cia, int MY_INDEX)
{
#line 219 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
}
#line 107 "support.c"

INLINE_SUPPORT\
(int)
check_mf_cycles
(SIM_DESC sd, instruction_address cia, int MY_INDEX, hilo_history *history, signed64 time, const char *new)
{
#line 268 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  if (history->mf.timestamp + 3 > time)
    {
      sim_engine_abort (SD, CPU, CIA, "HILO: %s: %s at 0x%08lx too close to MF at 0x%08lx\n",
  			itable[MY_INDEX].name,
  			new, (long) CIA,
  			(long) history->mf.cia);
      return 0;
    }
  return 1;
}
#line 125 "support.c"

INLINE_SUPPORT\
(int)
check_mt_hilo
(SIM_DESC sd, instruction_address cia, int MY_INDEX, hilo_history *history)
{
#line 303 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  signed64 time = sim_events_time (SD);
  int ok = (! MIPS_MACH_HAS_MT_HILO_HAZARD (SD)
  	    || check_mf_cycles (SD_, history, time, "MT"));
  history->mt.timestamp = time;
  history->mt.cia = CIA;
  return ok;
}
#line 140 "support.c"

INLINE_SUPPORT\
(int)
check_mf_hilo
(SIM_DESC sd, instruction_address cia, int MY_INDEX, hilo_history *history, hilo_history *peer)
{
#line 344 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  signed64 time = sim_events_time (SD);
  int ok = 1;
  if (peer != NULL
      && peer->mt.timestamp > history->op.timestamp
      && history->mt.timestamp < history->op.timestamp
      && ! (history->mf.timestamp > history->op.timestamp
  	    && history->mf.timestamp < peer->mt.timestamp)
      && ! (peer->mf.timestamp > history->op.timestamp
  	    && peer->mf.timestamp < peer->mt.timestamp))
    {
      /* The peer has been written to since the last OP yet we have
         not */
      sim_engine_abort (SD, CPU, CIA, "HILO: %s: MF at 0x%08lx following OP at 0x%08lx corrupted by MT at 0x%08lx\n",
  			itable[MY_INDEX].name,
  			(long) CIA,
  			(long) history->op.cia,
  			(long) peer->mt.cia);
      ok = 0;
    }
  history->mf.timestamp = time;
  history->mf.cia = CIA;
  return ok;
}
#line 171 "support.c"

INLINE_SUPPORT\
(int)
check_mult_hilo
(SIM_DESC sd, instruction_address cia, int MY_INDEX, hilo_history *hi, hilo_history *lo)
{
#line 396 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  signed64 time = sim_events_time (SD);
  int ok = (! MIPS_MACH_HAS_MULT_HILO_HAZARD (SD)
  	    || (check_mf_cycles (SD_, hi, time, "OP")
  	        && check_mf_cycles (SD_, lo, time, "OP")));
  hi->op.timestamp = time;
  lo->op.timestamp = time;
  hi->op.cia = CIA;
  lo->op.cia = CIA;
  return ok;
}
#line 189 "support.c"

INLINE_SUPPORT\
(int)
check_div_hilo
(SIM_DESC sd, instruction_address cia, int MY_INDEX, hilo_history *hi, hilo_history *lo)
{
#line 451 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  signed64 time = sim_events_time (SD);
  int ok = (! MIPS_MACH_HAS_DIV_HILO_HAZARD (SD)
  	    || (check_mf_cycles (SD_, hi, time, "OP")
  	        && check_mf_cycles (SD_, lo, time, "OP")));
  hi->op.timestamp = time;
  lo->op.timestamp = time;
  hi->op.cia = CIA;
  lo->op.cia = CIA;
  return ok;
}
#line 207 "support.c"

INLINE_SUPPORT\
(void)
check_u64
(SIM_DESC sd, instruction_address cia, int MY_INDEX, instruction_word insn)
{
#line 492 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  // The check should be similar to mips64 for any with PX/UX bit equivalents.
}
#line 217 "support.c"

INLINE_SUPPORT\
(void)
do_addiu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, unsigned16 immediate)
{
#line 574 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  if (NotWordValue (GPR[rs]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rs], EXTEND16 (immediate));
  GPR[rt] = EXTEND32 (GPR[rs] + EXTEND16 (immediate));
  TRACE_ALU_RESULT (GPR[rt]);
}
#line 231 "support.c"

INLINE_SUPPORT\
(void)
do_addu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 603 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  if (NotWordValue (GPR[rs]) || NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  GPR[rd] = EXTEND32 (GPR[rs] + GPR[rt]);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 245 "support.c"

INLINE_SUPPORT\
(void)
do_and
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 632 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  GPR[rd] = GPR[rs] & GPR[rt];
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 257 "support.c"

INLINE_SUPPORT\
(void)
do_daddiu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, unsigned16 immediate)
{
#line 1236 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], EXTEND16 (immediate));
  GPR[rt] = GPR[rs] + EXTEND16 (immediate);
  TRACE_ALU_RESULT (GPR[rt]);
}
#line 269 "support.c"

INLINE_SUPPORT\
(void)
do_daddu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 1259 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  GPR[rd] = GPR[rs] + GPR[rt];
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 281 "support.c"

INLINE_SUPPORT\
(void)
do_ddiv
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt)
{
#line 1332 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  check_div_hilo (SD_, HIHISTORY, LOHISTORY);
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  {
    signed64 n = GPR[rs];
    signed64 d = GPR[rt];
    signed64 hi;
    signed64 lo;
    if (d == 0)
      {
  	lo = SIGNED64 (0x8000000000000000);
  	hi = 0;
      }
    else if (d == -1 && n == SIGNED64 (0x8000000000000000))
      {
  	lo = SIGNED64 (0x8000000000000000);
  	hi = 0;
      }
    else
      {
  	lo = (n / d);
  	hi = (n % d);
      }
    HI = hi;
    LO = lo;
  }
  TRACE_ALU_RESULT2 (HI, LO);
}
#line 316 "support.c"

INLINE_SUPPORT\
(void)
do_ddivu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt)
{
#line 1378 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  check_div_hilo (SD_, HIHISTORY, LOHISTORY);
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  {
    unsigned64 n = GPR[rs];
    unsigned64 d = GPR[rt];
    unsigned64 hi;
    unsigned64 lo;
    if (d == 0)
      {
  	lo = SIGNED64 (0x8000000000000000);
  	hi = 0;
      }
    else
      {
  	lo = (n / d);
  	hi = (n % d);
      }
    HI = hi;
    LO = lo;
  }
  TRACE_ALU_RESULT2 (HI, LO);
}
#line 346 "support.c"

INLINE_SUPPORT\
(void)
do_div
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt)
{
#line 1417 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  check_div_hilo (SD_, HIHISTORY, LOHISTORY);
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  {
    signed32 n = GPR[rs];
    signed32 d = GPR[rt];
    if (d == 0)
      {
  	LO = EXTEND32 (0x80000000);
  	HI = EXTEND32 (0);
      }
    else if (n == SIGNED32 (0x80000000) && d == -1)
      {
  	LO = EXTEND32 (0x80000000);
  	HI = EXTEND32 (0);
      }
    else
      {
  	LO = EXTEND32 (n / d);
  	HI = EXTEND32 (n % d);
      }
  }
  TRACE_ALU_RESULT2 (HI, LO);
}
#line 377 "support.c"

INLINE_SUPPORT\
(void)
do_divu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt)
{
#line 1463 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  check_div_hilo (SD_, HIHISTORY, LOHISTORY);
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  {
    unsigned32 n = GPR[rs];
    unsigned32 d = GPR[rt];
    if (d == 0)
      {
  	LO = EXTEND32 (0x80000000);
  	HI = EXTEND32 (0);
      }
    else
      {
  	LO = EXTEND32 (n / d);
  	HI = EXTEND32 (n % d);
      }
  }
  TRACE_ALU_RESULT2 (HI, LO);
}
#line 403 "support.c"

INLINE_SUPPORT\
(void)
do_dmultx
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd, int signed_p)
{
#line 1503 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  unsigned64 lo;
  unsigned64 hi;
  unsigned64 m00;
  unsigned64 m01;
  unsigned64 m10;
  unsigned64 m11;
  unsigned64 mid;
  int sign;
  unsigned64 op1 = GPR[rs];
  unsigned64 op2 = GPR[rt];
  check_mult_hilo (SD_, HIHISTORY, LOHISTORY);
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  /* make signed multiply unsigned */
  sign = 0;
  if (signed_p)
    {
      if ((signed64) op1 < 0)
  	{
  	  op1 = - op1;
  	  ++sign;
  	}
      if ((signed64) op2 < 0)
  	{
  	  op2 = - op2;
  	  ++sign;
  	}
    }
  /* multiply out the 4 sub products */
  m00 = ((unsigned64) VL4_8 (op1) * (unsigned64) VL4_8 (op2));
  m10 = ((unsigned64) VH4_8 (op1) * (unsigned64) VL4_8 (op2));
  m01 = ((unsigned64) VL4_8 (op1) * (unsigned64) VH4_8 (op2));
  m11 = ((unsigned64) VH4_8 (op1) * (unsigned64) VH4_8 (op2));
  /* add the products */
  mid = ((unsigned64) VH4_8 (m00)
  	 + (unsigned64) VL4_8 (m10)
  	 + (unsigned64) VL4_8 (m01));
  lo = U8_4 (mid, m00);
  hi = (m11
  	+ (unsigned64) VH4_8 (mid)
  	+ (unsigned64) VH4_8 (m01)
  	+ (unsigned64) VH4_8 (m10));
  /* fix the sign */
  if (sign & 1)
    {
      lo = -lo;
      if (lo == 0)
  	hi = -hi;
      else
  	hi = -hi - 1;
    }
  /* save the result HI/LO (and a gpr) */
  LO = lo;
  HI = hi;
  if (rd != 0)
    GPR[rd] = lo;
  TRACE_ALU_RESULT2 (HI, LO);
}
#line 468 "support.c"

INLINE_SUPPORT\
(void)
do_dmult
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 1563 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  do_dmultx (SD_, rs, rt, rd, 1);
}
#line 478 "support.c"

INLINE_SUPPORT\
(void)
do_dmultu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 1592 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  do_dmultx (SD_, rs, rt, rd, 0);
}
#line 488 "support.c"

INLINE_SUPPORT\
(unsigned64)
do_dror
(SIM_DESC sd, instruction_address cia, int MY_INDEX, unsigned64 x,unsigned64 y)
{
#line 1620 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  unsigned64 result;

  y &= 63;
  TRACE_ALU_INPUT2 (x, y);
  result = ROTR64 (x, y);
  TRACE_ALU_RESULT (result);
  return result;
}
#line 504 "support.c"

INLINE_SUPPORT\
(void)
do_dsll
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int rd, int shift)
{
#line 1662 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  TRACE_ALU_INPUT2 (GPR[rt], shift);
  GPR[rd] = GPR[rt] << shift;
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 516 "support.c"

INLINE_SUPPORT\
(void)
do_dsllv
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 1701 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  int s = MASKED64 (GPR[rs], 5, 0);
  TRACE_ALU_INPUT2 (GPR[rt], s);
  GPR[rd] = GPR[rt] << s;
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 529 "support.c"

INLINE_SUPPORT\
(void)
do_dsra
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int rd, int shift)
{
#line 1723 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  TRACE_ALU_INPUT2 (GPR[rt], shift);
  GPR[rd] = ((signed64) GPR[rt]) >> shift;
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 541 "support.c"

INLINE_SUPPORT\
(void)
do_dsrav
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 1764 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  int s = MASKED64 (GPR[rs], 5, 0);
  TRACE_ALU_INPUT2 (GPR[rt], s);
  GPR[rd] = ((signed64) GPR[rt]) >> s;
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 554 "support.c"

INLINE_SUPPORT\
(void)
do_dsrl
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int rd, int shift)
{
#line 1786 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  TRACE_ALU_INPUT2 (GPR[rt], shift);
  GPR[rd] = (unsigned64) GPR[rt] >> shift;
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 566 "support.c"

INLINE_SUPPORT\
(void)
do_dsrlv
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 1827 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  int s = MASKED64 (GPR[rs], 5, 0);
  TRACE_ALU_INPUT2 (GPR[rt], s);
  GPR[rd] = (unsigned64) GPR[rt] >> s;
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 579 "support.c"

INLINE_SUPPORT\
(void)
do_dsubu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 1873 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  GPR[rd] = GPR[rs] - GPR[rt];
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 591 "support.c"

INLINE_SUPPORT\
(unsigned_word)
do_load
(SIM_DESC sd, instruction_address cia, int MY_INDEX, unsigned access, address_word base, address_word offset)
{
#line 1980 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  address_word mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
  address_word reverseendian = (ReverseEndian ? (mask ^ access) : 0);
  address_word bigendiancpu = (BigEndianCPU ? (mask ^ access) : 0);
  unsigned int byte;
  address_word paddr;
  int uncached;
  unsigned64 memval;
  address_word vaddr;

  vaddr = loadstore_ea (SD_, base, offset);
  if ((vaddr & access) != 0)
    {
      SIM_CORE_SIGNAL (SD, STATE_CPU (SD, 0), cia, read_map, access+1, vaddr, read_transfer, sim_core_unaligned_signal);
    }
  AddressTranslation (vaddr, isDATA, isLOAD, &paddr, &uncached, isTARGET, isREAL);
  paddr = ((paddr & ~mask) | ((paddr & mask) ^ reverseendian));
  LoadMemory (&memval, NULL, uncached, access, paddr, vaddr, isDATA, isREAL);
  byte = ((vaddr & mask) ^ bigendiancpu);
  return (memval >> (8 * byte));
}
#line 619 "support.c"

INLINE_SUPPORT\
(unsigned_word)
do_load_left
(SIM_DESC sd, instruction_address cia, int MY_INDEX, unsigned access, address_word base, address_word offset, unsigned_word rt)
{
#line 2003 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  address_word mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
  address_word reverseendian = (ReverseEndian ? -1 : 0);
  address_word bigendiancpu = (BigEndianCPU ? -1 : 0);
  unsigned int byte;
  unsigned int word;
  address_word paddr;
  int uncached;
  unsigned64 memval;
  address_word vaddr;
  int nr_lhs_bits;
  int nr_rhs_bits;
  unsigned_word lhs_mask;
  unsigned_word temp;

  vaddr = loadstore_ea (SD_, base, offset);
  AddressTranslation (vaddr, isDATA, isLOAD, &paddr, &uncached, isTARGET, isREAL);
  paddr = (paddr ^ (reverseendian & mask));
  if (BigEndianMem == 0)
    paddr = paddr & ~access;

  /* compute where within the word/mem we are */
  byte = ((vaddr ^ bigendiancpu) & access); /* 0..access */
  word = ((vaddr ^ bigendiancpu) & (mask & ~access)) / (access + 1); /* 0..1 */
  nr_lhs_bits = 8 * byte + 8;
  nr_rhs_bits = 8 * access - 8 * byte;
  /* nr_lhs_bits + nr_rhs_bits == 8 * (accesss + 1) */

  /* fprintf (stderr, "l[wd]l: 0x%08lx%08lx 0x%08lx%08lx %d:%d %d+%d\n",
  	   (long) ((unsigned64) vaddr >> 32), (long) vaddr,
  	   (long) ((unsigned64) paddr >> 32), (long) paddr,
  	   word, byte, nr_lhs_bits, nr_rhs_bits); */

  LoadMemory (&memval, NULL, uncached, byte, paddr, vaddr, isDATA, isREAL);
  if (word == 0)
    {
      /* GPR_31..32-NR_LHS_BITS_ = memval_NR_LHS_BITS-1..0_ */
      temp = (memval << nr_rhs_bits);
    }
  else
    {
      /* GPR_31..32-NR_LHS_BITS = memval_32+NR_LHS_BITS..32_ */
      temp = (memval >> nr_lhs_bits);
    }
  lhs_mask = LSMASK (nr_lhs_bits + nr_rhs_bits - 1, nr_rhs_bits);
  rt = (rt & ~lhs_mask) | (temp & lhs_mask);

  /* fprintf (stderr, "l[wd]l: 0x%08lx%08lx -> 0x%08lx%08lx & 0x%08lx%08lx -> 0x%08lx%08lx\n",
  	   (long) ((unsigned64) memval >> 32), (long) memval,
  	   (long) ((unsigned64) temp >> 32), (long) temp,
  	   (long) ((unsigned64) lhs_mask >> 32), (long) lhs_mask,
  	   (long) (rt >> 32), (long) rt); */
  return rt;
}
#line 680 "support.c"

INLINE_SUPPORT\
(unsigned_word)
do_load_right
(SIM_DESC sd, instruction_address cia, int MY_INDEX, unsigned access, address_word base, address_word offset, unsigned_word rt)
{
#line 2059 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  address_word mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
  address_word reverseendian = (ReverseEndian ? -1 : 0);
  address_word bigendiancpu = (BigEndianCPU ? -1 : 0);
  unsigned int byte;
  address_word paddr;
  int uncached;
  unsigned64 memval;
  address_word vaddr;

  vaddr = loadstore_ea (SD_, base, offset);
  AddressTranslation (vaddr, isDATA, isLOAD, &paddr, &uncached, isTARGET, isREAL);
  /* NOTE: SPEC is wrong, has `BigEndianMem == 0' not `BigEndianMem != 0' */
  paddr = (paddr ^ (reverseendian & mask));
  if (BigEndianMem != 0)
    paddr = paddr & ~access;
  byte = ((vaddr & mask) ^ (bigendiancpu & mask));
  /* NOTE: SPEC is wrong, had `byte' not `access - byte'.  See SW. */
  LoadMemory (&memval, NULL, uncached, access - (access & byte), paddr, vaddr, isDATA, isREAL);
  /* printf ("lr: 0x%08lx %d@0x%08lx 0x%08lx\n",
     (long) paddr, byte, (long) paddr, (long) memval); */
  {
    unsigned_word screen = LSMASK (8 * (access - (byte & access) + 1) - 1, 0);
    rt &= ~screen;
    rt |= (memval >> (8 * byte)) & screen;
  }
  return rt;
}
#line 715 "support.c"

INLINE_SUPPORT\
(void)
do_mfhi
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd)
{
#line 2468 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  check_mf_hilo (SD_, HIHISTORY, LOHISTORY);
  TRACE_ALU_INPUT1 (HI);
  GPR[rd] = HI;
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 728 "support.c"

INLINE_SUPPORT\
(void)
do_mflo
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd)
{
#line 2492 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  check_mf_hilo (SD_, LOHISTORY, HIHISTORY);
  TRACE_ALU_INPUT1 (LO);
  GPR[rd] = LO;
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 741 "support.c"

INLINE_SUPPORT\
(void)
do_mult
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 2652 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  signed64 prod;
  check_mult_hilo (SD_, HIHISTORY, LOHISTORY);
  if (NotWordValue (GPR[rs]) || NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  prod = (((signed64)(signed32) GPR[rs])
  	  * ((signed64)(signed32) GPR[rt]));
  LO = EXTEND32 (VL4_8 (prod));
  HI = EXTEND32 (VH4_8 (prod));
  if (rd != 0)
    GPR[rd] = LO;
  TRACE_ALU_RESULT2 (HI, LO);
}
#line 762 "support.c"

INLINE_SUPPORT\
(void)
do_multu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 2695 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  unsigned64 prod;
  check_mult_hilo (SD_, HIHISTORY, LOHISTORY);
  if (NotWordValue (GPR[rs]) || NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  prod = (((unsigned64)(unsigned32) GPR[rs])
  	  * ((unsigned64)(unsigned32) GPR[rt]));
  LO = EXTEND32 (VL4_8 (prod));
  HI = EXTEND32 (VH4_8 (prod));
  if (rd != 0)
    GPR[rd] = LO;
  TRACE_ALU_RESULT2 (HI, LO);
}
#line 783 "support.c"

INLINE_SUPPORT\
(void)
do_nor
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 2737 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  GPR[rd] = ~ (GPR[rs] | GPR[rt]);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 795 "support.c"

INLINE_SUPPORT\
(void)
do_or
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 2763 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  GPR[rd] = (GPR[rs] | GPR[rt]);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 807 "support.c"

INLINE_SUPPORT\
(void)
do_ori
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, unsigned immediate)
{
#line 2790 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], immediate);
  GPR[rt] = (GPR[rs] | immediate);
  TRACE_ALU_RESULT (GPR[rt]);
}
#line 819 "support.c"

INLINE_SUPPORT\
(unsigned64)
do_ror
(SIM_DESC sd, instruction_address cia, int MY_INDEX, unsigned32 x,unsigned32 y)
{
#line 2840 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  unsigned64 result;

  y &= 31;
  TRACE_ALU_INPUT2 (x, y);
  result = EXTEND32 (ROTR32 (x, y));
  TRACE_ALU_RESULT (result);
  return result;
}
#line 835 "support.c"

INLINE_SUPPORT\
(void)
do_store
(SIM_DESC sd, instruction_address cia, int MY_INDEX, unsigned access, address_word base, address_word offset, unsigned_word word)
{
#line 2872 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  address_word mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
  address_word reverseendian = (ReverseEndian ? (mask ^ access) : 0);
  address_word bigendiancpu = (BigEndianCPU ? (mask ^ access) : 0);
  unsigned int byte;
  address_word paddr;
  int uncached;
  unsigned64 memval;
  address_word vaddr;

  vaddr = loadstore_ea (SD_, base, offset);
  if ((vaddr & access) != 0)
    {
      SIM_CORE_SIGNAL (SD, STATE_CPU(SD, 0), cia, read_map, access+1, vaddr, write_transfer, sim_core_unaligned_signal);
    }
  AddressTranslation (vaddr, isDATA, isSTORE, &paddr, &uncached, isTARGET, isREAL);
  paddr = ((paddr & ~mask) | ((paddr & mask) ^ reverseendian));
  byte = ((vaddr & mask) ^ bigendiancpu);
  memval = (word << (8 * byte));
  StoreMemory (uncached, access, memval, 0, paddr, vaddr, isREAL);
}
#line 863 "support.c"

INLINE_SUPPORT\
(void)
do_store_left
(SIM_DESC sd, instruction_address cia, int MY_INDEX, unsigned access, address_word base, address_word offset, unsigned_word rt)
{
#line 2895 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  address_word mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
  address_word reverseendian = (ReverseEndian ? -1 : 0);
  address_word bigendiancpu = (BigEndianCPU ? -1 : 0);
  unsigned int byte;
  unsigned int word;
  address_word paddr;
  int uncached;
  unsigned64 memval;
  address_word vaddr;
  int nr_lhs_bits;
  int nr_rhs_bits;

  vaddr = loadstore_ea (SD_, base, offset);
  AddressTranslation (vaddr, isDATA, isSTORE, &paddr, &uncached, isTARGET, isREAL);
  paddr = (paddr ^ (reverseendian & mask));
  if (BigEndianMem == 0)
    paddr = paddr & ~access;

  /* compute where within the word/mem we are */
  byte = ((vaddr ^ bigendiancpu) & access); /* 0..access */
  word = ((vaddr ^ bigendiancpu) & (mask & ~access)) / (access + 1); /* 0..1 */
  nr_lhs_bits = 8 * byte + 8;
  nr_rhs_bits = 8 * access - 8 * byte;
  /* nr_lhs_bits + nr_rhs_bits == 8 * (accesss + 1) */
  /* fprintf (stderr, "s[wd]l: 0x%08lx%08lx 0x%08lx%08lx %d:%d %d+%d\n",
  	   (long) ((unsigned64) vaddr >> 32), (long) vaddr,
  	   (long) ((unsigned64) paddr >> 32), (long) paddr,
  	   word, byte, nr_lhs_bits, nr_rhs_bits); */

  if (word == 0)
    {
      memval = (rt >> nr_rhs_bits);
    }
  else
    {
      memval = (rt << nr_lhs_bits);
    }
  /* fprintf (stderr, "s[wd]l: 0x%08lx%08lx -> 0x%08lx%08lx\n",
  	   (long) ((unsigned64) rt >> 32), (long) rt,
  	   (long) ((unsigned64) memval >> 32), (long) memval); */
  StoreMemory (uncached, byte, memval, 0, paddr, vaddr, isREAL);
}
#line 913 "support.c"

INLINE_SUPPORT\
(void)
do_store_right
(SIM_DESC sd, instruction_address cia, int MY_INDEX, unsigned access, address_word base, address_word offset, unsigned_word rt)
{
#line 2940 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  address_word mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
  address_word reverseendian = (ReverseEndian ? -1 : 0);
  address_word bigendiancpu = (BigEndianCPU ? -1 : 0);
  unsigned int byte;
  address_word paddr;
  int uncached;
  unsigned64 memval;
  address_word vaddr;

  vaddr = loadstore_ea (SD_, base, offset);
  AddressTranslation (vaddr, isDATA, isSTORE, &paddr, &uncached, isTARGET, isREAL);
  paddr = (paddr ^ (reverseendian & mask));
  if (BigEndianMem != 0)
    paddr &= ~access;
  byte = ((vaddr & mask) ^ (bigendiancpu & mask));
  memval = (rt << (byte * 8));
  StoreMemory (uncached, access - (access & byte), memval, 0, paddr, vaddr, isREAL);
}
#line 939 "support.c"

INLINE_SUPPORT\
(void)
do_sll
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int rd, int shift)
{
#line 3148 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  unsigned32 temp = (GPR[rt] << shift);
  TRACE_ALU_INPUT2 (GPR[rt], shift);
  GPR[rd] = EXTEND32 (temp);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 952 "support.c"

INLINE_SUPPORT\
(void)
do_sllv
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 3190 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  int s = MASKED (GPR[rs], 4, 0);
  unsigned32 temp = (GPR[rt] << s);
  TRACE_ALU_INPUT2 (GPR[rt], s);
  GPR[rd] = EXTEND32 (temp);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 966 "support.c"

INLINE_SUPPORT\
(void)
do_slt
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 3218 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  GPR[rd] = ((signed_word) GPR[rs] < (signed_word) GPR[rt]);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 978 "support.c"

INLINE_SUPPORT\
(void)
do_slti
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, unsigned16 immediate)
{
#line 3244 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], EXTEND16 (immediate));
  GPR[rt] = ((signed_word) GPR[rs] < (signed_word) EXTEND16 (immediate));
  TRACE_ALU_RESULT (GPR[rt]);
}
#line 990 "support.c"

INLINE_SUPPORT\
(void)
do_sltiu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, unsigned16 immediate)
{
#line 3270 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], EXTEND16 (immediate));
  GPR[rt] = ((unsigned_word) GPR[rs] < (unsigned_word) EXTEND16 (immediate));
  TRACE_ALU_RESULT (GPR[rt]);
}
#line 1002 "support.c"

INLINE_SUPPORT\
(void)
do_sltu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 3297 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  GPR[rd] = ((unsigned_word) GPR[rs] < (unsigned_word) GPR[rt]);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 1014 "support.c"

INLINE_SUPPORT\
(void)
do_sra
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int rd, int shift)
{
#line 3323 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  signed32 temp = (signed32) GPR[rt] >> shift;
  if (NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rt], shift);
  GPR[rd] = EXTEND32 (temp);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 1029 "support.c"

INLINE_SUPPORT\
(void)
do_srav
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 3353 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  int s = MASKED (GPR[rs], 4, 0);
  signed32 temp = (signed32) GPR[rt] >> s;
  if (NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rt], s);
  GPR[rd] = EXTEND32 (temp);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 1045 "support.c"

INLINE_SUPPORT\
(void)
do_srl
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int rd, int shift)
{
#line 3384 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  unsigned32 temp = (unsigned32) GPR[rt] >> shift;
  if (NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rt], shift);
  GPR[rd] = EXTEND32 (temp);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 1060 "support.c"

INLINE_SUPPORT\
(void)
do_srlv
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 3413 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  int s = MASKED (GPR[rs], 4, 0);
  unsigned32 temp = (unsigned32) GPR[rt] >> s;
  if (NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rt], s);
  GPR[rd] = EXTEND32 (temp);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 1076 "support.c"

INLINE_SUPPORT\
(void)
do_subu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 3470 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  if (NotWordValue (GPR[rs]) || NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  GPR[rd] = EXTEND32 (GPR[rs] - GPR[rt]);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 1090 "support.c"

INLINE_SUPPORT\
(void)
do_xor
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 3828 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  GPR[rd] = GPR[rs] ^ GPR[rt];
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 1102 "support.c"

INLINE_SUPPORT\
(void)
do_xori
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, unsigned16 immediate)
{
#line 3854 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], immediate);
  GPR[rt] = GPR[rs] ^ immediate;
  TRACE_ALU_RESULT (GPR[rt]);
}
#line 1114 "support.c"

INLINE_SUPPORT\
(const char *)
str_FMT
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int fmt)
{
#line 3887 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  switch (fmt)
    {
    case fmt_single: return "s";
    case fmt_double: return "d";
    case fmt_word: return "w";
    case fmt_long: return "l";
    case fmt_ps: return "ps";
    default: return "?";
    }
}
#line 1132 "support.c"

INLINE_SUPPORT\
(const char *)
str_TF
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int tf)
{
#line 3900 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  if (tf)
    return "t";
  else
    return "f";
}
#line 1145 "support.c"

INLINE_SUPPORT\
(const char *)
str_ND
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int nd)
{
#line 3908 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  if (nd)
    return "l";
  else
    return "";
}
#line 1158 "support.c"

INLINE_SUPPORT\
(const char *)
str_COND
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int cond)
{
#line 3916 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  switch (cond)
    {
    case 00: return "f";
    case 01: return "un";
    case 02: return "eq";
    case 03: return "ueq";
    case 04: return "olt";
    case 05: return "ult";
    case 06: return "ole";
    case 07: return "ule";
    case 010: return "sf";
    case 011: return "ngle";
    case 012: return "seq";
    case 013: return "ngl";
    case 014: return "lt";
    case 015: return "nge";
    case 016: return "le";
    case 017: return "ngt";
    default: return "?";
    }
}
#line 1187 "support.c"

INLINE_SUPPORT\
(void)
check_fmt_p
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int fmt, instruction_word insn)
{
#line 3957 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  /* None of these ISAs support Paired Single, so just fall back to
     the single/double check.  */
  if ((fmt != fmt_single) && (fmt != fmt_double))
    SignalException (ReservedInstruction, insn);
}
#line 1200 "support.c"

INLINE_SUPPORT\
(void)
check_fpu
(SIM_DESC sd, instruction_address cia, int MY_INDEX)
{
#line 3994 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/mips.igen"
  if (! COP_Usable (1))
    SignalExceptionCoProcessorUnusable (1);
}
#line 1211 "support.c"

INLINE_SUPPORT\
(address_word)
delayslot16
(SIM_DESC sd, instruction_address cia, int MY_INDEX, address_word nia, address_word target)
{
#line 1037 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/m16.igen"
  instruction_word delay_insn;
  sim_events_slip (SD, 1);
  DSPC = CIA; /* save current PC somewhere */
  STATE |= simDELAYSLOT;
  delay_insn = IMEM16 (nia); /* NOTE: mips16 */
  idecode_issue (CPU_, delay_insn, (nia));
  STATE &= ~simDELAYSLOT;
  return target;
}
#line 1228 "support.c"

INLINE_SUPPORT\
(address_word)
basepc
(SIM_DESC sd, instruction_address cia, int MY_INDEX)
{
#line 1050 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/m16.igen"
  if (STATE & simDELAYSLOT)
    {
      return DSPC; /* return saved address of preceeding jmp */
    }
  else
    {
      return CIA;
    }
}
#line 1245 "support.c"

INLINE_SUPPORT\
(const char *)
str_MFHI
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int hi)
{
#line 8 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/vr.igen"
  return hi ? "hi" : "";
}
#line 1255 "support.c"

INLINE_SUPPORT\
(const char *)
str_SAT
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int s)
{
#line 13 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/vr.igen"
  return s ? "s" : "";
}
#line 1265 "support.c"

INLINE_SUPPORT\
(const char *)
str_UNS
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int u)
{
#line 18 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/vr.igen"
  return u ? "u" : "";
}
#line 1275 "support.c"

INLINE_SUPPORT\
(void)
do_vr_mul_op
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs, int rt, int accumulate_p, int store_hi_p, int unsigned_p, int saturate_p, int subtract_p, int short_p, int double_p)
{
#line 43 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/vr.igen"
  unsigned64 lhs, x, y, xcut, ycut, product, result;

  check_mult_hilo (SD_, HIHISTORY, LOHISTORY);

  lhs = (!accumulate_p ? 0 : double_p ? LO : U8_4 (HI, LO));
  x = GPR[rs];
  y = GPR[rt];

  /* Work out the canonical form of X and Y from their significant bits.  */
  if (!short_p)
    {
      /* Normal sign-extension rule for 32-bit operands.  */
      xcut = EXTEND32 (x);
      ycut = EXTEND32 (y);
    }
  else if (unsigned_p)
    {
      /* Operands must be zero-extended 16-bit numbers.  */
      xcut = x & 0xffff;
      ycut = y & 0xffff;
    }
  else
    {
      /* Likewise but sign-extended.  */
      xcut = EXTEND16 (x);
      ycut = EXTEND16 (y);
    }
  if (x != xcut || y != ycut)
    sim_engine_abort (SD, CPU, CIA,
  		      "invalid multiplication operand at 0x%08lx\n",
  		      (long) CIA);

  TRACE_ALU_INPUT2 (x, y);
  product = (unsigned_p
  	     ? V8_4 (x, 1) * V8_4 (y, 1)
  	     : EXTEND32 (x) * EXTEND32 (y));
  result = (subtract_p ? lhs - product : lhs + product);
  if (saturate_p)
    {
      /* Saturate the result to 32 bits.  An unsigned, unsaturated
  	 result is zero-extended to 64 bits, but unsigned overflow
  	 causes all 64 bits to be set.  */
      if (!unsigned_p && (unsigned64) EXTEND32 (result) != result)
  	result = ((signed64) result < 0 ? -0x7fffffff - 1 : 0x7fffffff);
      else if (unsigned_p && (result >> 32) != 0)
  	result = (unsigned64) 0 - 1;
    }
  TRACE_ALU_RESULT (result);

  if (double_p)
    LO = result;
  else
    {
      LO = EXTEND32 (result);
      HI = EXTEND32 (VH4_8 (result));
    }
  if (rd != 0)
    GPR[rd] = store_hi_p ? HI : LO;
}
#line 1342 "support.c"

INLINE_SUPPORT\
(void)
do_ph_op
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs, int rt, int op, int sat)
{
#line 28 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/dsp.igen"
  int i;
  signed32 h0;
  signed16 h1, h2;
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  unsigned32 result = 0;
  for (i = 0; i < 32; i += 16, v1 >>= 16, v2 >>= 16)
    {
      h1 = (signed16)(v1 & 0xffff);
      h2 = (signed16)(v2 & 0xffff);
      if (op == 0) // ADD
  	h0 = (signed32)h1 + (signed32)h2;
      else // SUB
        h0 = (signed32)h1 - (signed32)h2;
      if (((h0 & 0x10000) >> 1) != (h0 & 0x8000))
  	{
  	  DSPCR |= DSPCR_OUFLAG4;
  	  if (sat == 1)
  	    {
  	      if (h0 & 0x10000)
  		h0 = 0x8000;
  	      else
  		h0 = 0x7fff;
  	    }
  	}
      result |= ((unsigned32)((unsigned16)h0) << i);
    }
  GPR[rd] = EXTEND32 (result);
}
#line 1379 "support.c"

INLINE_SUPPORT\
(void)
do_w_op
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs, int rt, int op)
{
#line 61 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/dsp.igen"
  signed64 h0;
  signed32 h1, h2;
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  unsigned32 result = 0;
  h1 = (signed32)v1;
  h2 = (signed32)v2;
  if (op == 0) // ADD
    h0 = (signed64)h1 + (signed64)h2;
  else // SUB
    h0 = (signed64)h1 - (signed64)h2;
  if (((h0 & 0x100000000) >> 1) != (h0 & 0x80000000))
    {
      DSPCR |= DSPCR_OUFLAG4;
      if (h0 & 0x100000000)
  	h0 = 0x80000000;
      else
  	h0 = 0x7fffffff;
    }
  GPR[rd] = EXTEND32 (h0);
}
#line 1408 "support.c"

INLINE_SUPPORT\
(void)
do_qb_op
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs, int rt, int op, int sat)
{
#line 87 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/dsp.igen"
  int i;
  unsigned32 h0;
  unsigned8 h1, h2;
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  unsigned32 result = 0;
  for (i = 0; i < 32; i += 8, v1 >>= 8, v2 >>= 8)
    {
      h1 = (unsigned8)(v1 & 0xff);
      h2 = (unsigned8)(v2 & 0xff);
      if (op == 0) // ADD
  	h0 = (unsigned32)h1 + (unsigned32)h2;
      else // SUB
  	h0 = (unsigned32)h1 - (unsigned32)h2;
      if (h0 & 0x100)
  	{
  	  DSPCR |= DSPCR_OUFLAG4;
  	  if (sat == 1)
  	    {
  	      if (op == 0) // ADD
  		h0 = 0xff;
  	      else // SUB
  		h0 = 0;
  	    }
  	}
      result |= ((unsigned32)((unsigned8)h0) << i);
    }
  GPR[rd] = EXTEND32 (result);
}
#line 1445 "support.c"

INLINE_SUPPORT\
(void)
do_qb_shift
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rt, int shift, int op)
{
#line 120 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/dsp.igen"
  int i, j;
  unsigned8 h0;
  unsigned32 v1 = GPR[rt];
  unsigned32 result = 0;
  for (i = 0; i < 32; i += 8, v1 >>= 8)
    {
      h0 = (unsigned8)(v1 & 0xff);
      if (op == 0) // left
  	{
  	  for (j = 7; j >= 8 - shift; j--)
  	    {
  	      if (h0 & (1<<j))
  		{
  		  DSPCR |= DSPCR_OUFLAG6;
  		  break;
  		}
  	    }
          h0 = h0 << shift;
  	}
      else // right
        h0 = h0 >> shift;
      result |= ((unsigned32)h0 << i);
    }
  GPR[rd] = EXTEND32 (result);
}
#line 1478 "support.c"

INLINE_SUPPORT\
(void)
do_ph_shift
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rt, int shift, int op, int sat)
{
#line 150 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/dsp.igen"
  int i, j;
  signed16 h0;
  unsigned32 v1 = GPR[rt];
  unsigned32 result = 0;
  int setcond;
  for (i = 0; i < 32; i += 16, v1 >>= 16)
    {
      h0 = (signed16)(v1 & 0xffff);
      if (op == 0) // left
  	{
  	  setcond = 0;
  	  if (h0 & (1<<15))
  	    {
  	      for (j = 14; j >= 15 - shift; j--)
  		{
  		  if (!(h0 & (1 << j)))
  		    {
  		      DSPCR |= DSPCR_OUFLAG6;
  		      setcond = 1;
  		      break;
  		    }
  		}
  	    }
  	  else
  	    {
  	      for (j = 14; j >= 15 - shift; j--)
  		{
  		  if (h0 & (1 << j))
  		    {
  		      DSPCR |= DSPCR_OUFLAG6;
  		      setcond = 2;
  		      break;
  		    }
  		}
  	    }
  	  h0 = h0 << shift;
  	  if (sat == 1)
  	    {
  	      if (setcond == 2)
  		h0 = 0x7fff; 
  	      else if (setcond == 1)
  		h0 = 0x8000;
  	    }
  	}
      else // right
  	{
  	  if (sat == 1 && shift != 0)
  	    h0 += (1 << (shift - 1));
  	  h0 = h0 >> shift;
  	}

      result |= ((unsigned32)((unsigned16)h0) << i);
    }
  GPR[rd] = EXTEND32 (result);
}
#line 1541 "support.c"

INLINE_SUPPORT\
(void)
do_w_shll
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rt, int shift)
{
#line 208 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/dsp.igen"
  int i;
  unsigned32 v1 = GPR[rt];
  unsigned32 result = 0;
  int setcond = 0;
  if (v1 & (1 << 31))
    {
      for (i = 30; i >= 31 - shift; i--)
  	{
  	  if (!(v1 & (1 << i)))
  	    {
  	      DSPCR |= DSPCR_OUFLAG6;
  	      setcond = 1;
  	      break;
  	    }
  	}
    }
  else
    {
      for (i = 30; i >= 31 - shift; i--)
  	{
  	  if (v1 & (1 << i))
  	    {
  	      DSPCR |= DSPCR_OUFLAG6;
  	      setcond = 2;
  	      break;
  	    }
  	}
    }
  if (setcond == 2)
    result = 0x7fffffff; 
  else if (setcond == 1)
    result = 0x80000000;
  else
    result = v1 << shift; 
  GPR[rd] = EXTEND32 (result);
}
#line 1585 "support.c"

INLINE_SUPPORT\
(void)
do_w_shra
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rt, int shift)
{
#line 247 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/dsp.igen"
  unsigned32 result = GPR[rt];
  signed32 h0 = (signed32)result;
  if (shift != 0)
    h0 += (1 << (shift - 1));
  h0 = h0 >> shift;
  GPR[rd] = EXTEND32 (h0);
}
#line 1600 "support.c"

INLINE_SUPPORT\
(void)
do_qb_muleu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs, int rt, int loc)
{
#line 739 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/dsp.igen"
  int i;
  unsigned32 result = 0;
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  unsigned16 h1, h2;
  unsigned32 prod;
  if (loc == 0)
    v1 >>= 16;
  for (i = 0; i < 32; i += 16, v1 >>= 8, v2 >>= 16)
    {
      h1 = (unsigned16)(v1 & 0xff);
      h2 = (unsigned16)(v2 & 0xffff);
      prod = (unsigned32)h1 * (unsigned32)h2;
      if (prod > 0xffff)
  	{
  	  DSPCR |= DSPCR_OUFLAG5;
  	  prod = 0xffff;
  	}
      result |= ((unsigned32)prod << i);
    }
  GPR[rd] = EXTEND32 (result);
}
#line 1630 "support.c"

INLINE_SUPPORT\
(void)
do_ph_muleq
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs, int rt, int loc)
{
#line 806 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/dsp.igen"
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  signed16 h1, h2;
  signed32 prod;
  if (loc == 0)
    {
      h1 = (signed16)(v1 >> 16);
      h2 = (signed16)(v2 >> 16);
    }
  else
    {
      h1 = (signed16)(v1 & 0xffff);
      h2 = (signed16)(v2 & 0xffff);
    }
  if (h1 == (signed16)0x8000 && h2 == (signed16)0x8000)
    {
      DSPCR |= DSPCR_OUFLAG5;
      prod = 0x7fffffff;
    }
  else
    prod = ((signed32)h1 * (signed32)h2) << 1;
  GPR[rd] = EXTEND32 (prod);
}
#line 1661 "support.c"

INLINE_SUPPORT\
(void)
do_qb_dot_product
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int ac, int rs, int rt, int op, int loc)
{
#line 848 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/dsp.igen"
  int i;
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  unsigned8 h1, h2;
  unsigned32 lo = DSPLO(ac);
  unsigned32 hi = DSPHI(ac);
  unsigned64 prod = (((unsigned64)hi) << 32) + (unsigned64)lo;
  if (loc == 0)
    {
      v1 >>= 16;
      v2 >>= 16;
    }
  for (i = 0; i < 16; i += 8, v1 >>= 8, v2 >>= 8)
    {
      h1 = (unsigned8)(v1 & 0xff);
      h2 = (unsigned8)(v2 & 0xff);
      if (op == 0) // DPAU
  	prod += (unsigned64)h1 * (unsigned64)h2;
      else // DPSU
  	prod -= (unsigned64)h1 * (unsigned64)h2;
    }
  DSPLO(ac) = EXTEND32 (prod);
  DSPHI(ac) = EXTEND32 (prod >> 32);
}
#line 1693 "support.c"

INLINE_SUPPORT\
(void)
do_ph_dot_product
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int ac, int rs, int rt, int op)
{
#line 904 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/dsp.igen"
  int i;
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  signed16 h1, h2;
  signed32 result;
  unsigned32 lo = DSPLO(ac);
  unsigned32 hi = DSPHI(ac);
  signed64 prod = (signed64)((((unsigned64)hi) << 32) + (unsigned64)lo);
  for (i = 0; i < 32; i += 16, v1 >>= 16, v2 >>= 16)
    {
      h1 = (signed16)(v1 & 0xffff);
      h2 = (signed16)(v2 & 0xffff);
      if (h1 == (signed16)0x8000 && h2 == (signed16)0x8000)
  	{
  	  DSPCR |= (1 << (DSPCR_OUFLAG_SHIFT + ac));
  	  result = (signed32)0x7fffffff;
  	}
      else
  	result = ((signed32)h1 * (signed32)h2) << 1;

      if (op == 0) // DPAQ
  	prod += (signed64)result;
      else // DPSQ
  	prod -= (signed64)result;
    }
  DSPLO(ac) = EXTEND32 (prod);
  DSPHI(ac) = EXTEND32 (prod >> 32);
}
#line 1729 "support.c"

INLINE_SUPPORT\
(void)
do_w_dot_product
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int ac, int rs, int rt, int op)
{
#line 983 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/dsp.igen"
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  signed32 h1, h2;
  signed64 result;
  unsigned32 lo = DSPLO(ac);
  unsigned32 hi = DSPHI(ac);
  unsigned32 resultlo;
  unsigned32 resulthi;
  unsigned32 carry;
  unsigned64 temp1;
  signed64 temp2;
  h1 = (signed32) v1;
  h2 = (signed32) v2;
  if (h1 == 0x80000000 && h2 == 0x80000000)
    {
      DSPCR |= (1 << (DSPCR_OUFLAG_SHIFT + ac));
      result = (signed64) 0x7fffffffffffffffLL;
    }
  else
    result = ((signed64)h1 * (signed64)h2) << 1;
  resultlo = (unsigned32)(result);
  resulthi = (unsigned32)(result >> 32);
  if (op ==0) // DPAQ
    {
      temp1 = (unsigned64)lo + (unsigned64)resultlo;
      carry = (unsigned32)((temp1 >> 32) & 1);
      temp2 = (signed64)((signed32)hi) + (signed64)((signed32)resulthi) +
  	      (signed64)((signed32)carry);
    }
  else // DPSQ
    {
      temp1 = (unsigned64)lo - (unsigned64)resultlo;
      carry = (unsigned32)((temp1 >> 32) & 1);
      temp2 = (signed64)((signed32)hi) - (signed64)((signed32)resulthi) -
  	      (signed64)((signed32)carry);
    }
  if (((temp2 & 0x100000000LL) >> 1) != (temp2 & 0x80000000LL))
    {
      DSPCR |= (1 << (DSPCR_OUFLAG_SHIFT + ac));
      if (temp2 & 0x100000000LL)
  	{
  	  DSPLO(ac) = EXTEND32 (0x00000000);
  	  DSPHI(ac) = EXTEND32 (0x80000000);
  	}
      else
  	{
  	  DSPLO(ac) = EXTEND32 (0xffffffff);
  	  DSPHI(ac) = EXTEND32 (0x7fffffff);
  	}
    }
  else
    {
      DSPLO(ac) = EXTEND32 (temp1);
      DSPHI(ac) = EXTEND32 (temp2);
    }
}
#line 1793 "support.c"

INLINE_SUPPORT\
(void)
do_ph_maq
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int ac, int rs, int rt, int op, int loc)
{
#line 1058 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/dsp.igen"
  int i;
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  signed16 h1, h2;
  signed32 result;
  unsigned32 lo = DSPLO(ac);
  unsigned32 hi = DSPHI(ac);
  signed64 prod = (signed64)((((unsigned64)hi) << 32) + (unsigned64)lo);
  if (loc == 0)
    {
      h1 = (signed16)(v1 >> 16);
      h2 = (signed16)(v2 >> 16);
    }
  else
    {
      h1 = (signed16)(v1 & 0xffff);
      h2 = (signed16)(v2 & 0xffff);
    }
  if (h1 == (signed16)0x8000 && h2 == (signed16)0x8000)
    {
      DSPCR |= (1 << (DSPCR_OUFLAG_SHIFT + ac));
      result = (signed32)0x7fffffff;
    }
  else
    result = ((signed32)h1 * (signed32)h2) << 1;
  prod += (signed64)result;
  if (op == 1) // MAQ_SA
    {
      if (prod & 0x8000000000000000LL)
  	{
  	  for (i = 62; i >= 31; i--)
  	    {
  	      if (!(prod & ((signed64)1 << i)))
  		{
  		  DSPCR |= (1 << (DSPCR_OUFLAG_SHIFT + ac));
  		  prod = 0xffffffff80000000LL;
  		  break;
  		}
  	    }
  	}
      else
  	{
  	  for (i = 62; i >= 31; i--)
  	    {
  	      if (prod & ((signed64)1 << i))
  		{
  		  DSPCR |= (1 << (DSPCR_OUFLAG_SHIFT + ac));
  		  prod = 0x7fffffff;
  		  break;
  		}
  	    }
  	}
    }
  DSPLO(ac) = EXTEND32 (prod);
  DSPHI(ac) = EXTEND32 (prod >> 32);
}
#line 1857 "support.c"

INLINE_SUPPORT\
(void)
do_qb_cmpu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int op)
{
#line 1218 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/dsp.igen"
  int i, j;
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  unsigned8 h1, h2;
  unsigned32 mask;
  for (i = 0, j = 0; i < 32; i += 8, j++, v1 >>= 8, v2 >>= 8)
    {
      h1 = (unsigned8)(v1 & 0xff);
      h2 = (unsigned8)(v2 & 0xff);
      mask = ~(1 << (DSPCR_CCOND_SHIFT + j));
      DSPCR &= mask;
      if (op == 0) // EQ
  	DSPCR |= ((h1 == h2) << (DSPCR_CCOND_SHIFT + j));
      else if (op == 1) // LT
  	DSPCR |= ((h1 < h2) << (DSPCR_CCOND_SHIFT + j));
      else // LE
  	DSPCR |= ((h1 <= h2) << (DSPCR_CCOND_SHIFT + j));
    }
}
#line 1884 "support.c"

INLINE_SUPPORT\
(void)
do_qb_cmpgu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs, int rt, int op)
{
#line 1262 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/dsp.igen"
  int i, j;
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  unsigned8 h1, h2;
  unsigned32 result = 0;
  for (i = 0, j = 0; i < 32; i += 8, j++, v1 >>= 8, v2 >>= 8)
    {
      h1 = (unsigned8)(v1 & 0xff);
      h2 = (unsigned8)(v2 & 0xff);
      if (op == 0) // EQ
  	result |= ((h1 == h2) << j);
      else if (op == 1) // LT
  	result |= ((h1 < h2) << j);
      else // LE
  	result |= ((h1 <= h2) << j);
    }
  GPR[rd] = EXTEND32 (result);
}
#line 1910 "support.c"

INLINE_SUPPORT\
(void)
do_ph_cmpu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int op)
{
#line 1305 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/dsp.igen"
  int i, j;
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  signed16 h1, h2;
  unsigned32 mask;
  for (i = 0, j = 0; i < 32; i += 16, j++, v1 >>= 16, v2 >>= 16)
    {
      h1 = (signed16)(v1 & 0xffff);
      h2 = (signed16)(v2 & 0xffff);
      mask = ~(1 << (DSPCR_CCOND_SHIFT + j));
      DSPCR &= mask;
      if (op == 0) // EQ
  	DSPCR |= ((h1 == h2) << (DSPCR_CCOND_SHIFT + j));
      else if (op == 1) // LT
  	DSPCR |= ((h1 < h2) << (DSPCR_CCOND_SHIFT + j));
      else // LE
  	DSPCR |= ((h1 <= h2) << (DSPCR_CCOND_SHIFT + j));
    }
}
#line 1937 "support.c"

INLINE_SUPPORT\
(void)
do_w_extr
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int ac, int shift, int op)
{
#line 1400 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/dsp.igen"
  int i;
  unsigned32 lo = DSPLO(ac);
  unsigned32 hi = DSPHI(ac);
  unsigned64 prod = (((unsigned64)hi) << 32) + (unsigned64)lo;
  signed64 result = (signed64)prod;
  int setcond = 0;
  if (!(prod & 0x8000000000000000LL))
    {
      for (i = 62; i >= (shift + 31); i--)
  	{
  	  if (prod & ((unsigned64)1 << i))
  	    {
  	      DSPCR |= DSPCR_OUFLAG7;
  	      setcond = 1;
  	      break;
  	    }
  	}
      if (((prod >> (shift - 1)) & 0xffffffffLL) == 0xffffffffLL)
  	{
  	  DSPCR |= DSPCR_OUFLAG7;
  	  setcond = 1;
  	}
    }
  else
    {
      for (i = 62; i >= (shift + 31); i--)
  	{
  	  if (!(prod & ((unsigned64)1 << i)))
  	    {
  	      DSPCR |= DSPCR_OUFLAG7;
  	      setcond = 2;
  	      break;
  	    }
  	}
    }
  if (op == 0) // EXTR
    result = result >> shift;
  else if (op == 1) // EXTR_R
    {
      if (shift != 0)
        result = ((result >> (shift - 1)) + 1) >> 1;
      else
  	result = result >> shift;
    }
  else // EXTR_RS
    {
      if (setcond == 1)
  	result = 0x7fffffff;
      else if (setcond == 2)
  	result = 0x80000000;
      else 
  	{
  	  if (shift != 0)
  	    result = ((result >> (shift - 1)) + 1) >> 1;
  	  else
  	    result = result >> shift;
  	}
    }
  GPR[rt] = EXTEND32 (result);
}
#line 2005 "support.c"

INLINE_SUPPORT\
(void)
do_h_extr
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int ac, int shift)
{
#line 1508 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/dsp.igen"
  int i;
  unsigned32 lo = DSPLO(ac);
  unsigned32 hi = DSPHI(ac);
  unsigned64 prod = (((unsigned64)hi) << 32) + (unsigned64)lo;
  signed64 result = (signed64)prod;
  signed64 value = 0xffffffffffff8000LL;
  result >>= shift;
  if (result > 0x7fff)
    {
      result = 0x7fff;
      DSPCR |= DSPCR_OUFLAG7;
    }
  else if (result < value)
    {
      result = value;
      DSPCR |= DSPCR_OUFLAG7;
    }
  GPR[rt] = EXTEND32 (result);
}
#line 2032 "support.c"

INLINE_SUPPORT\
(void)
do_extp
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int ac, int size, int op)
{
#line 1546 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/dsp.igen"
  signed32 pos = (DSPCR >> DSPCR_POS_SHIFT) & DSPCR_POS_MASK;
  unsigned32 lo = DSPLO(ac);
  unsigned32 hi = DSPHI(ac);
  unsigned64 prod = (((unsigned64)hi) << 32) + (unsigned64)lo;
  unsigned64 result = 0;
  if (pos - (size + 1) >= -1)
    {
      prod >>= (pos - size);
      result = prod & (((unsigned64)1 << (size + 1)) - 1);
      DSPCR &= (~DSPCR_EFI_SMASK);
      if (op == 1) // EXTPDP
  	{
  	  if (pos - (size + 1) >= 0)
  	    {
  	      DSPCR &= (~DSPCR_POS_SMASK);
  	      DSPCR |= ((pos - (size + 1)) & DSPCR_POS_MASK) << DSPCR_POS_SHIFT;
  	    }
  	  else if (pos - (size + 1) == -1)
  	    {
  	      DSPCR |= DSPCR_POS_SMASK;
  	    }
  	}
    }
  else
    {
      DSPCR |= DSPCR_EFI;
      Unpredictable ();
    }
  GPR[rt] = EXTEND32 (result);
}
#line 2070 "support.c"

INLINE_SUPPORT\
(void)
do_shilo
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int ac, int shift)
{
#line 1609 "/opt/smp86xx/smp86xx_toolchain_2.8.2.0/toolchain_build_mipsel_nofpu/gdb-6.5/sim/mips/dsp.igen"
  unsigned32 lo = DSPLO(ac);
  unsigned32 hi = DSPHI(ac);
  unsigned64 prod = (((unsigned64)hi) << 32) + (unsigned64)lo;
  if (shift > 31)
    shift = shift - 64;
  if (shift >= 0)
    prod >>= shift;
  else
    prod <<= (-shift);
  DSPLO(ac) = EXTEND32 (prod);
  DSPHI(ac) = EXTEND32 (prod >> 32);
}
#line 2090 "support.c"


#endif /* _SUPPORT_C_*/
