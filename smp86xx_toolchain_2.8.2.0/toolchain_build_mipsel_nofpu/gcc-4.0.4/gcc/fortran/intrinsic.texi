@ignore
Copyright (C) 2005
Free Software Foundation, Inc.
This is part of the GFORTRAN manual.   
For copying conditions, see the file gfortran.texi.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with the
Invariant Sections being ``GNU General Public License'' and ``Funding
Free Software'', the Front-Cover texts being (a) (see below), and with
the Back-Cover Texts being (b) (see below).  A copy of the license is
included in the gfdl(7) man page.


Some basic guidelines for editing this document:

  (1) The intrinsic procedures are to be listed in alphabetical order.
  (2) The generic name is to be use.
  (3) The specific names are included in the function index and in a
      table at the end of the node (See ABS entry).
  (4) Try to maintain the same style for each entry.


@end ignore

@node Intrinsic Procedures
@chapter Intrinsic Procedures
@cindex Intrinsic Procedures

This portion of the document is incomplete and undergoing massive expansion 
and editing.  All contributions and corrections are strongly encouraged. 

@menu
* Introduction:         Introduction
* @code{ABORT}:         ABORT,     Abort the program     
* @code{ABS}:           ABS,       Absolute value     
* @code{ACHAR}:         ACHAR,     Character in @acronym{ASCII} collating sequence
* @code{ACOS}:          ACOS,      Arc cosine function
* @code{ADJUSTL}:       ADJUSTL,   Left adjust a string
* @code{ADJUSTR}:       ADJUSTR,   Right adjust a string
* @code{AIMAG}:         AIMAG,     Imaginary part of complex number
* @code{AINT}:          AINT,      Truncate to a whole number
* @code{ALL}:           ALL,       Determine if all values are true
* @code{ALLOCATED}:     ALLOCATED, Status of allocatable entity
* @code{ANINT}:         ANINT,     Nearest whole number
* @code{ANY}:           ANY,       Determine if any values are true
* @code{ASIN}:          ASIN,      Arcsine function
* @code{ASSOCIATED}:    ASSOCIATED, Status of a pointer or pointer/target pair
* @code{ATAN}:          ATAN,      Arctangent function
* @code{ATAN2}:         ATAN2,     Arctangent function
* @code{BESJ0}:         BESJ0,     Bessel function of the first kind of order 0
* @code{BESJ1}:         BESJ1,     Bessel function of the first kind of order 1
* @code{BESJN}:         BESJN,     Bessel function of the first kind
* @code{BESY0}:         BESY0,     Bessel function of the second kind of order 0
* @code{BESY1}:         BESY1,     Bessel function of the second kind of order 1
* @code{BESYN}:         BESYN,     Bessel function of the second kind
* @code{BIT_SIZE}:      BIT_SIZE,  Bit size inquiry function
* @code{BTEST}:         BTEST,     Bit test function
* @code{CEILING}:       CEILING,   Integer ceiling function
* @code{CHAR}:          CHAR,      Character conversion function
* @code{CMPLX}:         CMPLX,     Complex conversion function
* @code{COMMAND_ARGUMENT_COUNT}: COMMAND_ARGUMENT_COUNT,  Command line argument count
* @code{CONJG}:         CONJG,     Complex conjugate function
* @code{COS}:           COS,       Cosine function
* @code{COSH}:          COSH,      Hyperbolic cosine function
* @code{COUNT}:         COUNT,     Count occurrences of .TRUE. in an array
* @code{CPU_TIME}:      CPU_TIME,  CPU time subroutine
* @code{CSHIFT}:        CSHIFT,    Circular array shift function
* @code{CTIME}:         CTIME,     Subroutine (or function) to convert a time into a string
* @code{DATE_AND_TIME}: DATE_AND_TIME, Date and time subroutine
* @code{DBLE}:          DBLE,      Double precision conversion function
* @code{DCMPLX}:        DCMPLX,    Double complex conversion function
* @code{DFLOAT}:        DFLOAT,    Double precision conversion function
* @code{DIGITS}:        DIGITS,    Significant digits function
* @code{DIM}:           DIM,       Dim function
* @code{DOT_PRODUCT}:   DOT_PRODUCT, Dot product function
* @code{DPROD}:         DPROD,     Double product function
* @code{DREAL}:         DREAL,     Double real part function
* @code{DTIME}:         DTIME,     Execution time subroutine (or function)
* @code{EOSHIFT}:       EOSHIFT,   End-off shift function
* @code{EPSILON}:       EPSILON,   Epsilon function
* @code{ERF}:           ERF,       Error function
* @code{ERFC}:          ERFC,      Complementary error function
* @code{ETIME}:         ETIME,     Execution time subroutine (or function)
* @code{EXIT}:          EXIT,      Exit the program with status.
* @code{EXP}:           EXP,       Exponential function
* @code{EXPONENT}:      EXPONENT,  Exponent function
* @code{FDATE}:         FDATE,     Subroutine (or function) to get the current time as a string
* @code{FLOOR}:         FLOOR,     Integer floor function
* @code{FNUM}:          FNUM,      File number function
* @code{LOG}:           LOG,       Logarithm function
* @code{LOG10}:         LOG10,     Base 10 logarithm function 
* @code{SECNDS}:        SECNDS,    Time function
* @code{SQRT}:          SQRT,      Square-root function
* @code{SIN}:           SIN,       Sine function
* @code{SINH}:          SINH,      Hyperbolic sine function
* @code{TAN}:           TAN,       Tangent function
* @code{TANH}:          TANH,      Hyperbolic tangent function
@end menu

@node Introduction
@section Introduction to intrinsic procedures

Gfortran provides a rich set of intrinsic procedures that includes all
the intrinsic procedures required by the Fortran 95 standard, a set of
intrinsic procedures for backwards compatibility with Gnu Fortran 77
(i.e., @command{g77}), and a small selection of intrinsic procedures
from the Fortran 2003 standard.  Any description here, which conflicts with a 
description in either the Fortran 95 standard or the Fortran 2003 standard,
is unintentional and the standard(s) should be considered authoritative.

The enumeration of the @code{KIND} type parameter is processor defined in
the Fortran 95 standard.  Gfortran defines the default integer type and
default real type by @code{INTEGER(KIND=4)} and @code{REAL(KIND=4)},
respectively.  The standard mandates that both data types shall have
another kind, which have more precision.  On typical target architectures
supported by @command{gfortran}, this kind type parameter is @code{KIND=8}.
Hence, @code{REAL(KIND=8)} and @code{DOUBLE PRECISION} are equivalent.
In the description of generic intrinsic procedures, the kind type parameter
will be specified by @code{KIND=*}, and in the description of specific
names for an intrinsic procedure the kind type parameter will be explicitly
given (e.g., @code{REAL(KIND=4)} or @code{REAL(KIND=8)}).  Finally, for
brevity the optional @code{KIND=} syntax will be omitted.

Many of the intrinsics procedures take one or more optional arguments.
This document follows the convention used in the Fortran 95 standard,
and denotes such arguments by square brackets.

@command{Gfortran} offers the @option{-std=f95} and @option{-std=gnu} options,
which can be used to restrict the set of intrinsic procedures to a 
given standard.  By default, @command{gfortran} sets the @option{-std=gnu}
option, and so all intrinsic procedures described here are accepted.  There
is one caveat.  For a select group of intrinsic procedures, @command{g77}
implemented both a function and a subroutine.  Both classes 
have been implemented in @command{gfortran} for backwards compatibility
with @command{g77}.  It is noted here that these functions and subroutines
cannot be intermixed in a given subprogram.  In the descriptions that follow,
the applicable option(s) is noted.



@node ABORT
@section @code{ABORT} --- Abort the program  
@findex @code{ABORT}
@cindex abort

@table @asis
@item @emph{Description}:
@code{ABORT} causes immediate termination of the program.  On operating
systems that support a core dump, @code{ABORT} will produce a core dump,
which is suitable for debugging purposes.

@item @emph{Option}:
gnu

@item @emph{Class}:
non-elemental subroutine

@item @emph{Syntax}:
@code{CALL ABORT}

@item @emph{Return value}:
Does not return.

@item @emph{Example}:
@smallexample
program test_abort
  integer :: i = 1, j = 2
  if (i /= j) call abort
end program test_abort
@end smallexample
@end table



@node ABS
@section @code{ABS} --- Absolute value  
@findex @code{ABS} intrinsic
@findex @code{CABS} intrinsic
@findex @code{DABS} intrinsic
@findex @code{IABS} intrinsic
@findex @code{ZABS} intrinsic
@findex @code{CDABS} intrinsic
@cindex absolute value

@table @asis
@item @emph{Description}:
@code{ABS(X)} computes the absolute value of @code{X}.

@item @emph{Option}:
f95, gnu

@item @emph{Class}:
elemental function

@item @emph{Syntax}:
@code{X = ABS(X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type of the argument shall be an @code{INTEGER(*)},
@code{REAL(*)}, or @code{COMPLEX(*)}.
@end multitable

@item @emph{Return value}:
The return value is of the same type and
kind as the argument except the return value is @code{REAL(*)} for a
@code{COMPLEX(*)} argument.

@item @emph{Example}:
@smallexample
program test_abs
  integer :: i = -1
  real :: x = -1.e0
  complex :: z = (-1.e0,0.e0)
  i = abs(i)
  x = abs(x)
  x = abs(z)
end program test_abs
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name            @tab Argument            @tab Return type       @tab Option
@item @code{CABS(Z)}  @tab @code{COMPLEX(4) Z} @tab @code{REAL(4)}    @tab f95, gnu
@item @code{DABS(X)}  @tab @code{REAL(8)    X} @tab @code{REAL(8)}    @tab f95, gnu
@item @code{IABS(I)}  @tab @code{INTEGER(4) I} @tab @code{INTEGER(4)} @tab f95, gnu
@item @code{ZABS(Z)}  @tab @code{COMPLEX(8) Z} @tab @code{COMPLEX(8)} @tab gnu
@item @code{CDABS(Z)} @tab @code{COMPLEX(8) Z} @tab @code{COMPLEX(8)} @tab gnu
@end multitable
@end table



@node ACHAR
@section @code{ACHAR} --- Character in @acronym{ASCII} collating sequence 
@findex @code{ACHAR} intrinsic
@cindex @acronym{ASCII} collating sequence

@table @asis
@item @emph{Description}:
@code{ACHAR(I)} returns the character located at position @code{I}
in the @acronym{ASCII} collating sequence.

@item @emph{Option}:
f95, gnu

@item @emph{Class}:
elemental function

@item @emph{Syntax}:
@code{C = ACHAR(I)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{I} @tab The type shall be @code{INTEGER(*)}.
@end multitable

@item @emph{Return value}:
The return value is of type @code{CHARACTER} with a length of one.  The
kind type parameter is the same as  @code{KIND('A')}.

@item @emph{Example}:
@smallexample
program test_achar
  character c
  c = achar(32)
end program test_achar
@end smallexample
@end table



@node ACOS
@section @code{ACOS} --- Arc cosine function 
@findex @code{ACOS} intrinsic
@findex @code{DACOS} intrinsic
@cindex arc cosine

@table @asis
@item @emph{Description}:
@code{ACOS(X)} computes the arc cosine of @var{X}.

@item @emph{Option}:
f95, gnu

@item @emph{Class}:
elemental function

@item @emph{Syntax}:
@code{X = ACOS(X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type shall be @code{REAL(*)} with a magnitude that is
less than one.
@end multitable

@item @emph{Return value}:
The return value is of type @code{REAL(*)} and it lies in the
range @math{ 0 \leq \arccos (x) \leq \pi}.  The kind type
parameter is the same as @var{X}.

@item @emph{Example}:
@smallexample
program test_acos
  real(8) :: x = 0.866_8
  x = achar(x)
end program test_acos
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name            @tab Argument          @tab Return type       @tab Option
@item @code{DACOS(X)} @tab @code{REAL(8) X}  @tab @code{REAL(8)}    @tab f95, gnu
@end multitable
@end table



@node ADJUSTL
@section @code{ADJUSTL} --- Left adjust a string 
@findex @code{ADJUSTL} intrinsic
@cindex adjust string

@table @asis
@item @emph{Description}:
@code{ADJUSTL(STR)} will left adjust a string by removing leading spaces.
Spaces are inserted at the end of the string as needed.

@item @emph{Option}:
f95, gnu

@item @emph{Class}:
elemental function

@item @emph{Syntax}:
@code{STR = ADJUSTL(STR)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{STR} @tab The type shall be @code{CHARACTER}.
@end multitable

@item @emph{Return value}:
The return value is of type @code{CHARACTER} where leading spaces 
are removed and the same number of spaces are inserted on the end
of @var{STR}.

@item @emph{Example}:
@smallexample
program test_adjustl
  character(len=20) :: str = '   gfortran'
  str = adjustl(str)
  print *, str
end program test_adjustl
@end smallexample
@end table



@node ADJUSTR
@section @code{ADJUSTR} --- Right adjust a string 
@findex @code{ADJUSTR} intrinsic
@cindex adjust string

@table @asis
@item @emph{Description}:
@code{ADJUSTR(STR)} will right adjust a string by removing trailing spaces.
Spaces are inserted at the start of the string as needed.

@item @emph{Option}:
f95, gnu

@item @emph{Class}:
elemental function

@item @emph{Syntax}:
@code{STR = ADJUSTR(STR)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{STR} @tab The type shall be @code{CHARACTER}.
@end multitable

@item @emph{Return value}:
The return value is of type @code{CHARACTER} where trailing spaces 
are removed and the same number of spaces are inserted at the start
of @var{STR}.

@item @emph{Example}:
@smallexample
program test_adjustr
  character(len=20) :: str = 'gfortran'
  str = adjustr(str)
  print *, str
end program test_adjustr
@end smallexample
@end table



@node AIMAG
@section @code{AIMAG} --- Imaginary part of complex number  
@findex @code{AIMAG} intrinsic
@findex @code{DIMAG} intrinsic
@cindex Imaginary part

@table @asis
@item @emph{Description}:
@code{AIMAG(Z)} yields the imaginary part of complex argument @code{Z}.

@item @emph{Option}:
f95, gnu

@item @emph{Class}:
elemental function

@item @emph{Syntax}:
@code{X = AIMAG(Z)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{Z} @tab The type of the argument shall be @code{COMPLEX(*)}.
@end multitable

@item @emph{Return value}:
The return value is of type real with the
kind type parameter of the argument.

@item @emph{Example}:
@smallexample
program test_aimag
  complex(4) z4
  complex(8) z8
  z4 = cmplx(1.e0_4, 0.e0_4)
  z8 = cmplx(0.e0_8, 1.e0_8)
  print *, aimag(z4), dimag(z8)
end program test_aimag
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name            @tab Argument            @tab Return type       @tab Option
@item @code{DIMAG(Z)} @tab @code{COMPLEX(8) Z} @tab @code{REAL(8)}    @tab f95, gnu
@end multitable
@end table



@node AINT
@section @code{AINT} --- Imaginary part of complex number  
@findex @code{AINT} intrinsic
@findex @code{DINT} intrinsic
@cindex whole number

@table @asis
@item @emph{Description}:
@code{AINT(X [, KIND])} truncates its argument to a whole number.

@item @emph{Option}:
f95, gnu

@item @emph{Class}:
elemental function

@item @emph{Syntax}:
@code{X = AINT(X)} 
@code{X = AINT(X, KIND)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X}    @tab The type of the argument shall be @code{REAL(*)}.
@item @var{KIND} @tab (Optional) @var{KIND} shall be a scalar integer
initialization expression.
@end multitable

@item @emph{Return value}:
The return value is of type real with the kind type parameter of the
argument if the optional @var{KIND} is absent; otherwise, the kind
type parameter will be given by @var{KIND}.  If the magnitude of 
@var{X} is less than one, then @code{AINT(X)} returns zero.  If the
magnitude is equal to or greater than one, then it returns the largest
whole number that does not exceed its magnitude.  The sign is the same
as the sign of @var{X}. 

@item @emph{Example}:
@smallexample
program test_aint
  real(4) x4
  real(8) x8
  x4 = 1.234E0_4
  x8 = 4.321_8
  print *, aint(x4), dint(x8)
  x8 = aint(x4,8)
end program test_aint
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name           @tab Argument         @tab Return type      @tab Option
@item @code{DINT(X)} @tab @code{REAL(8) X} @tab @code{REAL(8)}   @tab f95, gnu
@end multitable
@end table



@node ALL
@section @code{ALL} --- All values in @var{MASK} along @var{DIM} are true 
@findex @code{ALL} intrinsic
@cindex true values

@table @asis
@item @emph{Description}:
@code{ALL(MASK [, DIM])} determines if all the values are true in @var{MASK}
in the array along dimension @var{DIM}.

@item @emph{Option}:
f95, gnu

@item @emph{Class}:
transformational function

@item @emph{Syntax}:
@code{L = ALL(MASK)} 
@code{L = ALL(MASK, DIM)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{MASK} @tab The type of the argument shall be @code{LOGICAL(*)} and
it shall not be scalar.
@item @var{DIM}  @tab (Optional) @var{DIM} shall be a scalar integer
with a value that lies between one and the rank of @var{MASK}.
@end multitable

@item @emph{Return value}:
@code{ALL(MASK)} returns a scalar value of type @code{LOGICAL(*)} where
the kind type parameter is the same as the kind type parameter of
@var{MASK}.  If @var{DIM} is present, then @code{ALL(MASK, DIM)} returns
an array with the rank of @var{MASK} minus 1.  The shape is determined from
the shape of @var{MASK} where the @var{DIM} dimension is elided. 

@table @asis
@item (A)
@code{ALL(MASK)} is true if all elements of @var{MASK} are true.
It also is true if @var{MASK} has zero size; otherwise, it is false.
@item (B)
If the rank of @var{MASK} is one, then @code{ALL(MASK,DIM)} is equivalent
to @code{ALL(MASK)}.  If the rank is greater than one, then @code{ALL(MASK,DIM)}
is determined by applying @code{ALL} to the array sections.
@end table

@item @emph{Example}:
@smallexample
program test_all
  logical l
  l = all((/.true., .true., .true./))
  print *, l
  call section
  contains
    subroutine section
      integer a(2,3), b(2,3)
      a = 1
      b = 1
      b(2,2) = 2
      print *, all(a .eq. b, 1)
      print *, all(a .eq. b, 2)
    end subroutine section
end program test_all
@end smallexample
@end table



@node ALLOCATED
@section @code{ALLOCATED} --- Status of an allocatable entity
@findex @code{ALLOCATED} intrinsic
@cindex allocation status

@table @asis
@item @emph{Description}:
@code{ALLOCATED(X)} checks the status of whether @var{X} is allocated.

@item @emph{Option}:
f95, gnu

@item @emph{Class}:
inquiry function

@item @emph{Syntax}:
@code{L = ALLOCATED(X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X}    @tab The argument shall be an @code{ALLOCATABLE} array.
@end multitable

@item @emph{Return value}:
The return value is a scalar @code{LOGICAL} with the default logical
kind type parameter.  If @var{X} is allocated, @code{ALLOCATED(X)}
is @code{.TRUE.}; otherwise, it returns the @code{.TRUE.} 

@item @emph{Example}:
@smallexample
program test_allocated
  integer :: i = 4
  real(4), allocatable :: x(:)
  if (allocated(x) .eqv. .false.) allocate(x(i)
end program test_allocated
@end smallexample
@end table



@node ANINT
@section @code{ANINT} --- Imaginary part of complex number  
@findex @code{ANINT} intrinsic
@findex @code{DNINT} intrinsic
@cindex whole number

@table @asis
@item @emph{Description}:
@code{ANINT(X [, KIND])} rounds its argument to the nearest whole number.

@item @emph{Option}:
f95, gnu

@item @emph{Class}:
elemental function

@item @emph{Syntax}:
@code{X = ANINT(X)}
@code{X = ANINT(X, KIND)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X}    @tab The type of the argument shall be @code{REAL(*)}.
@item @var{KIND} @tab (Optional) @var{KIND} shall be a scalar integer
initialization expression.
@end multitable

@item @emph{Return value}:
The return value is of type real with the kind type parameter of the
argument if the optional @var{KIND} is absent; otherwise, the kind
type parameter will be given by @var{KIND}.  If @var{X} is greater than
zero, then @code{ANINT(X)} returns @code{AINT(X+0.5)}.  If @var{X} is
less than or equal to zero, then return @code{AINT(X-0.5)}.

@item @emph{Example}:
@smallexample
program test_anint
  real(4) x4
  real(8) x8
  x4 = 1.234E0_4
  x8 = 4.321_8
  print *, anint(x4), dnint(x8)
  x8 = anint(x4,8)
end program test_anint
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name            @tab Argument         @tab Return type      @tab Option
@item @code{DNINT(X)} @tab @code{REAL(8) X} @tab @code{REAL(8)}   @tab f95, gnu
@end multitable
@end table



@node ANY
@section @code{ANY} --- Any value in @var{MASK} along @var{DIM} is true 
@findex @code{ANY} intrinsic
@cindex true values

@table @asis
@item @emph{Description}:
@code{ANY(MASK [, DIM])} determines if any of the values in the logical array
@var{MASK} along dimension @var{DIM} are @code{.TRUE.}.

@item @emph{Option}:
f95, gnu

@item @emph{Class}:
transformational function

@item @emph{Syntax}:
@code{L = ANY(MASK)} 
@code{L = ANY(MASK, DIM)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{MASK} @tab The type of the argument shall be @code{LOGICAL(*)} and
it shall not be scalar.
@item @var{DIM}  @tab (Optional) @var{DIM} shall be a scalar integer
with a value that lies between one and the rank of @var{MASK}.
@end multitable

@item @emph{Return value}:
@code{ANY(MASK)} returns a scalar value of type @code{LOGICAL(*)} where
the kind type parameter is the same as the kind type parameter of
@var{MASK}.  If @var{DIM} is present, then @code{ANY(MASK, DIM)} returns
an array with the rank of @var{MASK} minus 1.  The shape is determined from
the shape of @var{MASK} where the @var{DIM} dimension is elided. 

@table @asis
@item (A)
@code{ANY(MASK)} is true if any element of @var{MASK} is true;
otherwise, it is false.  It also is false if @var{MASK} has zero size.
@item (B)
If the rank of @var{MASK} is one, then @code{ANY(MASK,DIM)} is equivalent
to @code{ANY(MASK)}.  If the rank is greater than one, then @code{ANY(MASK,DIM)}
is determined by applying @code{ANY} to the array sections.
@end table

@item @emph{Example}:
@smallexample
program test_any
  logical l
  l = any((/.true., .true., .true./))
  print *, l
  call section
  contains
    subroutine section
      integer a(2,3), b(2,3)
      a = 1
      b = 1
      b(2,2) = 2
      print *, any(a .eq. b, 1)
      print *, any(a .eq. b, 2)
    end subroutine section
end program test_any
@end smallexample
@end table



@node ASIN
@section @code{ASIN} --- Arcsine function 
@findex @code{ASIN} intrinsic
@findex @code{DASIN} intrinsic
@cindex arcsine

@table @asis
@item @emph{Description}:
@code{ASIN(X)} computes the arcsine of its @var{X}.

@item @emph{Option}:
f95, gnu

@item @emph{Class}:
elemental function

@item @emph{Syntax}:
@code{X = ASIN(X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type shall be @code{REAL(*)}, and a magnitude that is
less than one.
@end multitable

@item @emph{Return value}:
The return value is of type @code{REAL(*)} and it lies in the
range @math{-\pi / 2 \leq \arccos (x) \leq \pi / 2}.  The kind type
parameter is the same as @var{X}.

@item @emph{Example}:
@smallexample
program test_asin
  real(8) :: x = 0.866_8
  x = asin(x)
end program test_asin
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name            @tab Argument          @tab Return type       @tab Option
@item @code{DASIN(X)} @tab @code{REAL(8) X}  @tab @code{REAL(8)}    @tab f95, gnu
@end multitable
@end table



@node ASSOCIATED
@section @code{ASSOCIATED} --- Status of a pointer or pointer/target pair 
@findex @code{ASSOCIATED} intrinsic
@cindex pointer status

@table @asis
@item @emph{Description}:
@code{ASSOCIATED(PTR [, TGT])} determines the status of the pointer @var{PTR}
or if @var{PTR} is associated with the target @var{TGT}.

@item @emph{Option}:
f95, gnu

@item @emph{Class}:
inquiry function

@item @emph{Syntax}:
@code{L = ASSOCIATED(PTR)} 
@code{L = ASSOCIATED(PTR [, TGT])}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{PTR} @tab @var{PTR} shall have the @code{POINTER} attribute and
it can be of any type.
@item @var{TGT} @tab (Optional) @var{TGT} shall be a @code{POINTER} or
a @code{TARGET}.  It must have the same type, kind type parameter, and
array rank as @var{PTR}.
@end multitable
The status of neither @var{PTR} nor @var{TGT} can be undefined.

@item @emph{Return value}:
@code{ASSOCIATED(PTR)} returns a scalar value of type @code{LOGICAL(4)}.
There are several cases:
@table @asis
@item (A) If the optional @var{TGT} is not present, then @code{ASSOCIATED(PTR)}
is true if @var{PTR} is associated with a target; otherwise, it returns false.
@item (B) If @var{TGT} is present and a scalar target, the result is true if
@var{TGT}
is not a 0 sized storage sequence and the target associated with @var{PTR}
occupies the same storage units.  If @var{PTR} is disassociated, then the 
result is false.
@item (C) If @var{TGT} is present and an array target, the result is true if
@var{TGT} and @var{PTR} have the same shape, are not 0 sized arrays, are
arrays whose elements are not 0 sized storage sequences, and @var{TGT} and
@var{PTR} occupy the same storage units in array element order.
As in case(B), the result is false, if @var{PTR} is disassociated.
@item (D) If @var{TGT} is present and an scalar pointer, the result is true if
target associated with @var{PTR} and the target associated with @var{TGT}
are not 0 sized storage sequences and occupy the same storage units.
The result is false, if either @var{TGT} or @var{PTR} is disassociated.
@item (E) If @var{TGT} is present and an array pointer, the result is true if
target associated with @var{PTR} and the target associated with @var{TGT}
have the same shape, are not 0 sized arrays, are arrays whose elements are
not 0 sized storage sequences, and @var{TGT} and @var{PTR} occupy the same
storage units in array element order.
The result is false, if either @var{TGT} or @var{PTR} is disassociated.
@end table

@item @emph{Example}:
@smallexample
program test_associated
   implicit none
   real, target  :: tgt(2) = (/1., 2./)
   real, pointer :: ptr(:)
   ptr => tgt
   if (associated(ptr)     .eqv. .false.) call abort
   if (associated(ptr,tgt) .eqv. .false.) call abort
end program test_associated
@end smallexample
@end table



@node ATAN
@section @code{ATAN} --- Arctangent function 
@findex @code{ATAN} intrinsic
@findex @code{DATAN} intrinsic
@cindex arctangent

@table @asis
@item @emph{Description}:
@code{ATAN(X)} computes the arctangent of @var{X}.

@item @emph{Option}:
f95, gnu

@item @emph{Class}:
elemental function

@item @emph{Syntax}:
@code{X = ATAN(X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type shall be @code{REAL(*)}.
@end multitable

@item @emph{Return value}:
The return value is of type @code{REAL(*)} and it lies in the
range @math{ - \pi / 2 \leq \arcsin (x) \leq \pi / 2}.

@item @emph{Example}:
@smallexample
program test_atan
  real(8) :: x = 2.866_8
  x = atan(x)
end program test_atan
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name            @tab Argument          @tab Return type       @tab Option
@item @code{DATAN(X)} @tab @code{REAL(8) X}  @tab @code{REAL(8)}    @tab f95, gnu
@end multitable
@end table



@node ATAN2
@section @code{ATAN2} --- Arctangent function 
@findex @code{ATAN2} intrinsic
@findex @code{DATAN2} intrinsic
@cindex arctangent

@table @asis
@item @emph{Description}:
@code{ATAN2(Y,X)} computes the arctangent of the complex number @math{X + i Y}.

@item @emph{Option}:
f95, gnu

@item @emph{Class}:
elemental function

@item @emph{Syntax}:
@code{X = ATAN2(Y,X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{Y} @tab The type shall be @code{REAL(*)}.
@item @var{X} @tab The type and kind type parameter shall be the same as @var{Y}.
If @var{Y} is zero, then @var{X} must be nonzero.
@end multitable

@item @emph{Return value}:
The return value has the same type and kind type parameter as @var{Y}.
It is the principle value of the complex number @math{X + i Y}.  If
@var{X} is nonzero, then it lies in the range @math{-\pi \le \arccos (x) \leq \pi}.
The sign is positive if @var{Y} is positive.  If @var{Y} is zero, then
the return value is zero if @var{X} is positive and @math{\pi} if @var{X}
is negative.  Finally, if @var{X} is zero, then the magnitude of the result
is @math{\pi/2}.

@item @emph{Example}:
@smallexample
program test_atan2
  real(4) :: x = 1.e0_4, y = 0.5e0_4
  x = atan2(y,x)
end program test_atan2
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name            @tab Argument          @tab Return type    @tab Option
@item @code{DATAN2(X)} @tab @code{REAL(8) X} @tab @code{REAL(8)} @tab f95, gnu
@end multitable
@end table



@node BESJ0
@section @code{BESJ0} --- Bessel function of the first kind of order 0
@findex @code{BESJ0} intrinsic
@findex @code{DBESJ0} intrinsic
@cindex Bessel

@table @asis
@item @emph{Description}:
@code{BESJ0(X)} computes the Bessel function of the first kind of order 0
of @var{X}.

@item @emph{Option}:
gnu

@item @emph{Class}:
elemental function

@item @emph{Syntax}:
@code{X = BESJ0(X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type shall be @code{REAL(*)}, and it shall be scalar.
@end multitable

@item @emph{Return value}:
The return value is of type @code{REAL(*)} and it lies in the
range @math{ - 0.4027... \leq Bessel (0,x) \leq 1}.

@item @emph{Example}:
@smallexample
program test_besj0
  real(8) :: x = 0.0_8
  x = besj0(x)
end program test_besj0
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name            @tab Argument          @tab Return type       @tab Option
@item @code{DBESJ0(X)} @tab @code{REAL(8) X}  @tab @code{REAL(8)}    @tab gnu
@end multitable
@end table



@node BESJ1
@section @code{BESJ1} --- Bessel function of the first kind of order 1
@findex @code{BESJ1} intrinsic
@findex @code{DBESJ1} intrinsic
@cindex Bessel

@table @asis
@item @emph{Description}:
@code{BESJ1(X)} computes the Bessel function of the first kind of order 1
of @var{X}.

@item @emph{Option}:
gnu

@item @emph{Class}:
elemental function

@item @emph{Syntax}:
@code{X = BESJ1(X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type shall be @code{REAL(*)}, and it shall be scalar.
@end multitable

@item @emph{Return value}:
The return value is of type @code{REAL(*)} and it lies in the
range @math{ - 0.5818... \leq Bessel (0,x) \leq 0.5818 }.

@item @emph{Example}:
@smallexample
program test_besj1
  real(8) :: x = 1.0_8
  x = besj1(x)
end program test_besj1
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name            @tab Argument          @tab Return type       @tab Option
@item @code{DBESJ1(X)}@tab @code{REAL(8) X}  @tab @code{REAL(8)}    @tab gnu
@end multitable
@end table



@node BESJN
@section @code{BESJN} --- Bessel function of the first kind
@findex @code{BESJN} intrinsic
@findex @code{DBESJN} intrinsic
@cindex Bessel

@table @asis
@item @emph{Description}:
@code{BESJN(N, X)} computes the Bessel function of the first kind of order
@var{N} of @var{X}.

@item @emph{Option}:
gnu

@item @emph{Class}:
elemental function

@item @emph{Syntax}:
@code{Y = BESJN(N, X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{N} @tab The type shall be @code{INTEGER(*)}, and it shall be scalar.
@item @var{X} @tab The type shall be @code{REAL(*)}, and it shall be scalar.
@end multitable

@item @emph{Return value}:
The return value is a scalar of type @code{REAL(*)}.

@item @emph{Example}:
@smallexample
program test_besjn
  real(8) :: x = 1.0_8
  x = besjn(5,x)
end program test_besjn
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name             @tab Argument            @tab Return type       @tab Option
@item @code{DBESJN(X)} @tab @code{INTEGER(*) N} @tab @code{REAL(8)}    @tab gnu
@item                  @tab @code{REAL(8) X}    @tab                   @tab
@end multitable
@end table



@node BESY0
@section @code{BESY0} --- Bessel function of the second kind of order 0
@findex @code{BESY0} intrinsic
@findex @code{DBESY0} intrinsic
@cindex Bessel

@table @asis
@item @emph{Description}:
@code{BESY0(X)} computes the Bessel function of the second kind of order 0
of @var{X}.

@item @emph{Option}:
gnu

@item @emph{Class}:
elemental function

@item @emph{Syntax}:
@code{X = BESY0(X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type shall be @code{REAL(*)}, and it shall be scalar.
@end multitable

@item @emph{Return value}:
The return value is a scalar of type @code{REAL(*)}.

@item @emph{Example}:
@smallexample
program test_besy0
  real(8) :: x = 0.0_8
  x = besy0(x)
end program test_besy0
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name            @tab Argument          @tab Return type       @tab Option
@item @code{DBESY0(X)}@tab @code{REAL(8) X}  @tab @code{REAL(8)}    @tab gnu
@end multitable
@end table



@node BESY1
@section @code{BESY1} --- Bessel function of the second kind of order 1
@findex @code{BESY1} intrinsic
@findex @code{DBESY1} intrinsic
@cindex Bessel

@table @asis
@item @emph{Description}:
@code{BESY1(X)} computes the Bessel function of the second kind of order 1
of @var{X}.

@item @emph{Option}:
gnu

@item @emph{Class}:
elemental function

@item @emph{Syntax}:
@code{X = BESY1(X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type shall be @code{REAL(*)}, and it shall be scalar.
@end multitable

@item @emph{Return value}:
The return value is a scalar of type @code{REAL(*)}.

@item @emph{Example}:
@smallexample
program test_besy1
  real(8) :: x = 1.0_8
  x = besy1(x)
end program test_besy1
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name            @tab Argument          @tab Return type       @tab Option
@item @code{DBESY1(X)}@tab @code{REAL(8) X}  @tab @code{REAL(8)}    @tab gnu
@end multitable
@end table



@node BESYN
@section @code{BESYN} --- Bessel function of the second kind
@findex @code{BESYN} intrinsic
@findex @code{DBESYN} intrinsic
@cindex Bessel

@table @asis
@item @emph{Description}:
@code{BESYN(N, X)} computes the Bessel function of the second kind of order
@var{N} of @var{X}.

@item @emph{Option}:
gnu

@item @emph{Class}:
elemental function

@item @emph{Syntax}:
@code{Y = BESYN(N, X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{N} @tab The type shall be @code{INTEGER(*)}, and it shall be scalar.
@item @var{X} @tab The type shall be @code{REAL(*)}, and it shall be scalar.
@end multitable

@item @emph{Return value}:
The return value is a scalar of type @code{REAL(*)}.

@item @emph{Example}:
@smallexample
program test_besyn
  real(8) :: x = 1.0_8
  x = besyn(5,x)
end program test_besyn
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name               @tab Argument            @tab Return type     @tab Option
@item @code{DBESYN(N,X)} @tab @code{INTEGER(*) N} @tab @code{REAL(8)}  @tab gnu
@item                    @tab @code{REAL(8)    X} @tab                 @tab 
@end multitable
@end table



@node BIT_SIZE
@section @code{BIT_SIZE} --- Bit size inquiry function
@findex @code{BIT_SIZE} intrinsic
@cindex bit_size

@table @asis
@item @emph{Description}:
@code{BIT_SIZE(I)} returns the number of bits (integer precision plus sign bit)
represented by the type of @var{I}.

@item @emph{Option}:
f95, gnu

@item @emph{Class}:
elemental function

@item @emph{Syntax}:
@code{I = BIT_SIZE(I)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{I} @tab The type shall be @code{INTEGER(*)}.
@end multitable

@item @emph{Return value}:
The return value is of type @code{INTEGER(*)}

@item @emph{Example}:
@smallexample
program test_bit_size
    integer :: i = 123
    integer :: size
    size = bit_size(i)
    print *, size
end program test_bit_size
@end smallexample
@end table



@node BTEST
@section @code{BTEST} --- Bit test function
@findex @code{BTEST} intrinsic
@cindex BTEST

@table @asis
@item @emph{Description}:
@code{BTEST(I,POS)} returns logical @code{.TRUE.} if the bit at @var{POS}
in @var{I} is set.

@item @emph{Option}:
f95, gnu

@item @emph{Class}:
elemental function

@item @emph{Syntax}:
@code{I = BTEST(I,POS)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{I} @tab The type shall be @code{INTEGER(*)}.
@item @var{POS} @tab The type shall be @code{INTEGER(*)}.
@end multitable

@item @emph{Return value}:
The return value is of type @code{LOGICAL}

@item @emph{Example}:
@smallexample
program test_btest
    integer :: i = 32768 + 1024 + 64
    integer :: pos
    logical :: bool
    do pos=0,16
        bool = btest(i, pos) 
        print *, pos, bool
    end do
end program test_btest
@end smallexample
@end table



@node CEILING
@section @code{CEILING} --- Integer ceiling function
@findex @code{CEILING} intrinsic
@cindex CEILING

@table @asis
@item @emph{Description}:
@code{CEILING(X)} returns the least integer greater than or equal to @var{X}.

@item @emph{Option}:
f95, gnu

@item @emph{Class}:
elemental function

@item @emph{Syntax}:
@code{I = CEILING(X[,KIND])}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type shall be @code{REAL(*)}.
@item @var{KIND} @tab Optional scaler integer initialization expression.
@end multitable

@item @emph{Return value}:
The return value is of type @code{INTEGER(KIND)}

@item @emph{Example}:
@smallexample
program test_ceiling
    real :: x = 63.29
    real :: y = -63.59
    print *, ceiling(x) ! returns 64
    print *, ceiling(y) ! returns -63
end program test_ceiling
@end smallexample
@end table



@node CHAR
@section @code{CHAR} --- Character conversion function
@findex @code{CHAR} intrinsic
@cindex CHAR

@table @asis
@item @emph{Description}:
@code{CHAR(I,[KIND])} returns the character represented by the integer @var{I}.

@item @emph{Option}:
f95, gnu

@item @emph{Class}:
elemental function

@item @emph{Syntax}:
@code{C = CHAR(I[,KIND])}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{I} @tab The type shall be @code{INTEGER(*)}.
@item @var{KIND} @tab Optional scaler integer initialization expression.
@end multitable

@item @emph{Return value}:
The return value is of type @code{CHARACTER(1)}

@item @emph{Example}:
@smallexample
program test_char
    integer :: i = 74
    character(1) :: c
    c = char(i)
    print *, i, c ! returns 'J'
end program test_char
@end smallexample
@end table



@node CMPLX
@section @code{CMPLX} --- Complex conversion function
@findex @code{CMPLX} intrinsic
@cindex CMPLX

@table @asis
@item @emph{Description}:
@code{CMPLX(X,[Y,KIND])} returns a complex number where @var{X} is converted to
the real component.  If @var{Y} is present it is converted to the imaginary
component.  If @var{Y} is not present then the imaginary component is set to
0.0.  If @var{X} is complex then @var{Y} must not be present.

@item @emph{Option}:
f95, gnu

@item @emph{Class}:
elemental function

@item @emph{Syntax}:
@code{C = CMPLX(X[,Y,KIND])}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type may be @code{INTEGER(*)}, @code{REAL(*)}, or @code{COMPLEX(*)}.
@item @var{Y} @tab Optional, allowed if @var{X} is not @code{COMPLEX(*)}.  May be @code{INTEGER(*)} or @code{REAL(*)}. 
@item @var{KIND} @tab Optional scaler integer initialization expression.
@end multitable

@item @emph{Return value}:
The return value is of type @code{COMPLEX(*)}

@item @emph{Example}:
@smallexample
program test_cmplx
    integer :: i = 42
    real :: x = 3.14
    complex :: z
    z = cmplx(i, x)
    print *, z, cmplx(x)
end program test_cmplx
@end smallexample
@end table



@node COMMAND_ARGUMENT_COUNT
@section @code{COMMAND_ARGUMENT_COUNT} --- Argument count function 
@findex @code{COMMAND_ARGUMENT_COUNT} intrinsic
@cindex command argument count

@table @asis
@item @emph{Description}:
@code{COMMAND_ARGUMENT_COUNT()} returns the number of arguments passed on the
command line when the containing program was invoked.

@item @emph{Option}:
f2003, gnu

@item @emph{Class}:
non-elemental function

@item @emph{Syntax}:
@code{I = COMMAND_ARGUMENT_COUNT()}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item None
@end multitable

@item @emph{Return value}:
The return value is of type @code{INTEGER(4)}

@item @emph{Example}:
@smallexample
program test_command_argument_count
    integer :: count
    count = command_argument_count()
    print *, count
end program test_command_argument_count
@end smallexample
@end table



@node CONJG
@section @code{CONJG} --- Complex conjugate function 
@findex @code{CONJG} intrinsic
@findex @code{DCONJG} intrinsic
@cindex complex conjugate
@table @asis
@item @emph{Description}:
@code{CONJG(Z)} returns the conjugate of @var{Z}.  If @var{Z} is @code{(x, y)}
then the result is @code{(x, -y)}

@item @emph{Option}:
f95, gnu

@item @emph{Class}:
elemental function

@item @emph{Syntax}:
@code{Z = CONJG(Z)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{Z} @tab The type shall be @code{COMPLEX(*)}.
@end multitable

@item @emph{Return value}:
The return value is of type @code{COMPLEX(*)}.

@item @emph{Example}:
@smallexample
program test_conjg
    complex :: z = (2.0, 3.0)
    complex(8) :: dz = (2.71_8, -3.14_8)
    z= conjg(z)
    print *, z
    dz = dconjg(dz)
    print *, dz
end program test_conjg
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name             @tab Argument             @tab Return type          @tab Option
@item @code{DCONJG(Z)} @tab @code{COMPLEX(8) Z}  @tab @code{COMPLEX(8)}    @tab gnu
@end multitable
@end table



@node COS
@section @code{COS} --- Cosine function 
@findex @code{COS} intrinsic
@findex @code{DCOS} intrinsic
@findex @code{ZCOS} intrinsic
@findex @code{CDCOS} intrinsic
@cindex cosine

@table @asis
@item @emph{Description}:
@code{COS(X)} computes the cosine of @var{X}.

@item @emph{Option}:
f95, gnu

@item @emph{Class}:
elemental function

@item @emph{Syntax}:
@code{X = COS(X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type shall be @code{REAL(*)} or
@code{COMPLEX(*)}.
@end multitable

@item @emph{Return value}:
The return value has the same type and kind as @var{X}.

@item @emph{Example}:
@smallexample
program test_cos
  real :: x = 0.0
  x = cos(x)
end program test_cos
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name            @tab Argument          @tab Return type     @tab Option
@item @code{DCOS(X)}  @tab @code{REAL(8) X}  @tab @code{REAL(8)}  @tab f95, gnu
@item @code{CCOS(X)}@tab @code{COMPLEX(4) X}@tab @code{COMPLEX(4)}@tab f95, gnu
@item @code{ZCOS(X)}@tab @code{COMPLEX(8) X}@tab @code{COMPLEX(8)}@tab f95, gnu
@item @code{CDCOS(X)}@tab @code{COMPLEX(8) X}@tab @code{COMPLEX(8)}@tab f95, gnu
@end multitable
@end table



@node COSH
@section @code{COSH} --- Hyperbolic cosine function 
@findex @code{COSH} intrinsic
@findex @code{DCOSH} intrinsic
@cindex hyperbolic cosine

@table @asis
@item @emph{Description}:
@code{COSH(X)} computes the hyperbolic cosine of @var{X}.

@item @emph{Option}:
f95, gnu

@item @emph{Class}:
elemental function

@item @emph{Syntax}:
@code{X = COSH(X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type shall be @code{REAL(*)}.
@end multitable

@item @emph{Return value}:
The return value is of type @code{REAL(*)} and it is positive
(@math{ \cosh (x) \geq 0 }.

@item @emph{Example}:
@smallexample
program test_cosh
  real(8) :: x = 1.0_8
  x = cosh(x)
end program test_cosh
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name            @tab Argument          @tab Return type       @tab Option
@item @code{DCOSH(X)} @tab @code{REAL(8) X}  @tab @code{REAL(8)}    @tab f95, gnu
@end multitable
@end table



@node COUNT
@section @code{COUNT} --- Count function
@findex @code{COUNT} intrinsic
@cindex count

@table @asis
@item @emph{Description}:
@code{COUNT(MASK[,DIM])} counts the number of @code{.TRUE.} elements of
@var{MASK} along the dimension of @var{DIM}.  If @var{DIM} is omitted it is
taken to be @code{1}.  @var{DIM} is a scaler of type @code{INTEGER} in the
range of @math{1 /leq DIM /leq n)} where @math{n} is the rank of @var{MASK}.

@item @emph{Option}:
f95, gnu

@item @emph{Class}:
transformational function

@item @emph{Syntax}:
@code{I = COUNT(MASK[,DIM])}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{MASK} @tab The type shall be @code{LOGICAL}.
@item @var{DIM}  @tab The type shall be @code{INTEGER}.
@end multitable

@item @emph{Return value}:
The return value is of type @code{INTEGER} with rank equal to that of
@var{MASK}.

@item @emph{Example}:
@smallexample
program test_count
    integer, dimension(2,3) :: a, b
    logical, dimension(2,3) :: mask
    a = reshape( (/ 1, 2, 3, 4, 5, 6 /), (/ 2, 3 /))
    b = reshape( (/ 0, 7, 3, 4, 5, 8 /), (/ 2, 3 /))
    print '(3i3)', a(1,:)
    print '(3i3)', a(2,:)
    print *
    print '(3i3)', b(1,:)
    print '(3i3)', b(2,:)
    print *
    mask = a.ne.b
    print '(3l3)', mask(1,:)
    print '(3l3)', mask(2,:)
    print *
    print '(3i3)', count(mask)
    print *
    print '(3i3)', count(mask, 1)
    print *
    print '(3i3)', count(mask, 2)
end program test_count
@end smallexample
@end table



@node CPU_TIME
@section @code{CPU_TIME} --- CPU elapsed time in seconds
@findex @code{CPU_TIME} intrinsic
@cindex CPU_TIME

@table @asis
@item @emph{Description}:
Returns a @code{REAL} value representing the elapsed CPU time in seconds.  This
is useful for testing segments of code to determine execution time.

@item @emph{Option}:
f95, gnu

@item @emph{Class}:
subroutine

@item @emph{Syntax}:
@code{CPU_TIME(X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type shall be @code{REAL} with intent out.
@end multitable

@item @emph{Return value}:
None

@item @emph{Example}:
@smallexample
program test_cpu_time
    real :: start, finish
    call cpu_time(start)
        ! put code to test here
    call cpu_time(finish)
    print '("Time = ",f6.3," seconds.")',finish-start
end program test_cpu_time
@end smallexample
@end table



@node CSHIFT
@section @code{CSHIFT} --- Circular shift function
@findex @code{CSHIFT} intrinsic
@cindex cshift intrinsic

@table @asis
@item @emph{Description}:
@code{CSHIFT(ARRAY, SHIFT[,DIM])} performs a circular shift on elements of
@var{ARRAY} along the dimension of @var{DIM}.  If @var{DIM} is omitted it is
taken to be @code{1}.  @var{DIM} is a scaler of type @code{INTEGER} in the
range of @math{1 /leq DIM /leq n)} where @math{n} is the rank of @var{ARRAY}.
If the rank of @var{ARRAY} is one, then all elements of @var{ARRAY} are shifted
by @var{SHIFT} places.  If rank is greater than one, then all complete rank one
sections of @var{ARRAY} along the given dimension are shifted.  Elements
shifted out one end of each rank one section are shifted back in the other end.

@item @emph{Option}:
f95, gnu

@item @emph{Class}:
transformational function

@item @emph{Syntax}:
@code{A = CSHIFT(A, SHIFT[,DIM])}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{ARRAY}  @tab May be any type, not scaler.
@item @var{SHIFT}  @tab The type shall be @code{INTEGER}.
@item @var{DIM}    @tab The type shall be @code{INTEGER}.
@end multitable

@item @emph{Return value}:
Returns an array of same type and rank as the @var{ARRAY} argument.

@item @emph{Example}:
@smallexample
program test_cshift
    integer, dimension(3,3) :: a
    a = reshape( (/ 1, 2, 3, 4, 5, 6, 7, 8, 9 /), (/ 3, 3 /))
    print '(3i3)', a(1,:)
    print '(3i3)', a(2,:)
    print '(3i3)', a(3,:)    
    a = cshift(a, SHIFT=(/1, 2, -1/), DIM=2)
    print *
    print '(3i3)', a(1,:)
    print '(3i3)', a(2,:)
    print '(3i3)', a(3,:)
end program test_cshift
@end smallexample
@end table


@node CTIME
@section @code{CTIME} --- Convert a time into a string
@findex @code{CTIME} intrinsic
@cindex ctime subroutine 

@table @asis
@item @emph{Description}:
@code{CTIME(T,S)} converts @var{T}, a system time value, such as returned
by @code{TIME8()}, to a string of the form @samp{Sat Aug 19 18:13:14
1995}, and returns that string into @var{S}.

If @code{CTIME} is invoked as a function, it can not be invoked as a
subroutine, and vice versa.

@var{T} is an @code{INTENT(IN)} @code{INTEGER(KIND=8)} variable.
@var{S} is an @code{INTENT(OUT)} @code{CHARACTER} variable.

@item @emph{Option}:
gnu

@item @emph{Class}:
subroutine

@item @emph{Syntax}:
@multitable @columnfractions .80
@item @code{CALL CTIME(T,S)}.
@item @code{S = CTIME(T)}, (not recommended).
@end multitable

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{S}@tab The type shall be of type @code{CHARACTER}.
@item @var{T}@tab The type shall be of type @code{INTEGER(KIND=8)}.
@end multitable

@item @emph{Return value}:
The converted date and time as a string.

@item @emph{Example}:
@smallexample
program test_ctime
    integer(8) :: i
    character(len=30) :: date
    i = time8()

    ! Do something, main part of the program
    
    call ctime(i,date)
    print *, 'Program was started on ', date
end program test_ctime
@end smallexample
@end table

@node DATE_AND_TIME
@section @code{DATE_AND_TIME} --- Date and time subroutine
@findex @code{DATE_AND_TIME} intrinsic
@cindex DATE_AND_TIME

@table @asis
@item @emph{Description}:
@code{DATE_AND_TIME(DATE, TIME, ZONE, VALUES)} gets the corresponding date and
time information from the real-time system clock.  @var{DATE} is
@code{INTENT(OUT)} and has form ccyymmdd.  @var{TIME} is @code{INTENT(OUT)} and
has form hhmmss.sss.  @var{ZONE} is @code{INTENT(OUT)} and has form (+-)hhmm,
representing the difference with respect to Coordinated Universal Time (UTC).
Unavailable time and date parameters return blanks.

@var{VALUES} is @code{INTENT(OUT)} and provides the following:

@multitable @columnfractions .15 .30 .60
@item @tab @code{VALUE(1)}: @tab The year
@item @tab @code{VALUE(2)}: @tab The month
@item @tab @code{VALUE(3)}: @tab The day of the month
@item @tab @code{VAlUE(4)}: @tab Time difference with UTC in minutes
@item @tab @code{VALUE(5)}: @tab The hour of the day
@item @tab @code{VALUE(6)}: @tab The minutes of the hour
@item @tab @code{VALUE(7)}: @tab The seconds of the minute
@item @tab @code{VALUE(8)}: @tab The milliseconds of the second
@end multitable	    

@item @emph{Option}:
f95, gnu

@item @emph{Class}:
subroutine

@item @emph{Syntax}:
@code{CALL DATE_AND_TIME([DATE, TIME, ZONE, VALUES])}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{DATE}  @tab (Optional) The type shall be @code{CHARACTER(8)} or larger.
@item @var{TIME}  @tab (Optional) The type shall be @code{CHARACTER(10)} or larger.
@item @var{ZONE}  @tab (Optional) The type shall be @code{CHARACTER(5)} or larger.
@item @var{VALUES}@tab (Optional) The type shall be @code{INTEGER(8)}.
@end multitable

@item @emph{Return value}:
None

@item @emph{Example}:
@smallexample
program test_time_and_date
    character(8)  :: date
    character(10) :: time
    character(5)  :: zone
    integer,dimension(8) :: values
    ! using keyword arguments
    call date_and_time(date,time,zone,values)
    call date_and_time(DATE=date,ZONE=zone)
    call date_and_time(TIME=time)
    call date_and_time(VALUES=values)
    print '(a,2x,a,2x,a)', date, time, zone
    print '(8i5))', values
end program test_time_and_date
@end smallexample
@end table



@node DBLE
@section @code{DBLE} --- Double conversion function 
@findex @code{DBLE} intrinsic
@cindex double conversion

@table @asis
@item @emph{Description}:
@code{DBLE(X)} Converts @var{X} to double precision real type.
@code{DFLOAT} is an alias for @code{DBLE}

@item @emph{Option}:
f95, gnu

@item @emph{Class}:
elemental function

@item @emph{Syntax}:
@code{X = DBLE(X)}
@code{X = DFLOAT(X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type shall be @code{INTEGER(*)}, @code{REAL(*)}, or @code{COMPLEX(*)}.
@end multitable

@item @emph{Return value}:
The return value is of type double precision real.

@item @emph{Example}:
@smallexample
program test_dble
    real    :: x = 2.18
    integer :: i = 5
    complex :: z = (2.3,1.14)
    print *, dble(x), dble(i), dfloat(z)
end program test_dble
@end smallexample
@end table



@node DCMPLX
@section @code{DCMPLX} --- Double complex conversion function
@findex @code{DCMPLX} intrinsic
@cindex DCMPLX

@table @asis
@item @emph{Description}:
@code{DCMPLX(X [,Y])} returns a double complex number where @var{X} is
converted to the real component.  If @var{Y} is present it is converted to the
imaginary component.  If @var{Y} is not present then the imaginary component is
set to 0.0.  If @var{X} is complex then @var{Y} must not be present.

@item @emph{Option}:
f95, gnu

@item @emph{Class}:
elemental function

@item @emph{Syntax}:
@code{C = DCMPLX(X)}
@code{C = DCMPLX(X,Y)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type may be @code{INTEGER(*)}, @code{REAL(*)}, or @code{COMPLEX(*)}.
@item @var{Y} @tab Optional if @var{X} is not @code{COMPLEX(*)}. May be @code{INTEGER(*)} or @code{REAL(*)}. 
@end multitable

@item @emph{Return value}:
The return value is of type @code{COMPLEX(8)}

@item @emph{Example}:
@smallexample
program test_dcmplx
    integer :: i = 42
    real :: x = 3.14
    complex :: z
    z = cmplx(i, x)
    print *, dcmplx(i)
    print *, dcmplx(x)
    print *, dcmplx(z)
    print *, dcmplx(x,i)
end program test_dcmplx
@end smallexample
@end table



@node DFLOAT
@section @code{DFLOAT} --- Double conversion function 
@findex @code{DFLOAT} intrinsic
@cindex double float conversion

@table @asis
@item @emph{Description}:
@code{DFLOAT(X)} Converts @var{X} to double precision real type.
@code{DFLOAT} is an alias for @code{DBLE}.  See @code{DBLE}.
@end table



@node DIGITS
@section @code{DIGITS} --- Significant digits function
@findex @code{DIGITS} intrinsic
@cindex digits, significant

@table @asis
@item @emph{Description}:
@code{DIGITS(X)} returns the number of significant digits of the internal model
representation of @var{X}.  For example, on a system using a 32-bit
floating point representation, a default real number would likely return 24.

@item @emph{Option}:
f95, gnu

@item @emph{Class}:
inquiry function

@item @emph{Syntax}:
@code{C = DIGITS(X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type may be @code{INTEGER(*)} or @code{REAL(*)}.
@end multitable

@item @emph{Return value}:
The return value is of type @code{INTEGER}.

@item @emph{Example}:
@smallexample
program test_digits
    integer :: i = 12345
    real :: x = 3.143
    real(8) :: y = 2.33
    print *, digits(i)
    print *, digits(x)
    print *, digits(y)
end program test_digits
@end smallexample
@end table



@node DIM
@section @code{DIM} --- Dim function
@findex @code{DIM} intrinsic
@findex @code{IDIM} intrinsic
@findex @code{DDIM} intrinsic
@cindex dim

@table @asis
@item @emph{Description}:
@code{DIM(X,Y)} returns the difference @code{X-Y} if the result is positive;
otherwise returns zero.

@item @emph{Option}:
f95, gnu

@item @emph{Class}:
elemental function

@item @emph{Syntax}:
@code{X = DIM(X,Y)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type shall be @code{INTEGER(*)} or @code{REAL(*)}
@item @var{Y} @tab The type shall be the same type and kind as @var{X}.
@end multitable

@item @emph{Return value}:
The return value is of type @code{INTEGER(*)} or @code{REAL(*)}.

@item @emph{Example}:
@smallexample
program test_dim
    integer :: i
    real(8) :: x
    i = dim(4, 15)
    x = dim(4.345_8, 2.111_8)
    print *, i
    print *, x
end program test_dim
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name            @tab Argument          @tab Return type       @tab Option
@item @code{IDIM(X,Y)} @tab @code{INTEGER(4) X,Y} @tab @code{INTEGER(4)} @tab gnu
@item @code{DDIM(X,Y)} @tab @code{REAL(8) X,Y}  @tab @code{REAL(8)} @tab gnu
@end multitable
@end table



@node DOT_PRODUCT
@section @code{DOT_PRODUCT} --- Dot product function
@findex @code{DOT_PRODUCT} intrinsic
@cindex Dot product

@table @asis
@item @emph{Description}:
@code{DOT_PRODUCT(X,Y)} computes the dot product multiplication of two vectors
@var{X} and @var{Y}.  The two vectors may be either numeric or logical
and must be arrays of rank one and of equal size. If the vectors are
@code{INTEGER(*)} or @code{REAL(*)}, the result is @code{SUM(X*Y)}. If the
vectors are @code{COMPLEX(*)}, the result is @code{SUM(CONJG(X)*Y)}. If the 
vectors are @code{LOGICAL}, the result is @code{ANY(X.AND.Y)}.

@item @emph{Option}:
f95

@item @emph{Class}:
transformational function

@item @emph{Syntax}:
@code{S = DOT_PRODUCT(X,Y)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type shall be numeric or @code{LOGICAL}, rank 1.
@item @var{Y} @tab The type shall be numeric or @code{LOGICAL}, rank 1.
@end multitable

@item @emph{Return value}:
If the arguments are numeric, the return value is a scaler of numeric type,
@code{INTEGER(*)}, @code{REAL(*)}, or @code{COMPLEX(*)}.  If the arguments are
@code{LOGICAL}, the return value is @code{.TRUE.} or @code{.FALSE.}.

@item @emph{Example}:
@smallexample
program test_dot_prod
    integer, dimension(3) :: a, b
    a = (/ 1, 2, 3 /)
    b = (/ 4, 5, 6 /)
    print '(3i3)', a
    print *
    print '(3i3)', b
    print *
    print *, dot_product(a,b)
end program test_dot_prod
@end smallexample
@end table



@node DPROD
@section @code{DPROD} --- Double product function
@findex @code{DPROD} intrinsic
@cindex Double product

@table @asis
@item @emph{Description}:
@code{DPROD(X,Y)} returns the product @code{X*Y}.

@item @emph{Option}:
f95, gnu

@item @emph{Class}:
elemental function

@item @emph{Syntax}:
@code{D = DPROD(X,Y)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type shall be @code{REAL}.
@item @var{Y} @tab The type shall be @code{REAL}.
@end multitable

@item @emph{Return value}:
The return value is of type @code{REAL(8)}.

@item @emph{Example}:
@smallexample
program test_dprod
    integer :: i
    real :: x = 5.2
    real :: y = 2.3
    real(8) :: d
    d = dprod(x,y)
    print *, d
end program test_dprod
@end smallexample
@end table



@node DREAL
@section @code{DREAL} --- Double real part function
@findex @code{DREAL} intrinsic
@cindex Double real part

@table @asis
@item @emph{Description}:
@code{DREAL(Z)} returns the real part of complex variable @var{Z}.

@item @emph{Option}:
gnu

@item @emph{Class}:
elemental function

@item @emph{Syntax}:
@code{D = DREAL(Z)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{Z} @tab The type shall be @code{COMPLEX(8)}.
@end multitable

@item @emph{Return value}:
The return value is of type @code{REAL(8)}.

@item @emph{Example}:
@smallexample
program test_dreal
    complex(8) :: z = (1.3_8,7.2_8)
    print *, dreal(z)
end program test_dreal
@end smallexample
@end table



@node DTIME
@section @code{DTIME} --- Execution time subroutine (or function)
@findex @code{DTIME} intrinsic
@cindex dtime subroutine 

@table @asis
@item @emph{Description}:
@code{DTIME(TARRAY, RESULT)} initially returns the number of seconds of runtime
since the start of the process's execution in @var{RESULT}.  @var{TARRAY}
returns the user and system components of this time in @code{TARRAY(1)} and
@code{TARRAY(2)} respectively. @var{RESULT} is equal to @code{TARRAY(1) +
TARRAY(2)}.

Subsequent invocations of @code{DTIME} return values accumulated since the
previous invocation.

On some systems, the underlying timings are represented using types with
sufficiently small limits that overflows (wraparounds) are possible, such as
32-bit types. Therefore, the values returned by this intrinsic might be, or
become, negative, or numerically less than previous values, during a single
run of the compiled program.

If @code{DTIME} is invoked as a function, it can not be invoked as a
subroutine, and vice versa.

@var{TARRAY} and @var{RESULT} are @code{INTENT(OUT)} and provide the following:

@multitable @columnfractions .15 .30 .60
@item @tab @code{TARRAY(1)}: @tab User time in seconds.
@item @tab @code{TARRAY(2)}: @tab System time in seconds.
@item @tab @code{RESULT}: @tab Run time since start in seconds.
@end multitable

@item @emph{Option}:
gnu

@item @emph{Class}:
subroutine

@item @emph{Syntax}:
@multitable @columnfractions .80
@item @code{CALL DTIME(TARRAY, RESULT)}.
@item @code{RESULT = DTIME(TARRAY)}, (not recommended).
@end multitable

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{TARRAY}@tab The type shall be @code{REAL, DIMENSION(2)}.
@item @var{RESULT}@tab The type shall be @code{REAL}.
@end multitable

@item @emph{Return value}:
Elapsed time in seconds since the start of program execution.

@item @emph{Example}:
@smallexample
program test_dtime
    integer(8) :: i, j
    real, dimension(2) :: tarray
    real :: result
    call dtime(tarray, result)
    print *, result
    print *, tarray(1)
    print *, tarray(2)   
    do i=1,100000000    ! Just a delay
        j = i * i - i
    end do
    call dtime(tarray, result)
    print *, result
    print *, tarray(1)
    print *, tarray(2)
end program test_dtime
@end smallexample
@end table



@node EOSHIFT
@section @code{EOSHIFT} --- End-off shift function
@findex @code{EOSHIFT} intrinsic
@cindex eoshift intrinsic

@table @asis
@item @emph{Description}:
@code{EOSHIFT(ARRAY, SHIFT[,BOUNDARY, DIM])} performs an end-off shift on
elements of @var{ARRAY} along the dimension of @var{DIM}.  If @var{DIM} is
omitted it is taken to be @code{1}.  @var{DIM} is a scaler of type
@code{INTEGER} in the range of @math{1 /leq DIM /leq n)} where @math{n} is the
rank of @var{ARRAY}.  If the rank of @var{ARRAY} is one, then all elements of
@var{ARRAY} are shifted by @var{SHIFT} places.  If rank is greater than one,
then all complete rank one sections of @var{ARRAY} along the given dimension are
shifted.  Elements shifted out one end of each rank one section are dropped.  If
@var{BOUNDARY} is present then the corresponding value of from @var{BOUNDARY}
is copied back in the other end.  If @var{BOUNDARY} is not present then the
following are copied in depending on the type of @var{ARRAY}.

@multitable @columnfractions .15 .80
@item @emph{Array Type} @tab @emph{Boundary Value}
@item Numeric  @tab 0 of the type and kind of @var{ARRAY}.
@item Logical  @tab @code{.FALSE.}.
@item Character(@var{len}) @tab @var{len} blanks.
@end multitable

@item @emph{Option}:
f95, gnu

@item @emph{Class}:
transformational function

@item @emph{Syntax}:
@code{A = EOSHIFT(A, SHIFT[,BOUNDARY, DIM])}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{ARRAY}  @tab May be any type, not scaler.
@item @var{SHIFT}  @tab The type shall be @code{INTEGER}.
@item @var{BOUNDARY} @tab Same type as @var{ARRAY}. 
@item @var{DIM}    @tab The type shall be @code{INTEGER}.
@end multitable

@item @emph{Return value}:
Returns an array of same type and rank as the @var{ARRAY} argument.

@item @emph{Example}:
@smallexample
program test_eoshift
    integer, dimension(3,3) :: a
    a = reshape( (/ 1, 2, 3, 4, 5, 6, 7, 8, 9 /), (/ 3, 3 /))
    print '(3i3)', a(1,:)
    print '(3i3)', a(2,:)
    print '(3i3)', a(3,:)    
    a = EOSHIFT(a, SHIFT=(/1, 2, 1/), BOUNDARY=-5, DIM=2)
    print *
    print '(3i3)', a(1,:)
    print '(3i3)', a(2,:)
    print '(3i3)', a(3,:)
end program test_eoshift
@end smallexample
@end table



@node EPSILON
@section @code{EPSILON} --- Epsilon function
@findex @code{EPSILON} intrinsic
@cindex epsilon, significant

@table @asis
@item @emph{Description}:
@code{EPSILON(X)} returns a nearly negligible number relative to @code{1}.

@item @emph{Option}:
f95, gnu

@item @emph{Class}:
inquiry function

@item @emph{Syntax}:
@code{C = EPSILON(X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type shall be @code{REAL(*)}.
@end multitable

@item @emph{Return value}:
The return value is of same type as the argument.

@item @emph{Example}:
@smallexample
program test_epsilon
    real :: x = 3.143
    real(8) :: y = 2.33
    print *, EPSILON(x)
    print *, EPSILON(y)
end program test_epsilon
@end smallexample
@end table



@node ERF
@section @code{ERF} --- Error function 
@findex @code{ERF} intrinsic
@cindex error function

@table @asis
@item @emph{Description}:
@code{ERF(X)} computes the error function of @var{X}.

@item @emph{Option}:
gnu

@item @emph{Class}:
elemental function

@item @emph{Syntax}:
@code{X = ERF(X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type shall be @code{REAL(*)}, and it shall be scalar.
@end multitable

@item @emph{Return value}:
The return value is a scalar of type @code{REAL(*)} and it is positive
(@math{ - 1 \leq erf (x) \leq 1 }.

@item @emph{Example}:
@smallexample
program test_erf
  real(8) :: x = 0.17_8
  x = erf(x)
end program test_erf
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name            @tab Argument          @tab Return type       @tab Option
@item @code{DERF(X)}  @tab @code{REAL(8) X}  @tab @code{REAL(8)}    @tab gnu
@end multitable
@end table



@node ERFC
@section @code{ERFC} --- Error function 
@findex @code{ERFC} intrinsic
@cindex error function

@table @asis
@item @emph{Description}:
@code{ERFC(X)} computes the complementary error function of @var{X}.

@item @emph{Option}:
gnu

@item @emph{Class}:
elemental function

@item @emph{Syntax}:
@code{X = ERFC(X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type shall be @code{REAL(*)}, and it shall be scalar.
@end multitable

@item @emph{Return value}:
The return value is a scalar of type @code{REAL(*)} and it is positive
(@math{ 0 \leq erfc (x) \leq 2 }.

@item @emph{Example}:
@smallexample
program test_erfc
  real(8) :: x = 0.17_8
  x = erfc(x)
end program test_erfc
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name            @tab Argument          @tab Return type       @tab Option
@item @code{DERFC(X)} @tab @code{REAL(8) X}  @tab @code{REAL(8)}    @tab gnu
@end multitable
@end table



@node ETIME
@section @code{ETIME} --- Execution time subroutine (or function)
@findex @code{ETIME} intrinsic
@cindex ETIME subroutine 

@table @asis
@item @emph{Description}:
@code{ETIME(TARRAY, RESULT)} returns the number of seconds of runtime
since the start of the process's execution in @var{RESULT}.  @var{TARRAY}
returns the user and system components of this time in @code{TARRAY(1)} and
@code{TARRAY(2)} respectively. @var{RESULT} is equal to @code{TARRAY(1) + TARRAY(2)}.

On some systems, the underlying timings are represented using types with
sufficiently small limits that overflows (wraparounds) are possible, such as
32-bit types. Therefore, the values returned by this intrinsic might be, or
become, negative, or numerically less than previous values, during a single
run of the compiled program.

If @code{ETIME} is invoked as a function, it can not be invoked as a
subroutine, and vice versa.

@var{TARRAY} and @var{RESULT} are @code{INTENT(OUT)} and provide the following:

@multitable @columnfractions .15 .30 .60
@item @tab @code{TARRAY(1)}: @tab User time in seconds.
@item @tab @code{TARRAY(2)}: @tab System time in seconds.
@item @tab @code{RESULT}: @tab Run time since start in seconds.
@end multitable

@item @emph{Option}:
gnu

@item @emph{Class}:
subroutine

@item @emph{Syntax}:
@multitable @columnfractions .8
@item @code{CALL ETIME(TARRAY, RESULT)}.
@item @code{RESULT = ETIME(TARRAY)}, (not recommended).
@end multitable

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{TARRAY}@tab The type shall be @code{REAL, DIMENSION(2)}.
@item @var{RESULT}@tab The type shall be @code{REAL}.
@end multitable

@item @emph{Return value}:
Elapsed time in seconds since the start of program execution.

@item @emph{Example}:
@smallexample
program test_etime
    integer(8) :: i, j
    real, dimension(2) :: tarray
    real :: result
    call ETIME(tarray, result)
    print *, result
    print *, tarray(1)
    print *, tarray(2)   
    do i=1,100000000    ! Just a delay
        j = i * i - i
    end do
    call ETIME(tarray, result)
    print *, result
    print *, tarray(1)
    print *, tarray(2)
end program test_etime
@end smallexample
@end table



@node EXIT
@section @code{EXIT} --- Exit the program with status. 
@findex @code{EXIT}
@cindex exit

@table @asis
@item @emph{Description}:
@code{EXIT} causes immediate termination of the program with status.  If status
is omitted it returns the canonical @emph{success} for the system.  All Fortran
I/O units are closed. 

@item @emph{Option}:
gnu

@item @emph{Class}:
non-elemental subroutine

@item @emph{Syntax}:
@code{CALL EXIT([STATUS])}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{STATUS} @tab The type of the argument shall be @code{INTEGER(*)}.
@end multitable

@item @emph{Return value}:
@code{STATUS} is passed to the parent process on exit.

@item @emph{Example}:
@smallexample
program test_exit
  integer :: STATUS = 0
  print *, 'This program is going to exit.'
  call EXIT(STATUS)
end program test_exit
@end smallexample
@end table



@node EXP
@section @code{EXP} --- Exponential function 
@findex @code{EXP} intrinsic
@findex @code{DEXP} intrinsic
@findex @code{ZEXP} intrinsic
@findex @code{CDEXP} intrinsic
@cindex exponential

@table @asis
@item @emph{Description}:
@code{EXP(X)} computes the base @math{e} exponential of @var{X}.

@item @emph{Option}:
f95, gnu

@item @emph{Class}:
elemental function

@item @emph{Syntax}:
@code{X = EXP(X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type shall be @code{REAL(*)} or
@code{COMPLEX(*)}.
@end multitable

@item @emph{Return value}:
The return value has same type and kind as @var{X}.

@item @emph{Example}:
@smallexample
program test_exp
  real :: x = 1.0
  x = exp(x)
end program test_exp
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name            @tab Argument          @tab Return type       @tab Option
@item @code{DEXP(X)}  @tab @code{REAL(8) X}  @tab @code{REAL(8)}    @tab f95, gnu
@item @code{CEXP(X)}  @tab @code{COMPLEX(4) X}  @tab @code{COMPLEX(4)}    @tab f95, gnu
@item @code{ZEXP(X)}  @tab @code{COMPLEX(8) X}  @tab @code{COMPLEX(8)}    @tab f95, gnu
@item @code{CDEXP(X)} @tab @code{COMPLEX(8) X}  @tab @code{COMPLEX(8)}    @tab f95, gnu
@end multitable
@end table



@node EXPONENT
@section @code{EXPONENT} --- Exponent function 
@findex @code{EXPONENT} intrinsic
@cindex exponent function

@table @asis
@item @emph{Description}:
@code{EXPONENT(X)} returns the value of the exponent part of @var{X}. If @var{X}
is zero the value returned is zero. 

@item @emph{Option}:
f95, gnu

@item @emph{Class}:
elemental function

@item @emph{Syntax}:
@code{I = EXPONENT(X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type shall be @code{REAL(*)}.
@end multitable

@item @emph{Return value}:
The return value is of type default @code{INTEGER}.

@item @emph{Example}:
@smallexample
program test_exponent
  real :: x = 1.0
  integer :: i
  i = exponent(x)
  print *, i
  print *, exponent(0.0)
end program test_exponent
@end smallexample
@end table



@node FDATE
@section @code{FDATE} --- Get the current time as a string
@findex @code{FDATE} intrinsic
@cindex fdate subroutine 

@table @asis
@item @emph{Description}:
@code{FDATE(DATE)} returns the current date (using the same format as
@code{CTIME}) in @var{DATE}. It is equivalent to @code{CALL CTIME(DATE,
TIME8())}.

If @code{FDATE} is invoked as a function, it can not be invoked as a
subroutine, and vice versa.

@var{DATE} is an @code{INTENT(OUT)} @code{CHARACTER} variable.

@item @emph{Option}:
gnu

@item @emph{Class}:
subroutine

@item @emph{Syntax}:
@multitable @columnfractions .80
@item @code{CALL FDATE(DATE)}.
@item @code{DATE = FDATE()}, (not recommended).
@end multitable

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{DATE}@tab The type shall be of type @code{CHARACTER}.
@end multitable

@item @emph{Return value}:
The current date and time as a string.

@item @emph{Example}:
@smallexample
program test_fdate
    integer(8) :: i, j
    character(len=30) :: date
    call fdate(date)
    print *, 'Program started on ', date
    do i = 1, 100000000 ! Just a delay
        j = i * i - i
    end do
    call fdate(date)
    print *, 'Program ended on ', date
end program test_fdate
@end smallexample
@end table


@node FLOOR
@section @code{FLOOR} --- Integer floor function
@findex @code{FLOOR} intrinsic
@cindex floor

@table @asis
@item @emph{Description}:
@code{FLOOR(X)} returns the greatest integer less than or equal to @var{X}.

@item @emph{Option}:
f95, gnu

@item @emph{Class}:
elemental function

@item @emph{Syntax}:
@code{I = FLOOR(X[,KIND])}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type shall be @code{REAL(*)}.
@item @var{KIND} @tab Optional scaler integer initialization expression.
@end multitable

@item @emph{Return value}:
The return value is of type @code{INTEGER(KIND)}

@item @emph{Example}:
@smallexample
program test_floor
    real :: x = 63.29
    real :: y = -63.59
    print *, floor(x) ! returns 63
    print *, floor(y) ! returns -64
end program test_floor
@end smallexample
@end table



@node FNUM
@section @code{FNUM} --- File number function
@findex @code{FNUM} intrinsic
@cindex fnum

@table @asis
@item @emph{Description}:
@code{FNUM(UNIT)} returns the Posix file descriptor number coresponding to the
open Fortran I/O unit @code{UNIT}.

@item @emph{Option}:
gnu

@item @emph{Class}:
non-elemental function

@item @emph{Syntax}:
@code{I = FNUM(UNIT)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{UNIT} @tab The type shall be @code{INTEGER}.
@end multitable

@item @emph{Return value}:
The return value is of type @code{INTEGER}

@item @emph{Example}:
@smallexample
program test_fnum
  integer :: i
  open (unit=10, status = "scratch")
  i = fnum(10)
  print *, i
  close (10)
end program test_fnum
@end smallexample
@end table



@node LOG
@section @code{LOG} --- Logarithm function
@findex @code{LOG} intrinsic
@findex @code{ALOG} intrinsic
@findex @code{DLOG} intrinsic
@findex @code{CLOG} intrinsic
@findex @code{ZLOG} intrinsic
@findex @code{CDLOG} intrinsic
@cindex logarithm

@table @asis
@item @emph{Description}:
@code{LOG(X)} computes the logarithm of @var{X}.

@item @emph{Option}:
f95, gnu

@item @emph{Class}:
elemental function

@item @emph{Syntax}:
@code{X = LOG(X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type shall be @code{REAL(*)} or
@code{COMPLEX(*)}.
@end multitable

@item @emph{Return value}:
The return value is of type @code{REAL(*)} or @code{COMPLEX(*)}.
The kind type parameter is the same as @var{X}.

@item @emph{Example}:
@smallexample
program test_log
  real(8) :: x = 1.0_8
  complex :: z = (1.0, 2.0)
  x = log(x)
  z = log(z)
end program test_log
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name            @tab Argument          @tab Return type       @tab Option
@item @code{ALOG(X)}  @tab @code{REAL(4) X}  @tab @code{REAL(4)}    @tab f95, gnu
@item @code{DLOG(X)}  @tab @code{REAL(8) X}  @tab @code{REAL(8)}    @tab f95, gnu
@item @code{CLOG(X)}  @tab @code{COMPLEX(4) X}  @tab @code{COMPLEX(4)}    @tab f95, gnu
@item @code{ZLOG(X)}  @tab @code{COMPLEX(8) X}  @tab @code{COMPLEX(8)}    @tab f95, gnu
@item @code{CDLOG(X)} @tab @code{COMPLEX(8) X}  @tab @code{COMPLEX(8)}    @tab f95, gnu
@end multitable
@end table



@node LOG10
@section @code{LOG10} --- Base 10 logarithm function
@findex @code{LOG10} intrinsic
@findex @code{ALOG10} intrinsic
@findex @code{DLOG10} intrinsic
@cindex logarithm

@table @asis
@item @emph{Description}:
@code{LOG10(X)} computes the base 10 logarithm of @var{X}.

@item @emph{Option}:
f95, gnu

@item @emph{Class}:
elemental function

@item @emph{Syntax}:
@code{X = LOG10(X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type shall be @code{REAL(*)} or
@code{COMPLEX(*)}.
@end multitable

@item @emph{Return value}:
The return value is of type @code{REAL(*)} or @code{COMPLEX(*)}.
The kind type parameter is the same as @var{X}.

@item @emph{Example}:
@smallexample
program test_log10
  real(8) :: x = 10.0_8
  x = log10(x)
end program test_log10
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name            @tab Argument          @tab Return type       @tab Option
@item @code{ALOG10(X)}  @tab @code{REAL(4) X}  @tab @code{REAL(4)}    @tab f95, gnu
@item @code{DLOG10(X)}  @tab @code{REAL(8) X}  @tab @code{REAL(8)}    @tab f95, gnu
@end multitable
@end table




@node SECNDS
@section @code{SECNDS} --- Time subroutine
@findex @code{SECNDS} intrinsic
@cindex SECNDS

@table @asis
@item @emph{Description}:
@code{SECNDS(X)} gets the time in seconds from the real-time system clock.
@var{X} is a reference time, also in seconds. If this is zero, the time in
seconds from midnight is returned. This function is non-standard and its
use is discouraged.

@item @emph{Option}:
gnu

@item @emph{Class}:
function

@item @emph{Syntax}:
@code{T = SECNDS (X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item Name        @tab Type
@item @var{T}     @tab REAL(4)
@item @var{X}     @tab REAL(4)
@end multitable

@item @emph{Return value}:
None

@item @emph{Example}:
@smallexample
program test_secnds
    real(4) :: t1, t2
    print *, secnds (0.0)   ! seconds since midnight
    t1 = secnds (0.0)       ! reference time
    do i = 1, 10000000      ! do something
    end do
    t2 = secnds (t1)        ! elapsed time
    print *, "Something took ", t2, " seconds."
end program test_secnds
@end smallexample
@end table



@node SIN
@section @code{SIN} --- Sine function 
@findex @code{SIN} intrinsic
@findex @code{DSIN} intrinsic
@findex @code{ZSIN} intrinsic
@findex @code{CDSIN} intrinsic
@cindex sine

@table @asis
@item @emph{Description}:
@code{SIN(X)} computes the sine of @var{X}.

@item @emph{Option}:
f95, gnu

@item @emph{Class}:
elemental function

@item @emph{Syntax}:
@code{X = SIN(X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type shall be @code{REAL(*)} or
@code{COMPLEX(*)}.
@end multitable

@item @emph{Return value}:
The return value has same type and king than @var{X}.

@item @emph{Example}:
@smallexample
program test_sin
  real :: x = 0.0
  x = sin(x)
end program test_sin
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name            @tab Argument          @tab Return type       @tab Option
@item @code{DSIN(X)}  @tab @code{REAL(8) X}  @tab @code{REAL(8)}    @tab f95, gnu
@item @code{CSIN(X)}  @tab @code{COMPLEX(4) X}  @tab @code{COMPLEX(4)}    @tab f95, gnu
@item @code{ZSIN(X)}  @tab @code{COMPLEX(8) X}  @tab @code{COMPLEX(8)}    @tab f95, gnu
@item @code{CDSIN(X)} @tab @code{COMPLEX(8) X}  @tab @code{COMPLEX(8)}    @tab f95, gnu
@end multitable
@end table



@node SINH
@section @code{SINH} --- Hyperbolic sine function 
@findex @code{SINH} intrinsic
@findex @code{DSINH} intrinsic
@cindex hyperbolic sine

@table @asis
@item @emph{Description}:
@code{SINH(X)} computes the hyperbolic sine of @var{X}.

@item @emph{Option}:
f95, gnu

@item @emph{Class}:
elemental function

@item @emph{Syntax}:
@code{X = SINH(X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type shall be @code{REAL(*)}.
@end multitable

@item @emph{Return value}:
The return value is of type @code{REAL(*)}.

@item @emph{Example}:
@smallexample
program test_sinh
  real(8) :: x = - 1.0_8
  x = sinh(x)
end program test_sinh
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name            @tab Argument          @tab Return type       @tab Option
@item @code{DSINH(X)} @tab @code{REAL(8) X}  @tab @code{REAL(8)}    @tab f95, gnu
@end multitable
@end table



@node SQRT
@section @code{SQRT} --- Square-root function
@findex @code{SQRT} intrinsic
@findex @code{DSQRT} intrinsic
@findex @code{CSQRT} intrinsic
@findex @code{ZSQRT} intrinsic
@findex @code{CDSQRT} intrinsic
@cindex square-root

@table @asis
@item @emph{Description}:
@code{SQRT(X)} computes the square root of @var{X}.

@item @emph{Option}:
f95, gnu

@item @emph{Class}:
elemental function

@item @emph{Syntax}:
@code{X = SQRT(X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type shall be @code{REAL(*)} or
@code{COMPLEX(*)}.
@end multitable

@item @emph{Return value}:
The return value is of type @code{REAL(*)} or @code{COMPLEX(*)}.
The kind type parameter is the same as @var{X}.

@item @emph{Example}:
@smallexample
program test_sqrt
  real(8) :: x = 2.0_8
  complex :: z = (1.0, 2.0)
  x = sqrt(x)
  z = sqrt(z)
end program test_sqrt
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name            @tab Argument          @tab Return type       @tab Option
@item @code{DSQRT(X)}  @tab @code{REAL(8) X}  @tab @code{REAL(8)}    @tab f95, gnu
@item @code{CSQRT(X)}  @tab @code{COMPLEX(4) X}  @tab @code{COMPLEX(4)}    @tab f95, gnu
@item @code{ZSQRT(X)}  @tab @code{COMPLEX(8) X}  @tab @code{COMPLEX(8)}    @tab f95, gnu
@item @code{CDSQRT(X)} @tab @code{COMPLEX(8) X}  @tab @code{COMPLEX(8)}    @tab f95, gnu
@end multitable
@end table



@node TAN
@section @code{TAN} --- Tangent function
@findex @code{TAN} intrinsic
@findex @code{DTAN} intrinsic
@cindex tangent

@table @asis
@item @emph{Description}:
@code{TAN(X)} computes the tangent of @var{X}.

@item @emph{Option}:
f95, gnu

@item @emph{Class}:
elemental function

@item @emph{Syntax}:
@code{X = TAN(X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type shall be @code{REAL(*)}.
@end multitable

@item @emph{Return value}:
The return value is of type @code{REAL(*)}.  The kind type parameter is
the same as @var{X}.

@item @emph{Example}:
@smallexample
program test_tan
  real(8) :: x = 0.165_8
  x = tan(x)
end program test_tan
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name            @tab Argument          @tab Return type       @tab Option
@item @code{DTAN(X)}  @tab @code{REAL(8) X}  @tab @code{REAL(8)}    @tab f95, gnu
@end multitable
@end table



@node TANH
@section @code{TANH} --- Hyperbolic tangent function 
@findex @code{TANH} intrinsic
@findex @code{DTANH} intrinsic
@cindex hyperbolic tangent

@table @asis
@item @emph{Description}:
@code{TANH(X)} computes the hyperbolic tangent of @var{X}.

@item @emph{Option}:
f95, gnu

@item @emph{Class}:
elemental function

@item @emph{Syntax}:
@code{X = TANH(X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type shall be @code{REAL(*)}.
@end multitable

@item @emph{Return value}:
The return value is of type @code{REAL(*)} and lies in the range
@math{ - 1 \leq tanh(x) \leq 1 }.

@item @emph{Example}:
@smallexample
program test_tanh
  real(8) :: x = 2.1_8
  x = tanh(x)
end program test_tanh
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name            @tab Argument          @tab Return type       @tab Option
@item @code{DTANH(X)} @tab @code{REAL(8) X}  @tab @code{REAL(8)}    @tab f95, gnu
@end multitable
@end table



@comment sub   flush
@comment 
@comment gen   fraction
@comment 
@comment gen   fstat
@comment sub   fstat
@comment 
@comment sub   getarg
@comment 
@comment gen   getcwd
@comment sub   getcwd
@comment 
@comment sub   getenv
@comment 
@comment gen   getgid
@comment 
@comment gen   getpid
@comment 
@comment gen   getuid
@comment 
@comment sub   get_command
@comment 
@comment sub   get_command_argument
@comment 
@comment sub   get_environment_variable
@comment 
@comment gen   huge
@comment 
@comment gen   iachar
@comment 
@comment gen   iand
@comment 
@comment gen   iargc
@comment 
@comment gen   ibclr
@comment 
@comment gen   ibits
@comment 
@comment gen   ibset
@comment 
@comment gen   ichar
@comment 
@comment gen   ieor
@comment 
@comment gen   index
@comment 
@comment gen   int
@comment       ifix
@comment       idint
@comment 
@comment gen   ior
@comment 
@comment gen   irand
@comment 
@comment gen   ishft
@comment 
@comment gen   ishftc
@comment 
@comment gen   kind
@comment 
@comment gen   lbound
@comment 
@comment gen   len
@comment 
@comment gen   len_trim
@comment 
@comment gen   lge
@comment 
@comment gen   lgt
@comment 
@comment gen   lle
@comment 
@comment gen   llt
@comment 
@comment gen   logical
@comment 
@comment gen   matmul
@comment 
@comment gen   max
@comment       max0
@comment       amax0
@comment       amax1
@comment       max1
@comment       dmax1
@comment 
@comment gen   maxexponent
@comment 
@comment gen   maxloc
@comment 
@comment gen   maxval
@comment 
@comment gen   merge
@comment 
@comment gen   min
@comment       min0
@comment       amin0
@comment       amin1
@comment       min1
@comment       dmin1
@comment 
@comment gen   minexponent
@comment 
@comment gen   minloc
@comment 
@comment gen   minval
@comment 
@comment gen   mod
@comment       amod
@comment       dmod
@comment 
@comment gen   modulo
@comment 
@comment sub   mvbits
@comment 
@comment gen   nearest
@comment 
@comment gen   nint
@comment       idnint
@comment 
@comment gen   not
@comment 
@comment gen   null
@comment 
@comment gen   pack
@comment 
@comment gen   precision
@comment 
@comment gen   present
@comment 
@comment gen   product
@comment 
@comment gen   radix
@comment 
@comment gen   rand
@comment       ran 
@comment 
@comment sub   random_number
@comment 
@comment sub   random_seed
@comment 
@comment gen   range
@comment 
@comment gen   real
@comment       float
@comment       sngl
@comment 
@comment gen   repeat
@comment 
@comment gen   reshape
@comment 
@comment gen   rrspacing
@comment 
@comment gen   scale
@comment 
@comment gen   scan
@comment 
@comment gen   second
@comment sub   second
@comment 
@comment gen   selected_int_kind
@comment 
@comment gen   selected_real_kind
@comment 
@comment gen   set_exponent
@comment 
@comment gen   shape
@comment 
@comment gen   sign
@comment       isign
@comment       dsign
@comment 
@comment gen   size
@comment 
@comment gen   spacing
@comment 
@comment gen   spread
@comment 
@comment sub   srand
@comment 
@comment gen   stat
@comment sub   stat
@comment 
@comment gen   sum
@comment 
@comment gen   system
@comment sub   system
@comment 
@comment sub system_clock
@comment 
@comment gen   tiny
@comment 
@comment gen   transfer
@comment 
@comment gen   transpose
@comment 
@comment gen   trim
@comment 
@comment gen   ubound
@comment 
@comment gen   umask
@comment sub   umask
@comment 
@comment gen   unlink
@comment sub   unlink
@comment 
@comment gen   unpack
@comment 
@comment gen   verify

