This is doc/gfortran.info, produced by makeinfo version 4.8 from
/home/gdr/build/gcc-release/gcc-4.0.4/gcc-4.0.4/gcc/fortran/gfortran.texi.

   Copyright (C) 1999-2005 Free Software Foundation, Inc.

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License" and "Funding Free
Software", the Front-Cover texts being (a) (see below), and with the
Back-Cover Texts being (b) (see below).  A copy of the license is
included in the section entitled "GNU Free Documentation License".

   (a) The FSF's Front-Cover Text is:

   A GNU Manual

   (b) The FSF's Back-Cover Text is:

   You have freedom to copy and modify this GNU Manual, like GNU
software.  Copies published by the Free Software Foundation raise
funds for GNU development.

INFO-DIR-SECTION Programming
START-INFO-DIR-ENTRY
* gfortran: (gfortran).                  The GNU Fortran 95 Compiler.
END-INFO-DIR-ENTRY
   This file documents the use and the internals of the GNU Fortran 95
compiler, (`gfortran').

   Published by the Free Software Foundation 59 Temple Place - Suite 330
Boston, MA 02111-1307 USA

   Copyright (C) 1999-2005 Free Software Foundation, Inc.

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License" and "Funding Free
Software", the Front-Cover texts being (a) (see below), and with the
Back-Cover Texts being (b) (see below).  A copy of the license is
included in the section entitled "GNU Free Documentation License".

   (a) The FSF's Front-Cover Text is:

   A GNU Manual

   (b) The FSF's Back-Cover Text is:

   You have freedom to copy and modify this GNU Manual, like GNU
software.  Copies published by the Free Software Foundation raise
funds for GNU development.

   Contributed by Steven Bosscher (<s.bosscher@gcc.gnu.org>).


File: gfortran.info,  Node: Top,  Next: Copying,  Up: (DIR)

Introduction
************

This manual documents the use of `gfortran', the GNU Fortran 95
compiler. You can find in this manual how to invoke `gfortran', as well
as its features and incompatibilities.

* Menu:

* Copying::              GNU General Public License says
                         how you can copy and share GNU Fortran.
* GNU Free Documentation License::
		         How you can copy and share this manual.
* Funding::              How to help assure continued work for free software.
* Getting Started::      What you should know about `gfortran'.
* GFORTRAN and GCC::     You can compile Fortran, C, or other programs.
* GFORTRAN and G77::     Why we chose to start from scratch.
* Invoking GFORTRAN::    Command options supported by `gfortran'.
* Project Status::       Status of `gfortran', roadmap, proposed extensions.
* Contributing::         How you can help.
* Standards::	         Standards supported by `gfortran'
* Extensions::           Language extensions implemented by `gfortran'
* Intrinsic Procedures:: Intrinsic procedures supported by `gfortran'
* Index::                Index of this documentation.


File: gfortran.info,  Node: Copying,  Next: GNU Free Documentation License,  Prev: Top,  Up: Top

GNU GENERAL PUBLIC LICENSE
**************************

                         Version 2, June 1991

     Copyright (C) 1989, 1991 Free Software Foundation, Inc.
     59 Temple Place - Suite 330, Boston, MA  02111-1307, USA

     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.

Preamble
========

The licenses for most software are designed to take away your freedom
to share and change it.  By contrast, the GNU General Public License is
intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Library General Public License instead.)  You can apply it to
your programs, too.

   When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it in
new free programs; and that you know you can do these things.

   To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

   For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

   We protect your rights with two steps: (1) copyright the software,
and (2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

   Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

   Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

   The precise terms and conditions for copying, distribution and
modification follow.

    TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
  0. This License applies to any program or other work which contains a
     notice placed by the copyright holder saying it may be distributed
     under the terms of this General Public License.  The "Program",
     below, refers to any such program or work, and a "work based on
     the Program" means either the Program or any derivative work under
     copyright law: that is to say, a work containing the Program or a
     portion of it, either verbatim or with modifications and/or
     translated into another language.  (Hereinafter, translation is
     included without limitation in the term "modification".)  Each
     licensee is addressed as "you".

     Activities other than copying, distribution and modification are
     not covered by this License; they are outside its scope.  The act
     of running the Program is not restricted, and the output from the
     Program is covered only if its contents constitute a work based on
     the Program (independent of having been made by running the
     Program).  Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
     source code as you receive it, in any medium, provided that you
     conspicuously and appropriately publish on each copy an appropriate
     copyright notice and disclaimer of warranty; keep intact all the
     notices that refer to this License and to the absence of any
     warranty; and give any other recipients of the Program a copy of
     this License along with the Program.

     You may charge a fee for the physical act of transferring a copy,
     and you may at your option offer warranty protection in exchange
     for a fee.

  2. You may modify your copy or copies of the Program or any portion
     of it, thus forming a work based on the Program, and copy and
     distribute such modifications or work under the terms of Section 1
     above, provided that you also meet all of these conditions:

       a. You must cause the modified files to carry prominent notices
          stating that you changed the files and the date of any change.

       b. You must cause any work that you distribute or publish, that
          in whole or in part contains or is derived from the Program
          or any part thereof, to be licensed as a whole at no charge
          to all third parties under the terms of this License.

       c. If the modified program normally reads commands interactively
          when run, you must cause it, when started running for such
          interactive use in the most ordinary way, to print or display
          an announcement including an appropriate copyright notice and
          a notice that there is no warranty (or else, saying that you
          provide a warranty) and that users may redistribute the
          program under these conditions, and telling the user how to
          view a copy of this License.  (Exception: if the Program
          itself is interactive but does not normally print such an
          announcement, your work based on the Program is not required
          to print an announcement.)

     These requirements apply to the modified work as a whole.  If
     identifiable sections of that work are not derived from the
     Program, and can be reasonably considered independent and separate
     works in themselves, then this License, and its terms, do not
     apply to those sections when you distribute them as separate
     works.  But when you distribute the same sections as part of a
     whole which is a work based on the Program, the distribution of
     the whole must be on the terms of this License, whose permissions
     for other licensees extend to the entire whole, and thus to each
     and every part regardless of who wrote it.

     Thus, it is not the intent of this section to claim rights or
     contest your rights to work written entirely by you; rather, the
     intent is to exercise the right to control the distribution of
     derivative or collective works based on the Program.

     In addition, mere aggregation of another work not based on the
     Program with the Program (or with a work based on the Program) on
     a volume of a storage or distribution medium does not bring the
     other work under the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
     under Section 2) in object code or executable form under the terms
     of Sections 1 and 2 above provided that you also do one of the
     following:

       a. Accompany it with the complete corresponding machine-readable
          source code, which must be distributed under the terms of
          Sections 1 and 2 above on a medium customarily used for
          software interchange; or,

       b. Accompany it with a written offer, valid for at least three
          years, to give any third party, for a charge no more than your
          cost of physically performing source distribution, a complete
          machine-readable copy of the corresponding source code, to be
          distributed under the terms of Sections 1 and 2 above on a
          medium customarily used for software interchange; or,

       c. Accompany it with the information you received as to the offer
          to distribute corresponding source code.  (This alternative is
          allowed only for noncommercial distribution and only if you
          received the program in object code or executable form with
          such an offer, in accord with Subsection b above.)

     The source code for a work means the preferred form of the work for
     making modifications to it.  For an executable work, complete
     source code means all the source code for all modules it contains,
     plus any associated interface definition files, plus the scripts
     used to control compilation and installation of the executable.
     However, as a special exception, the source code distributed need
     not include anything that is normally distributed (in either
     source or binary form) with the major components (compiler,
     kernel, and so on) of the operating system on which the executable
     runs, unless that component itself accompanies the executable.

     If distribution of executable or object code is made by offering
     access to copy from a designated place, then offering equivalent
     access to copy the source code from the same place counts as
     distribution of the source code, even though third parties are not
     compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
     except as expressly provided under this License.  Any attempt
     otherwise to copy, modify, sublicense or distribute the Program is
     void, and will automatically terminate your rights under this
     License.  However, parties who have received copies, or rights,
     from you under this License will not have their licenses
     terminated so long as such parties remain in full compliance.

  5. You are not required to accept this License, since you have not
     signed it.  However, nothing else grants you permission to modify
     or distribute the Program or its derivative works.  These actions
     are prohibited by law if you do not accept this License.
     Therefore, by modifying or distributing the Program (or any work
     based on the Program), you indicate your acceptance of this
     License to do so, and all its terms and conditions for copying,
     distributing or modifying the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
     Program), the recipient automatically receives a license from the
     original licensor to copy, distribute or modify the Program
     subject to these terms and conditions.  You may not impose any
     further restrictions on the recipients' exercise of the rights
     granted herein.  You are not responsible for enforcing compliance
     by third parties to this License.

  7. If, as a consequence of a court judgment or allegation of patent
     infringement or for any other reason (not limited to patent
     issues), conditions are imposed on you (whether by court order,
     agreement or otherwise) that contradict the conditions of this
     License, they do not excuse you from the conditions of this
     License.  If you cannot distribute so as to satisfy simultaneously
     your obligations under this License and any other pertinent
     obligations, then as a consequence you may not distribute the
     Program at all.  For example, if a patent license would not permit
     royalty-free redistribution of the Program by all those who
     receive copies directly or indirectly through you, then the only
     way you could satisfy both it and this License would be to refrain
     entirely from distribution of the Program.

     If any portion of this section is held invalid or unenforceable
     under any particular circumstance, the balance of the section is
     intended to apply and the section as a whole is intended to apply
     in other circumstances.

     It is not the purpose of this section to induce you to infringe any
     patents or other property right claims or to contest validity of
     any such claims; this section has the sole purpose of protecting
     the integrity of the free software distribution system, which is
     implemented by public license practices.  Many people have made
     generous contributions to the wide range of software distributed
     through that system in reliance on consistent application of that
     system; it is up to the author/donor to decide if he or she is
     willing to distribute software through any other system and a
     licensee cannot impose that choice.

     This section is intended to make thoroughly clear what is believed
     to be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
     certain countries either by patents or by copyrighted interfaces,
     the original copyright holder who places the Program under this
     License may add an explicit geographical distribution limitation
     excluding those countries, so that distribution is permitted only
     in or among countries not thus excluded.  In such case, this
     License incorporates the limitation as if written in the body of
     this License.

  9. The Free Software Foundation may publish revised and/or new
     versions of the General Public License from time to time.  Such
     new versions will be similar in spirit to the present version, but
     may differ in detail to address new problems or concerns.

     Each version is given a distinguishing version number.  If the
     Program specifies a version number of this License which applies
     to it and "any later version", you have the option of following
     the terms and conditions either of that version or of any later
     version published by the Free Software Foundation.  If the Program
     does not specify a version number of this License, you may choose
     any version ever published by the Free Software Foundation.

 10. If you wish to incorporate parts of the Program into other free
     programs whose distribution conditions are different, write to the
     author to ask for permission.  For software which is copyrighted
     by the Free Software Foundation, write to the Free Software
     Foundation; we sometimes make exceptions for this.  Our decision
     will be guided by the two goals of preserving the free status of
     all derivatives of our free software and of promoting the sharing
     and reuse of software generally.

                                NO WARRANTY
 11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO
     WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE
     LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
     HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT
     WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT
     NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
     FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE
     QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
     PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY
     SERVICING, REPAIR OR CORRECTION.

 12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
     WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY
     MODIFY AND/OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE
     LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL,
     INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR
     INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
     DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU
     OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY
     OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN
     ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

                      END OF TERMS AND CONDITIONS
How to Apply These Terms to Your New Programs
=============================================

If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these
terms.

   To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

     ONE LINE TO GIVE THE PROGRAM'S NAME AND A BRIEF IDEA OF WHAT IT DOES.
     Copyright (C) YEAR  NAME OF AUTHOR

     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.

     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program; if not, write to the Free Software Foundation,
     Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

   Also add information on how to contact you by electronic and paper
mail.

   If the program is interactive, make it output a short notice like
this when it starts in an interactive mode:

     Gnomovision version 69, Copyright (C) YEAR NAME OF AUTHOR
     Gnomovision comes with ABSOLUTELY NO WARRANTY; for details
     type `show w'.
     This is free software, and you are welcome to redistribute it
     under certain conditions; type `show c' for details.

   The hypothetical commands `show w' and `show c' should show the
appropriate parts of the General Public License.  Of course, the
commands you use may be called something other than `show w' and `show
c'; they could even be mouse-clicks or menu items--whatever suits your
program.

   You should also get your employer (if you work as a programmer) or
your school, if any, to sign a "copyright disclaimer" for the program,
if necessary.  Here is a sample; alter the names:

     Yoyodyne, Inc., hereby disclaims all copyright interest in the program
     `Gnomovision' (which makes passes at compilers) written by James Hacker.

     SIGNATURE OF TY COON, 1 April 1989
     Ty Coon, President of Vice

   This General Public License does not permit incorporating your
program into proprietary programs.  If your program is a subroutine
library, you may consider it more useful to permit linking proprietary
applications with the library.  If this is what you want to do, use the
GNU Library General Public License instead of this License.


File: gfortran.info,  Node: GNU Free Documentation License,  Next: Funding,  Prev: Copying,  Up: Top

GNU Free Documentation License
******************************

                      Version 1.2, November 2002

     Copyright (C) 2000,2001,2002 Free Software Foundation, Inc.
     59 Temple Place, Suite 330, Boston, MA  02111-1307, USA

     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.

  0. PREAMBLE

     The purpose of this License is to make a manual, textbook, or other
     functional and useful document "free" in the sense of freedom: to
     assure everyone the effective freedom to copy and redistribute it,
     with or without modifying it, either commercially or
     noncommercially.  Secondarily, this License preserves for the
     author and publisher a way to get credit for their work, while not
     being considered responsible for modifications made by others.

     This License is a kind of "copyleft", which means that derivative
     works of the document must themselves be free in the same sense.
     It complements the GNU General Public License, which is a copyleft
     license designed for free software.

     We have designed this License in order to use it for manuals for
     free software, because free software needs free documentation: a
     free program should come with manuals providing the same freedoms
     that the software does.  But this License is not limited to
     software manuals; it can be used for any textual work, regardless
     of subject matter or whether it is published as a printed book.
     We recommend this License principally for works whose purpose is
     instruction or reference.

  1. APPLICABILITY AND DEFINITIONS

     This License applies to any manual or other work, in any medium,
     that contains a notice placed by the copyright holder saying it
     can be distributed under the terms of this License.  Such a notice
     grants a world-wide, royalty-free license, unlimited in duration,
     to use that work under the conditions stated herein.  The
     "Document", below, refers to any such manual or work.  Any member
     of the public is a licensee, and is addressed as "you".  You
     accept the license if you copy, modify or distribute the work in a
     way requiring permission under copyright law.

     A "Modified Version" of the Document means any work containing the
     Document or a portion of it, either copied verbatim, or with
     modifications and/or translated into another language.

     A "Secondary Section" is a named appendix or a front-matter section
     of the Document that deals exclusively with the relationship of the
     publishers or authors of the Document to the Document's overall
     subject (or to related matters) and contains nothing that could
     fall directly within that overall subject.  (Thus, if the Document
     is in part a textbook of mathematics, a Secondary Section may not
     explain any mathematics.)  The relationship could be a matter of
     historical connection with the subject or with related matters, or
     of legal, commercial, philosophical, ethical or political position
     regarding them.

     The "Invariant Sections" are certain Secondary Sections whose
     titles are designated, as being those of Invariant Sections, in
     the notice that says that the Document is released under this
     License.  If a section does not fit the above definition of
     Secondary then it is not allowed to be designated as Invariant.
     The Document may contain zero Invariant Sections.  If the Document
     does not identify any Invariant Sections then there are none.

     The "Cover Texts" are certain short passages of text that are
     listed, as Front-Cover Texts or Back-Cover Texts, in the notice
     that says that the Document is released under this License.  A
     Front-Cover Text may be at most 5 words, and a Back-Cover Text may
     be at most 25 words.

     A "Transparent" copy of the Document means a machine-readable copy,
     represented in a format whose specification is available to the
     general public, that is suitable for revising the document
     straightforwardly with generic text editors or (for images
     composed of pixels) generic paint programs or (for drawings) some
     widely available drawing editor, and that is suitable for input to
     text formatters or for automatic translation to a variety of
     formats suitable for input to text formatters.  A copy made in an
     otherwise Transparent file format whose markup, or absence of
     markup, has been arranged to thwart or discourage subsequent
     modification by readers is not Transparent.  An image format is
     not Transparent if used for any substantial amount of text.  A
     copy that is not "Transparent" is called "Opaque".

     Examples of suitable formats for Transparent copies include plain
     ASCII without markup, Texinfo input format, LaTeX input format,
     SGML or XML using a publicly available DTD, and
     standard-conforming simple HTML, PostScript or PDF designed for
     human modification.  Examples of transparent image formats include
     PNG, XCF and JPG.  Opaque formats include proprietary formats that
     can be read and edited only by proprietary word processors, SGML or
     XML for which the DTD and/or processing tools are not generally
     available, and the machine-generated HTML, PostScript or PDF
     produced by some word processors for output purposes only.

     The "Title Page" means, for a printed book, the title page itself,
     plus such following pages as are needed to hold, legibly, the
     material this License requires to appear in the title page.  For
     works in formats which do not have any title page as such, "Title
     Page" means the text near the most prominent appearance of the
     work's title, preceding the beginning of the body of the text.

     A section "Entitled XYZ" means a named subunit of the Document
     whose title either is precisely XYZ or contains XYZ in parentheses
     following text that translates XYZ in another language.  (Here XYZ
     stands for a specific section name mentioned below, such as
     "Acknowledgements", "Dedications", "Endorsements", or "History".)
     To "Preserve the Title" of such a section when you modify the
     Document means that it remains a section "Entitled XYZ" according
     to this definition.

     The Document may include Warranty Disclaimers next to the notice
     which states that this License applies to the Document.  These
     Warranty Disclaimers are considered to be included by reference in
     this License, but only as regards disclaiming warranties: any other
     implication that these Warranty Disclaimers may have is void and
     has no effect on the meaning of this License.

  2. VERBATIM COPYING

     You may copy and distribute the Document in any medium, either
     commercially or noncommercially, provided that this License, the
     copyright notices, and the license notice saying this License
     applies to the Document are reproduced in all copies, and that you
     add no other conditions whatsoever to those of this License.  You
     may not use technical measures to obstruct or control the reading
     or further copying of the copies you make or distribute.  However,
     you may accept compensation in exchange for copies.  If you
     distribute a large enough number of copies you must also follow
     the conditions in section 3.

     You may also lend copies, under the same conditions stated above,
     and you may publicly display copies.

  3. COPYING IN QUANTITY

     If you publish printed copies (or copies in media that commonly
     have printed covers) of the Document, numbering more than 100, and
     the Document's license notice requires Cover Texts, you must
     enclose the copies in covers that carry, clearly and legibly, all
     these Cover Texts: Front-Cover Texts on the front cover, and
     Back-Cover Texts on the back cover.  Both covers must also clearly
     and legibly identify you as the publisher of these copies.  The
     front cover must present the full title with all words of the
     title equally prominent and visible.  You may add other material
     on the covers in addition.  Copying with changes limited to the
     covers, as long as they preserve the title of the Document and
     satisfy these conditions, can be treated as verbatim copying in
     other respects.

     If the required texts for either cover are too voluminous to fit
     legibly, you should put the first ones listed (as many as fit
     reasonably) on the actual cover, and continue the rest onto
     adjacent pages.

     If you publish or distribute Opaque copies of the Document
     numbering more than 100, you must either include a
     machine-readable Transparent copy along with each Opaque copy, or
     state in or with each Opaque copy a computer-network location from
     which the general network-using public has access to download
     using public-standard network protocols a complete Transparent
     copy of the Document, free of added material.  If you use the
     latter option, you must take reasonably prudent steps, when you
     begin distribution of Opaque copies in quantity, to ensure that
     this Transparent copy will remain thus accessible at the stated
     location until at least one year after the last time you
     distribute an Opaque copy (directly or through your agents or
     retailers) of that edition to the public.

     It is requested, but not required, that you contact the authors of
     the Document well before redistributing any large number of
     copies, to give them a chance to provide you with an updated
     version of the Document.

  4. MODIFICATIONS

     You may copy and distribute a Modified Version of the Document
     under the conditions of sections 2 and 3 above, provided that you
     release the Modified Version under precisely this License, with
     the Modified Version filling the role of the Document, thus
     licensing distribution and modification of the Modified Version to
     whoever possesses a copy of it.  In addition, you must do these
     things in the Modified Version:

       A. Use in the Title Page (and on the covers, if any) a title
          distinct from that of the Document, and from those of
          previous versions (which should, if there were any, be listed
          in the History section of the Document).  You may use the
          same title as a previous version if the original publisher of
          that version gives permission.

       B. List on the Title Page, as authors, one or more persons or
          entities responsible for authorship of the modifications in
          the Modified Version, together with at least five of the
          principal authors of the Document (all of its principal
          authors, if it has fewer than five), unless they release you
          from this requirement.

       C. State on the Title page the name of the publisher of the
          Modified Version, as the publisher.

       D. Preserve all the copyright notices of the Document.

       E. Add an appropriate copyright notice for your modifications
          adjacent to the other copyright notices.

       F. Include, immediately after the copyright notices, a license
          notice giving the public permission to use the Modified
          Version under the terms of this License, in the form shown in
          the Addendum below.

       G. Preserve in that license notice the full lists of Invariant
          Sections and required Cover Texts given in the Document's
          license notice.

       H. Include an unaltered copy of this License.

       I. Preserve the section Entitled "History", Preserve its Title,
          and add to it an item stating at least the title, year, new
          authors, and publisher of the Modified Version as given on
          the Title Page.  If there is no section Entitled "History" in
          the Document, create one stating the title, year, authors,
          and publisher of the Document as given on its Title Page,
          then add an item describing the Modified Version as stated in
          the previous sentence.

       J. Preserve the network location, if any, given in the Document
          for public access to a Transparent copy of the Document, and
          likewise the network locations given in the Document for
          previous versions it was based on.  These may be placed in
          the "History" section.  You may omit a network location for a
          work that was published at least four years before the
          Document itself, or if the original publisher of the version
          it refers to gives permission.

       K. For any section Entitled "Acknowledgements" or "Dedications",
          Preserve the Title of the section, and preserve in the
          section all the substance and tone of each of the contributor
          acknowledgements and/or dedications given therein.

       L. Preserve all the Invariant Sections of the Document,
          unaltered in their text and in their titles.  Section numbers
          or the equivalent are not considered part of the section
          titles.

       M. Delete any section Entitled "Endorsements".  Such a section
          may not be included in the Modified Version.

       N. Do not retitle any existing section to be Entitled
          "Endorsements" or to conflict in title with any Invariant
          Section.

       O. Preserve any Warranty Disclaimers.

     If the Modified Version includes new front-matter sections or
     appendices that qualify as Secondary Sections and contain no
     material copied from the Document, you may at your option
     designate some or all of these sections as invariant.  To do this,
     add their titles to the list of Invariant Sections in the Modified
     Version's license notice.  These titles must be distinct from any
     other section titles.

     You may add a section Entitled "Endorsements", provided it contains
     nothing but endorsements of your Modified Version by various
     parties--for example, statements of peer review or that the text
     has been approved by an organization as the authoritative
     definition of a standard.

     You may add a passage of up to five words as a Front-Cover Text,
     and a passage of up to 25 words as a Back-Cover Text, to the end
     of the list of Cover Texts in the Modified Version.  Only one
     passage of Front-Cover Text and one of Back-Cover Text may be
     added by (or through arrangements made by) any one entity.  If the
     Document already includes a cover text for the same cover,
     previously added by you or by arrangement made by the same entity
     you are acting on behalf of, you may not add another; but you may
     replace the old one, on explicit permission from the previous
     publisher that added the old one.

     The author(s) and publisher(s) of the Document do not by this
     License give permission to use their names for publicity for or to
     assert or imply endorsement of any Modified Version.

  5. COMBINING DOCUMENTS

     You may combine the Document with other documents released under
     this License, under the terms defined in section 4 above for
     modified versions, provided that you include in the combination
     all of the Invariant Sections of all of the original documents,
     unmodified, and list them all as Invariant Sections of your
     combined work in its license notice, and that you preserve all
     their Warranty Disclaimers.

     The combined work need only contain one copy of this License, and
     multiple identical Invariant Sections may be replaced with a single
     copy.  If there are multiple Invariant Sections with the same name
     but different contents, make the title of each such section unique
     by adding at the end of it, in parentheses, the name of the
     original author or publisher of that section if known, or else a
     unique number.  Make the same adjustment to the section titles in
     the list of Invariant Sections in the license notice of the
     combined work.

     In the combination, you must combine any sections Entitled
     "History" in the various original documents, forming one section
     Entitled "History"; likewise combine any sections Entitled
     "Acknowledgements", and any sections Entitled "Dedications".  You
     must delete all sections Entitled "Endorsements."

  6. COLLECTIONS OF DOCUMENTS

     You may make a collection consisting of the Document and other
     documents released under this License, and replace the individual
     copies of this License in the various documents with a single copy
     that is included in the collection, provided that you follow the
     rules of this License for verbatim copying of each of the
     documents in all other respects.

     You may extract a single document from such a collection, and
     distribute it individually under this License, provided you insert
     a copy of this License into the extracted document, and follow
     this License in all other respects regarding verbatim copying of
     that document.

  7. AGGREGATION WITH INDEPENDENT WORKS

     A compilation of the Document or its derivatives with other
     separate and independent documents or works, in or on a volume of
     a storage or distribution medium, is called an "aggregate" if the
     copyright resulting from the compilation is not used to limit the
     legal rights of the compilation's users beyond what the individual
     works permit.  When the Document is included an aggregate, this
     License does not apply to the other works in the aggregate which
     are not themselves derivative works of the Document.

     If the Cover Text requirement of section 3 is applicable to these
     copies of the Document, then if the Document is less than one half
     of the entire aggregate, the Document's Cover Texts may be placed
     on covers that bracket the Document within the aggregate, or the
     electronic equivalent of covers if the Document is in electronic
     form.  Otherwise they must appear on printed covers that bracket
     the whole aggregate.

  8. TRANSLATION

     Translation is considered a kind of modification, so you may
     distribute translations of the Document under the terms of section
     4.  Replacing Invariant Sections with translations requires special
     permission from their copyright holders, but you may include
     translations of some or all Invariant Sections in addition to the
     original versions of these Invariant Sections.  You may include a
     translation of this License, and all the license notices in the
     Document, and any Warrany Disclaimers, provided that you also
     include the original English version of this License and the
     original versions of those notices and disclaimers.  In case of a
     disagreement between the translation and the original version of
     this License or a notice or disclaimer, the original version will
     prevail.

     If a section in the Document is Entitled "Acknowledgements",
     "Dedications", or "History", the requirement (section 4) to
     Preserve its Title (section 1) will typically require changing the
     actual title.

  9. TERMINATION

     You may not copy, modify, sublicense, or distribute the Document
     except as expressly provided for under this License.  Any other
     attempt to copy, modify, sublicense or distribute the Document is
     void, and will automatically terminate your rights under this
     License.  However, parties who have received copies, or rights,
     from you under this License will not have their licenses
     terminated so long as such parties remain in full compliance.

 10. FUTURE REVISIONS OF THIS LICENSE

     The Free Software Foundation may publish new, revised versions of
     the GNU Free Documentation License from time to time.  Such new
     versions will be similar in spirit to the present version, but may
     differ in detail to address new problems or concerns.  See
     `http://www.gnu.org/copyleft/'.

     Each version of the License is given a distinguishing version
     number.  If the Document specifies that a particular numbered
     version of this License "or any later version" applies to it, you
     have the option of following the terms and conditions either of
     that specified version or of any later version that has been
     published (not as a draft) by the Free Software Foundation.  If
     the Document does not specify a version number of this License,
     you may choose any version ever published (not as a draft) by the
     Free Software Foundation.

ADDENDUM: How to use this License for your documents
====================================================

To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and license
notices just after the title page:

       Copyright (C)  YEAR  YOUR NAME.
       Permission is granted to copy, distribute and/or modify this document
       under the terms of the GNU Free Documentation License, Version 1.2
       or any later version published by the Free Software Foundation;
       with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
       A copy of the license is included in the section entitled ``GNU
       Free Documentation License''.

   If you have Invariant Sections, Front-Cover Texts and Back-Cover
Texts, replace the "with...Texts." line with this:

         with the Invariant Sections being LIST THEIR TITLES, with
         the Front-Cover Texts being LIST, and with the Back-Cover Texts
         being LIST.

   If you have Invariant Sections without Cover Texts, or some other
combination of the three, merge those two alternatives to suit the
situation.

   If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of
free software license, such as the GNU General Public License, to
permit their use in free software.


File: gfortran.info,  Node: Funding,  Next: Getting Started,  Prev: GNU Free Documentation License,  Up: Top

Funding Free Software
*********************

If you want to have more free software a few years from now, it makes
sense for you to help encourage people to contribute funds for its
development.  The most effective approach known is to encourage
commercial redistributors to donate.

   Users of free software systems can boost the pace of development by
encouraging for-a-fee distributors to donate part of their selling price
to free software developers--the Free Software Foundation, and others.

   The way to convince distributors to do this is to demand it and
expect it from them.  So when you compare distributors, judge them
partly by how much they give to free software development.  Show
distributors they must compete to be the one who gives the most.

   To make this approach work, you must insist on numbers that you can
compare, such as, "We will donate ten dollars to the Frobnitz project
for each disk sold."  Don't be satisfied with a vague promise, such as
"A portion of the profits are donated," since it doesn't give a basis
for comparison.

   Even a precise fraction "of the profits from this disk" is not very
meaningful, since creative accounting and unrelated business decisions
can greatly alter what fraction of the sales price counts as profit.
If the price you pay is $50, ten percent of the profit is probably less
than a dollar; it might be a few cents, or nothing at all.

   Some redistributors do development work themselves.  This is useful
too; but to keep everyone honest, you need to inquire how much they do,
and what kind.  Some kinds of development make much more long-term
difference than others.  For example, maintaining a separate version of
a program contributes very little; maintaining the standard version of a
program for the whole community contributes much.  Easy new ports
contribute little, since someone else would surely do them; difficult
ports such as adding a new CPU to the GNU Compiler Collection
contribute more; major new features or packages contribute the most.

   By establishing the idea that supporting further development is "the
proper thing to do" when distributing free software for a fee, we can
assure a steady flow of resources into making more free software.

     Copyright (C) 1994 Free Software Foundation, Inc.
     Verbatim copying and redistribution of this section is permitted
     without royalty; alteration is not permitted.


File: gfortran.info,  Node: Getting Started,  Next: GFORTRAN and GCC,  Prev: Funding,  Up: Top

1 Getting Started
*****************

Gfortran is the GNU Fortran 95 compiler front end, designed initially
as a free replacement for, or alternative to, the unix `f95' command;
`gfortran' is command you'll use to invoke the compiler.

   _Gfortran is not yet a fully conformant Fortran 95 compiler_.  It
can generate code for most constructs and expressions, but work remains
to be done.  In particular, there are known deficiencies with ENTRY,
NAMELIST, and sophisticated use of MODULES, POINTERS and DERIVED TYPES.
For those whose Fortran codes conform to either the Fortran 77
standard or the GNU Fortran 77 language, we recommend to use `g77' from
GCC 3.4.  We recommend that distributors continue to provide packages
of g77-3.4 until we announce that `gfortran' fully replaces `g77'.  The
gfortran developers welcome any feedback on user experience with
`gfortran' at <fortran@gcc.gnu.org>.

   When `gfortran' is finished, it will do everything you expect from
any decent compiler:

   * Read a user's program, stored in a file and containing
     instructions written in Fortran 77, Fortran 90 or Fortran 95.
     This file contains "source code".

   * Translate the user's program into instructions a computer can
     carry out more quickly than it takes to translate the instructions
     in the first place.  The result after compilation of a program is
     "machine code", code designed to be efficiently translated and
     processed by a machine such as your computer.  Humans usually
     aren't as good writing machine code as they are at writing Fortran
     (or C++, Ada, or Java), because is easy to make tiny mistakes
     writing machine code.

   * Provide the user with information about the reasons why the
     compiler is unable to create a binary from the source code.
     Usually this will be the case if the source code is flawed.  When
     writing Fortran, it is easy to make big mistakes.  The Fortran 90
     requires that the compiler can point out mistakes to the user.  An
     incorrect usage of the language causes an "error message".

     The compiler will also attempt to diagnose cases where the user's
     program contains a correct usage of the language, but instructs
     the computer to do something questionable.  This kind of
     diagnostics message is called a "warning message".

   * Provide optional information about the translation passes from the
     source code to machine code.  This can help a user of the compiler
     to find the cause of certain bugs which may not be obvious in the
     source code, but may be more easily found at a lower level
     compiler output.  It also helps developers to find bugs in the
     compiler itself.

   * Provide information in the generated machine code that can make it
     easier to find bugs in the program (using a debugging tool, called
     a "debugger", such as the GNU Debugger `gdb').

   * Locate and gather machine code already generated to perform
     actions requested by statements in the user's program.  This
     machine code is organized into "modules" and is located and
     "linked" to the user program.

   Gfortran consists of several components:

   * A version of the `gcc' command (which also might be installed as
     the system's `cc' command) that also understands and accepts
     Fortran source code.  The `gcc' command is the "driver" program for
     all the languages in the GNU Compiler Collection (GCC); With `gcc',
     you can compiler the source code of any language for which a front
     end is available in GCC.

   * The `gfortran' command itself, which also might be installed as the
     system's `f95' command.  `gfortran' is just another driver program,
     but specifically for the Fortran 95 compiler only.  The difference
     with `gcc' is that `gfortran' will automatically link the correct
     libraries to your program.

   * A collection of run-time libraries.  These libraries contains the
     machine code needed to support capabilities of the Fortran
     language that are not directly provided by the machine code
     generated by the `gfortran' compilation phase, such as intrinsic
     functions and subroutines, and routines for interaction with files
     and the operating system.

   * The Fortran compiler itself, (`f951').  This is the gfortran
     parser and code generator, linked to and interfaced with the GCC
     backend library.  `f951' "translates" the source code to assembler
     code.  You would typically not use this program directly; instead,
     the `gcc' or `gfortran' driver programs will call it for you.


File: gfortran.info,  Node: GFORTRAN and GCC,  Next: GFORTRAN and G77,  Prev: Getting Started,  Up: Top

2 GFORTRAN and GCC
******************

GCC used to be the GNU "C" Compiler, but is now known as the "GNU
Compiler Collection".  GCC provides the GNU system with a very versatile
compiler middle end (shared optimization passes), and with back ends
(code generators) for many different computer architectures and
operating systems.  The code of the middle end and back end are shared
by all compiler front ends that are in the GNU Compiler Collection.

   A GCC front end is essentially a source code parser and a pass to
generate a representation of the semantics of the program in the source
code in the GCC language independent intermediate language, called
"GENERIC".

   The parser takes a source file written in a particular computer
language, reads and parses it, and tries to make sure that the source
code conforms to the language rules.  Once the correctness of a program
has been established, the compiler will build a data structure known as
the "Abstract Syntax tree", or just "AST" or "tree" for short.  This
data structure represents the whole program or a subroutine or a
function.  The "tree" is passed to the GCC middle end, which will
perform optimization passes on it, pass the optimized AST and generate
assembly for the program unit.

   Different phases in this translation process can be, and in fact
_are_ merged in many compiler front ends.  GNU Fortran 95 has a strict
separation between the parser and code generator.

   The goal of the gfortran project is to build a new front end for GCC:
A Fortran 95 front end.  In a non-gfortran installation, `gcc' will not
be able to compile Fortran 95 source code (only the "C" front end has
to be compiled if you want to build GCC, all other languages are
optional).  If you build GCC with gfortran, `gcc' will recognize
`.f/.f90/.f95' source files and accepts Fortran 95 specific command
line options.


File: gfortran.info,  Node: GFORTRAN and G77,  Next: Invoking GFORTRAN,  Prev: GFORTRAN and GCC,  Up: Top

3 GFORTRAN and G77
******************

Why do we write a compiler front end from scratch?  There's a fine
Fortran 77 compiler in the GNU Compiler Collection that accepts some
features of the Fortran 90 standard as extensions.  Why not start from
there and revamp it?

   One of the reasons is that Craig Burley, the author of G77, has
decided to stop working on the G77 front end.  On Craig explains the
reasons for his decision to stop working on G77
(http://world.std.com/~burley/g77-why.html) in one of the pages in his
homepage.  Among the reasons is a lack of interest in improvements to
`g77'.  Users appear to be quite satisfied with `g77' as it is.  While
`g77' is still being maintained (by Toon Moene), it is unlikely that
sufficient people will be willing to completely rewrite the existing
code.

   But there are other reasons to start from scratch.  Many people,
including Craig Burley, no longer agreed with certain design decisions
in the G77 front end.  Also, the interface of `g77' to the back end is
written in a style which is confusing and not up to date on recommended
practice.  In fact, a full rewrite had already been planned for GCC 3.0.

   When Craig decided to stop, it just seemed to be a better idea to
start a new project from scratch, because it was expected to be easier
to maintain code we develop ourselves than to do a major overhaul of
`g77' first, and then build a Fortran 95 compiler out of it.


File: gfortran.info,  Node: Invoking GFORTRAN,  Next: Project Status,  Prev: GFORTRAN and G77,  Up: Top

4 GNU Fortran 95 Command Options
********************************

The `gfortran' command supports all the options supported by the `gcc'
command.  Only options specific to gfortran are documented here.

   _Gfortran is not yet a fully conformant Fortran 95 compiler_.  It
can generate code for most constructs and expressions, but work remains
to be done.  In particular, there are known deficiencies with ENTRY,
NAMELIST, and sophisticated use of MODULES, POINTERS and DERIVED TYPES.
For those whose Fortran codes conform to either the Fortran 77
standard or the GNU Fortran 77 language, we recommend to use `g77' from
GCC 3.4.  We recommend that distributors continue to provide packages
of g77-3.4 until we announce that `gfortran' fully replaces `g77'.  The
gfortran developers welcome any feedback on user experience with
`gfortran' at <fortran@gcc.gnu.org>.

   *Note GCC Command Options: (gcc)Invoking GCC, for information on the
non-Fortran-specific aspects of the `gcc' command (and, therefore, the
`gfortran' command).

   All `gcc' and `gfortran' options are accepted both by `gfortran' and
by `gcc' (as well as any other drivers built at the same time, such as
`g++'), since adding `gfortran' to the `gcc' distribution enables
acceptance of `gfortran' options by all of the relevant drivers.

   In some cases, options have positive and negative forms; the
negative form of `-ffoo' would be `-fno-foo'.  This manual documents
only one of these two forms, whichever one is not the default.

* Menu:

* Option Summary::      Brief list of all `gfortran' options,
                        without explanations.
* Fortran Dialect Options::  Controlling the variant of Fortran language
                             compiled.
* Warning Options::     How picky should the compiler be?
* Debugging Options::   Symbol tables, measurements, and debugging dumps.
* Directory Options::   Where to find module files
* Code Gen Options::    Specifying conventions for function calls, data layout
                        and register usage.
* Environment Variables:: Env vars that affect GNU Fortran.


File: gfortran.info,  Node: Option Summary,  Next: Fortran Dialect Options,  Up: Invoking GFORTRAN

4.1 Option Summary
==================

Here is a summary of all the options specific to GNU Fortran, grouped
by type.  Explanations are in the following sections.

_Fortran Language Options_
     *Note Options Controlling Fortran Dialect: Fortran Dialect Options.
          -ffree-form  -fno-fixed-form
          -fdollar-ok  -fimplicit-none  -fmax-identifier-length
          -std=STD
          -ffixed-line-length-N  -ffixed-line-length-none
          -fdefault-double-8  -fdefault-integer-8  -fdefault-real-8

_Warning Options_
     *Note Options to Request or Suppress Warnings: Warning Options.
          -fsyntax-only  -pedantic  -pedantic-errors
          -w  -Wall  -Waliasing  -Wconversion
          -Wimplicit-interface  -Wnonstd-intrinsics  -Wsurprising  -Wunderflow
          -Wunused-labels -Wline-truncation -W

_Debugging Options_
     *Note Options for Debugging Your Program or GCC: Debugging Options.
          -fdump-parse-tree

_Directory Options_
     *Note Options for Directory Search: Directory Options.
          -IDIR  -MDIR

_Code Generation Options_
     *Note Options for Code Generation Conventions: Code Gen Options.
          -fno-automatic -ff2c -fno-underscoring  -fsecond-underscore
          -fbounds-check  -fmax-stack-var-size=N
          -fpackderived  -frepack-arrays


* Menu:

* Fortran Dialect Options::  Controlling the variant of Fortran language
                             compiled.
* Warning Options::     How picky should the compiler be?
* Debugging Options::   Symbol tables, measurements, and debugging dumps.
* Directory Options::   Where to find module files
* Code Gen Options::    Specifying conventions for function calls, data layout
                        and register usage.


File: gfortran.info,  Node: Fortran Dialect Options,  Next: Warning Options,  Prev: Option Summary,  Up: Invoking GFORTRAN

4.2 Options Controlling Fortran Dialect
=======================================

The following options control the dialect of Fortran that the compiler
accepts:

`-ffree-form'

`-ffixed-form'
     Specify the layout used by the the source file. The free form
     layout was introduced in Fortran 90.  Fixed form was traditionally
     used in older Fortran programs.

`-fdefault-double-8'
     Set the "DOUBLE PRECISION" type to an 8 byte wide.

`-fdefault-integer-8'
     Set the default integer and logical types to an 8 byte wide type.
     Do nothing if this is already the default.

`-fdefault-real-8'
     Set the default real type to an 8 byte wide type.  Do nothing if
     this is already the default.

`-fdollar-ok'
     Allow `$' as a valid character in a symbol name.

`-fno-backslash'

`'
     Compile switch to change the interpretation of a backslash from
     "C"-style escape characters to a single backslash character.

`-ffixed-line-length-N'
     Set column after which characters are ignored in typical fixed-form
     lines in the source file, and through which spaces are assumed (as
     if padded to that length) after the ends of short fixed-form lines.

     Popular values for N include 72 (the standard and the default), 80
     (card image), and 132 (corresponds to "extended-source" options in
     some popular compilers).  N may be `none', meaning that the entire
     line is meaningful and that continued character constants never
     have implicit spaces appended to them to fill out the line.
     `-ffixed-line-length-0' means the same thing as
     `-ffixed-line-length-none'.

`-fmax-identifier-length=N'
     Specify the maximum allowed identifier length. Typical values are
     31 (Fortran 95) and 63 (Fortran 200x).

`-fimplicit-none'
     Specify that no implicit typing is allowed, unless overridden by
     explicit `IMPLICIT' statements.  This is the equivalent of adding
     `implicit none' to the start of every procedure.

`-std=STD'
     Conform to the specified standard.  Allowed values for STD are
     `gnu', `f95', `f2003' and `legacy'.



File: gfortran.info,  Node: Warning Options,  Next: Debugging Options,  Prev: Fortran Dialect Options,  Up: Invoking GFORTRAN

4.3 Options to Request or Suppress Warnings
===========================================

Warnings are diagnostic messages that report constructions which are
not inherently erroneous but which are risky or suggest there might
have been an error.

   You can request many specific warnings with options beginning `-W',
for example `-Wimplicit' to request warnings on implicit declarations.
Each of these specific warning options also has a negative form
beginning `-Wno-' to turn off warnings; for example, `-Wno-implicit'.
This manual lists only one of the two forms, whichever is not the
default.

   These options control the amount and kinds of warnings produced by
GNU Fortran:

`-fsyntax-only'
     Check the code for syntax errors, but don't do anything beyond
     that.

`-pedantic'
     Issue warnings for uses of extensions to FORTRAN 95.  `-pedantic'
     also applies to C-language constructs where they occur in GNU
     Fortran source files, such as use of `\e' in a character constant
     within a directive like `#include'.

     Valid FORTRAN 95 programs should compile properly with or without
     this option.  However, without this option, certain GNU extensions
     and traditional Fortran features are supported as well.  With this
     option, many of them are rejected.

     Some users try to use `-pedantic' to check programs for
     conformance.  They soon find that it does not do quite what they
     want--it finds some nonstandard practices, but not all.  However,
     improvements to `gfortran' in this area are welcome.

     This should be used in conjunction with -std=STD.

`-pedantic-errors'
     Like `-pedantic', except that errors are produced rather than
     warnings.

`-w'
     Inhibit all warning messages.

`-Wall'
     Enables commonly used warning options that which pertain to usage
     that we recommend avoiding and that we believe is easy to avoid.
     This currently includes `-Wunused-labels', `-Waliasing',
     `-Wsurprising', `-Wnonstd-intrinsic' and `-Wline-truncation'.

`-Waliasing'
     Warn about possible aliasing of dummy arguments. The following
     example will trigger the warning as it would be illegal to `bar' to
     modify either parameter.
            INTEGER A
            CALL BAR(A,A)

`-Wconversion'
     Warn about implicit conversions between different types.

`-Wimplicit-interface'
     Warn about when procedure are called without an explicit interface.
     Note this only checks that an explicit interface is present.  It
     does not check that the declared interfaces are consistent across
     program units.

`-Wnonstd-intrinsic'
     Warn if the user tries to use an intrinsic that does not belong to
     the standard the user has chosen via the -std option.

`-Wsurprising'
     Produce a warning when "suspicious" code constructs are
     encountered.  While technically legal these usually indicate that
     an error has been made.

     This currently produces a warning under the following
     circumstances:

        * An INTEGER SELECT construct has a CASE that can never be
          matched as its lower value is greater than its upper value.

        * A LOGICAL SELECT construct has three CASE statements.

`-Wunderflow'
     Produce a warning when numerical constant expressions are
     encountered, which yield an UNDERFLOW during compilation.

`-Wunused-labels'
     Warn whenever a label is defined but never referenced.

`-Werror'
     Turns all warnings into errors.

`-W'
     Turns on "extra warnings" and, if optimization is specified via
     `-O', the `-Wuninitialized' option.  (This might change in future
     versions of `gfortran'

   *Note Options to Request or Suppress Warnings: (gcc)Warning Options,
for information on more options offered by the GBE shared by
`gfortran', `gcc' and other GNU compilers.

   Some of these have no effect when compiling programs written in
Fortran.


File: gfortran.info,  Node: Debugging Options,  Next: Directory Options,  Prev: Warning Options,  Up: Invoking GFORTRAN

4.4 Options for Debugging Your Program or GNU Fortran
=====================================================

GNU Fortran has various special options that are used for debugging
either your program or `gfortran'

`-fdump-parse-tree'
     Output the internal parse tree before starting code generation.
     Only really useful for debugging gfortran itself.

   *Note Options for Debugging Your Program or GCC: (gcc)Debugging
Options, for more information on debugging options.


File: gfortran.info,  Node: Directory Options,  Next: Code Gen Options,  Prev: Debugging Options,  Up: Invoking GFORTRAN

4.5 Options for Directory Search
================================

There options affect how affect how `gfortran' searches for files
specified via the `INCLUDE' directive, and where it searches for
previously compiled modules.

   It also affects the search paths used by `cpp' when used to
preprocess Fortran source.

`-IDIR'
     These affect interpretation of the `INCLUDE' directive (as well as
     of the `#include' directive of the `cpp' preprocessor).

     Also note that the general behavior of `-I' and `INCLUDE' is
     pretty much the same as of `-I' with `#include' in the `cpp'
     preprocessor, with regard to looking for `header.gcc' files and
     other such things.

     This path is also used to search for `.mod' files when previously
     compiled modules are required by a `USE' statement.

     *Note Options for Directory Search: (gcc)Directory Options, for
     information on the `-I' option.

`-MDIR'

`-JDIR'
     This option specifies where to put `.mod' files for compiled
     modules.  It is also added to the list of directories to searched
     by an `USE' statement.

     The default is the current directory.

     `-J' is an alias for `-M' to avoid conflicts with existing GCC
     options.


File: gfortran.info,  Node: Code Gen Options,  Next: Environment Variables,  Prev: Directory Options,  Up: Invoking GFORTRAN

4.6 Options for Code Generation Conventions
===========================================

These machine-independent options control the interface conventions
used in code generation.

   Most of them have both positive and negative forms; the negative form
of `-ffoo' would be `-fno-foo'.  In the table below, only one of the
forms is listed--the one which is not the default.  You can figure out
the other form by either removing `no-' or adding it.

`-fno-automatic'
     Treat each program unit as if the `SAVE' statement was specified
     for every local variable and array referenced in it. Does not
     affect common blocks. (Some Fortran compilers provide this option
     under the name `-static'.)

`-ff2c'
     Generate code designed to be compatible with code generated by
     `g77' and `f2c'.

     The calling conventions used by `g77' (originally implemented in
     `f2c') require functions that return type default `REAL' to
     actually return the C type `double', and functions that return
     type `COMPLEX' to return the values via an extra argument in the
     calling sequence that points to where to store the return value.
     Under the default GNU calling conventions, such functions simply
     return their results as they would in GNU C - default `REAL'
     functions return the C type `float', and `COMPLEX' functions
     return the GNU C type `complex'.  Additionally, this option
     implies the `-fsecond-underscore' option, unless
     `-fno-second-underscore' is explicitly requested.

     This does not affect the generation of code that interfaces with
     the `libgfortran' library.

     _Caution:_ It is not a good idea to mix Fortran code compiled with
     `-ff2c' with code compiled with the default `-fno-f2c' calling
     conventions as, calling `COMPLEX' or default `REAL' functions
     between program parts which were compiled with different calling
     conventions will break at execution time.

     _Caution:_ This will break code which passes intrinsic functions
     of type default `REAL' or `COMPLEX' as actual arguments, as the
     library implementations use the `-fno-f2c' calling conventions.

`-fno-underscoring'
     Do not transform names of entities specified in the Fortran source
     file by appending underscores to them.

     With `-funderscoring' in effect, `gfortran' appends one underscore
     to external names with no underscores.

     This is done to ensure compatibility with code produced by many
     UNIX Fortran compilers.

     _Caution_: The default behavior of `gfortran' is incompatible with
     `f2c' and `g77', please use the `-ff2c' option if you want object
     files compiled with `gfortran' to be compatible with object code
     created with these tools.

     Use of `-fno-underscoring' is not recommended unless you are
     experimenting with issues such as integration of (GNU) Fortran into
     existing system environments (vis-a-vis existing libraries, tools,
     and so on).

     For example, with `-funderscoring', and assuming other defaults
     like `-fcase-lower' and that `j()' and `max_count()' are external
     functions while `my_var' and `lvar' are local variables, a
     statement like

          I = J() + MAX_COUNT (MY_VAR, LVAR)

     is implemented as something akin to:

          i = j_() + max_count__(&my_var__, &lvar);

     With `-fno-underscoring', the same statement is implemented as:

          i = j() + max_count(&my_var, &lvar);

     Use of `-fno-underscoring' allows direct specification of
     user-defined names while debugging and when interfacing `gfortran'
     code with other languages.

     Note that just because the names match does _not_ mean that the
     interface implemented by `gfortran' for an external name matches
     the interface implemented by some other language for that same
     name.  That is, getting code produced by `gfortran' to link to
     code produced by some other compiler using this or any other
     method can be only a small part of the overall solution--getting
     the code generated by both compilers to agree on issues other than
     naming can require significant effort, and, unlike naming
     disagreements, linkers normally cannot detect disagreements in
     these other areas.

     Also, note that with `-fno-underscoring', the lack of appended
     underscores introduces the very real possibility that a
     user-defined external name will conflict with a name in a system
     library, which could make finding unresolved-reference bugs quite
     difficult in some cases--they might occur at program run time, and
     show up only as buggy behavior at run time.

     In future versions of `gfortran' we hope to improve naming and
     linking issues so that debugging always involves using the names
     as they appear in the source, even if the names as seen by the
     linker are mangled to prevent accidental linking between
     procedures with incompatible interfaces.

`-fsecond-underscore'
     By default, `gfortran' appends an underscore to external names.
     If this option is used `gfortran' appends two underscores to names
     with underscores and one underscore to external names with no
     underscores.  (`gfortran' also appends two underscores to internal
     names with underscores to avoid naming collisions with external
     names.

     This option has no effect if `-fno-underscoring' is in effect.  It
     is implied by the `-ff2c' option.

     Otherwise, with this option, an external name such as `MAX_COUNT'
     is implemented as a reference to the link-time external symbol
     `max_count__', instead of `max_count_'.  This is required for
     compatibility with `g77' and `f2c', and is implied by use of the
     `-ff2c' option.

`-fbounds-check'
     Enable generation of run-time checks for array subscripts and
     against the declared minimum and maximum values.  It also checks
     array indices for assumed and deferred shape arrays against the
     actual allocated bounds.

     In the future this may also include other forms of checking, eg.
     checking substring references.

`-fmax-stack-var-size=N'
     This option specifies the size in bytes of the largest array that
     will be put on the stack.

     This option currently only affects local arrays declared with
     constant bounds, and may not apply to all character variables.
     Future versions of `gfortran' may improve this behavior.

     The default value for N is 32768.

`-fpackderived'
     This option tells gfortran to pack derived type members as closely
     as possible.  Code compiled with this option is likely to be
     incompatible with code compiled without this option, and may
     execute slower.

`-frepack-arrays'
     In some circumstances `gfortran' may pass assumed shape array
     sections via a descriptor describing a discontiguous area of
     memory.  This option adds code to the function prologue to repack
     the data into a contiguous block at runtime.

     This should result in faster accesses to the array.  However it
     can introduce significant overhead to the function call,
     especially  when the passed data is discontiguous.

   *Note Options for Code Generation Conventions: (gcc)Code Gen
Options, for information on more options offered by the GBE shared by
`gfortran' `gcc' and other GNU compilers.


File: gfortran.info,  Node: Environment Variables,  Prev: Code Gen Options,  Up: Invoking GFORTRAN

4.7 Environment Variables Affecting GNU Fortran
===============================================

GNU Fortran 95 currently does not make use of any environment variables
to control its operation above and beyond those that affect the
operation of `gcc'.

   *Note Environment Variables Affecting GCC: (gcc)Environment
Variables, for information on environment variables.


File: gfortran.info,  Node: Project Status,  Next: Contributing,  Prev: Invoking GFORTRAN,  Up: Top

5 Project Status
****************

     As soon as gfortran can parse all of the statements correctly, it
     will be in the "larva" state.  When we generate code, the "puppa"
     state.  When gfortran is done, we'll see if it will be a beautiful
     butterfly, or just a big bug....

     -Andy Vaught, April 2000

   The start of the GNU Fortran 95 project was announced on the GCC
homepage in March 18, 2000 (even though Andy had already been working
on it for a while, or course).

   Gfortran is currently reaching the stage where is is able to compile
real world programs.  However it is still under development and has
many rough edges.

* Menu:

* Compiler Status::
* Library Status::
* Proposed Extensions::


File: gfortran.info,  Node: Compiler Status,  Next: Library Status,  Up: Project Status

5.1 Compiler Status
===================

_Front end_
     This is the part of gfortran which parses a source file, verifies
     that it is valid Fortran 95, performs compile time replacement of
     constants (PARAMETER variables) and reads and generate module
     files. This is almost complete. Every Fortran 95 source should be
     accepted, and most none-Fortran 95 source should be rejected. If
     you find a source file where this is not true, please tell us. You
     can use the -fsyntax-only switch to make gfortran quit after
     running the front end, effectively reducing it to a syntax checker.

_Middle end interface_
     These are the parts of gfortran that take the parse tree generated
     by the front end and translate it to the GENERIC form required by
     the GCC back end. Work is ongoing in these parts of gfortran, but
     a large part has already been completed.


File: gfortran.info,  Node: Library Status,  Next: Proposed Extensions,  Prev: Compiler Status,  Up: Project Status

5.2 Library Status
==================

Some intrinsic functions map directly to library functions, and in most
cases the name of the library function used depends on the type of the
arguments.  For some intrinsics we generate inline code, and for others,
such as sin, cos and sqrt, we rely on the backend to use special
instructions in the floating point unit of the CPU if available, or to
fall back to a call to libm if these are not available.

   Implementation of some non-elemental intrinsic functions (eg.
DOT_PRODUCT, AVERAGE) is not yet optimal. This is hard because we have
to make decisions whether to use inline code (good for small arrays as
no function call overhead occurs) or generate function calls (good for
large arrays as it allows use of hand-optimized assembly routines, SIMD
instructions, etc.)

   The IO library is still under development.  The following features
should be usable for real programs:

   - List directed

   - Unformatted sequential

   Usable with bugs:

   - Formatted sequential ('T' edit descriptor, and others)

   Not recommended:

   - Unformatted direct access

   - Formatted direct access

   Many Fortran programs only use a small subset of the available IO
capabilities, so your mileage may vary.


File: gfortran.info,  Node: Proposed Extensions,  Prev: Library Status,  Up: Project Status

5.3 Proposed Extensions
=======================

Here's a list of proposed extensions for `gfortran', in no particular
order.  Most of these are necessary to be fully compatible with
existing Fortran compilers, but they are not part of the official J3
Fortran 95 standard.

5.3.1 Compiler extensions:
--------------------------

   * Flag for defining the kind number for default logicals.

   * User-specified alignment rules for structures.

   * Flag to generate a `Makefile' info.

   * Automatically extend single precision constants to double.

   * Cray pointers (this was high on the `g77' wishlist).

   * Compile code that conserves memory by dynamically allocating
     common and module storage either on stack or heap.

   * Flag to cause the compiler to distinguish between upper and lower
     case names.  The Fortran 95 standard does not distinguish them.

   * Compile flag to generate code for array conformance checking
     (suggest -CC).

   * User control of symbol names (underscores, etc).

   * Compile setting for maximum size of stack frame size before
     spilling parts to static or heap.

   * Flag to force local variables into static space.

   * Flag to force local variables onto stack.

   * Flag to compile lines beginning with "D".

   * Flag to ignore lines beginning with "D".

   * Flag for maximum errors before ending compile.

   * Generate code to check for null pointer dereferences - prints
     locus of dereference instead of segfaulting.  There was some
     discussion about this option in the g95 development mailing list.

   * Allow setting default unit number.

   * Option to initialize of otherwise uninitialized integer and
     floating point variables.

   * Support for OpenMP directives.  This also requires support from
     the runtime library and the rest of the compiler.

   * Support for Fortran 200x. This includes several new features
     including floating point exceptions, extended use of allocatable
     arrays, C interoperability, Parameterizer data types and function
     pointers.

5.3.2 Environment Options
-------------------------

   * Pluggable library modules for random numbers, linear algebra.  LA
     should use BLAS calling conventions.

   * Environment variables controlling actions on arithmetic exceptions
     like overflow, underflow, precision loss - Generate NaN, abort,
     default.  action.

   * Set precision for fp units that support it (i387).

   * Variables for setting fp rounding mode.

   * Variable to fill uninitialized variables with a user-defined bit
     pattern.

   * Environment variable controlling filename that is opened for that
     unit number.

   * Environment variable to clear/trash memory being freed.

   * Environment variable to control tracing of allocations and frees.

   * Environment variable to display allocated memory at normal program
     end.

   * Environment variable for filename for * IO-unit.

   * Environment variable for temporary file directory.

   * Environment variable forcing standard output to be line buffered
     (unix).

   * Variable for swapping endianness during unformatted read.

   * Variable for swapping Endianness during unformatted write.


File: gfortran.info,  Node: Extensions,  Next: Intrinsic Procedures,  Prev: Standards,  Up: Top

6 Extensions
************

`gfortran' implements a number of extensions over standard Fortran.
This chapter contains information on their syntax and meaning.  There
are currently two categories of `gfortran' extensions, those that
provide functionality beyond that provided by any standard, and those
that are supported by `gfortran' purely for backward compatibility with
legacy compilers.  By default, `-std=gnu' allows the compiler to accept
both types of extensions, but to warn about the use of the latter.
Specifying either `-std=f95' or `-std=f2003' disables both types of
extensions, and `-std=legacy' allows both without warning.

* Menu:

* Old-style kind specifications::
* Old-style variable initialization::
* Extensions to namelist::
* Implicitly interconvert LOGICAL and INTEGER::
* Hollerith constants support::


File: gfortran.info,  Node: Old-style kind specifications,  Next: Old-style variable initialization,  Up: Extensions

6.1 Old-style kind specifications
=================================

`gfortran' allows old-style kind specifications in declarations. These
look like:
           TYPESPEC*k x,y,z
   where `TYPESPEC' is a basic type, and where `k' is a valid kind
number for that type. The statement then declares `x', `y' and `z' to
be of type `TYPESPEC' with kind `k'. In other words, it is equivalent
to the standard conforming declaration
           TYPESPEC(k) x,y,z


File: gfortran.info,  Node: Old-style variable initialization,  Next: Extensions to namelist,  Prev: Old-style kind specifications,  Up: Extensions

6.2 Old-style variable initialization
=====================================

`gfortran' allows old-style initialization of variables of the form:
           INTEGER*4 i/1/,j/2/
           REAL*8 x(2,2) /3*0.,1./
   These are only allowed in declarations without double colons (`::'),
as these were introduced in Fortran 90 which also introduced a new
syntax for variable initializations. The syntax for the individual
initializers is as for the `DATA' statement, but unlike in a `DATA'
statement, an initializer only applies to the variable immediately
preceding. In other words, something like `INTEGER I,J/2,3/' is not
valid.

   Examples of standard conforming code equivalent to the above
example, are:
     ! Fortran 90
           INTEGER(4) :: i = 1, j = 2
           REAL(8) :: x(2,2) = RESHAPE((/0.,0.,0.,1./),SHAPE(x))
     ! Fortran 77
           INTEGER  i, j
           DOUBLE PRECISION x(2,2)
           DATA i,j,x /1,2,3*0.,1./


File: gfortran.info,  Node: Extensions to namelist,  Next: Implicitly interconvert LOGICAL and INTEGER,  Prev: Old-style variable initialization,  Up: Extensions

6.3 Extensions to namelist
==========================

`gfortran' fully supports the fortran95 standard for namelist io
including array qualifiers, substrings and fully qualified derived
types.  The output from a namelist write is compatible with namelist
read.  The output has all names in upper case and indentation to column
1 after the namelist name.  Two extensions are permitted:

   Old-style use of $ instead of &
     $MYNML
      X(:)%Y(2) = 1.0 2.0 3.0
      CH(1:4) = "abcd"
     $END

   It should be noticed that the default terminator is / rather than
&END.

   Querying of the namelist when inputting from stdin. After at least
one space, entering ? sends to stdout the namelist name and the names of
the variables in the namelist:
     ?

     &mynml
      x
      x%y
      ch
     &end

   Entering =? outputs the namelist to stdout, as if WRITE (*,NML =
mynml) had been called:
     =?

     &MYNML
      X(1)%Y=  0.000000    ,  1.000000    ,  0.000000    ,
      X(2)%Y=  0.000000    ,  2.000000    ,  0.000000    ,
      X(3)%Y=  0.000000    ,  3.000000    ,  0.000000    ,
      CH=abcd,  /

   To aid this dialog, when input is from stdin, errors produce send
their messages to stderr and execution continues, even if IOSTAT is set.

   PRINT namelist is permitted.  This causes an error if -std=f95 is
used.
     PROGRAM test_print
       REAL, dimension (4)  ::  x = (/1.0, 2.0, 3.0, 4.0/)
       NAMELIST /mynml/ x
       PRINT mynml
     END PROGRAM test_print


File: gfortran.info,  Node: Implicitly interconvert LOGICAL and INTEGER,  Next: Hollerith constants support,  Prev: Extensions to namelist,  Up: Extensions

6.4 Implicitly interconvert LOGICAL and INTEGER
===============================================

As a GNU extension for backwards compatability with other compilers,
`gfortran' allows the implicit conversion of LOGICALs to INTEGERs and
vice versa.  When converting from a LOGICAL to an INTEGER, the numeric
value of `.FALSE.' is zero, and that of `.TRUE.' is one.  When
converting from INTEGER to LOGICAL, the value zero is interpreted as
`.FALSE.' and any non-zero value is interpreted as `.TRUE.'.

            INTEGER*4 i
            i = .FALSE.


File: gfortran.info,  Node: Hollerith constants support,  Prev: Implicitly interconvert LOGICAL and INTEGER,  Up: Extensions

6.5 Hollerith constants support
===============================

A Hollerith constant is a string of characters preceded by the letter
`H' or `h', and there must be an literal, unsigned, nonzero default
integer constant indicating the number of characters in the string.
Hollerith constants are stored as byte strings, one character per byte.

   `gfortran' supports Hollerith constants. They can be used as the
right hands in the `DATA' statement and `ASSIGN' statement, also as the
arguments. The left hands can be of Integer, Real, Complex and Logical
type.  The constant will be padded or trancated to fit the size of left
hand.

   Valid Hollerith constants examples:
     complex*16 x(2)
     data x /16Habcdefghijklmnop, 16Hqrstuvwxyz012345/
     call foo (4H abc)
     x(1) = 16Habcdefghijklmnop

   Invalid Hollerith constants examples:
     integer*4 a
     a = 8H12345678 ! The Hollerith constant is too long. It will be truncated.
     a = 0H         ! At least one character needed.


File: gfortran.info,  Node: Intrinsic Procedures,  Next: Index,  Prev: Extensions,  Up: Top

7 Intrinsic Procedures
**********************

This portion of the document is incomplete and undergoing massive
expansion and editing.  All contributions and corrections are strongly
encouraged.

* Menu:

* Introduction:         Introduction
* `ABORT':         ABORT,     Abort the program
* `ABS':           ABS,       Absolute value
* `ACHAR':         ACHAR,     Character in ASCII collating sequence
* `ACOS':          ACOS,      Arc cosine function
* `ADJUSTL':       ADJUSTL,   Left adjust a string
* `ADJUSTR':       ADJUSTR,   Right adjust a string
* `AIMAG':         AIMAG,     Imaginary part of complex number
* `AINT':          AINT,      Truncate to a whole number
* `ALL':           ALL,       Determine if all values are true
* `ALLOCATED':     ALLOCATED, Status of allocatable entity
* `ANINT':         ANINT,     Nearest whole number
* `ANY':           ANY,       Determine if any values are true
* `ASIN':          ASIN,      Arcsine function
* `ASSOCIATED':    ASSOCIATED, Status of a pointer or pointer/target pair
* `ATAN':          ATAN,      Arctangent function
* `ATAN2':         ATAN2,     Arctangent function
* `BESJ0':         BESJ0,     Bessel function of the first kind of order 0
* `BESJ1':         BESJ1,     Bessel function of the first kind of order 1
* `BESJN':         BESJN,     Bessel function of the first kind
* `BESY0':         BESY0,     Bessel function of the second kind of order 0
* `BESY1':         BESY1,     Bessel function of the second kind of order 1
* `BESYN':         BESYN,     Bessel function of the second kind
* `BIT_SIZE':      BIT_SIZE,  Bit size inquiry function
* `BTEST':         BTEST,     Bit test function
* `CEILING':       CEILING,   Integer ceiling function
* `CHAR':          CHAR,      Character conversion function
* `CMPLX':         CMPLX,     Complex conversion function
* `COMMAND_ARGUMENT_COUNT': COMMAND_ARGUMENT_COUNT,  Command line argument count
* `CONJG':         CONJG,     Complex conjugate function
* `COS':           COS,       Cosine function
* `COSH':          COSH,      Hyperbolic cosine function
* `COUNT':         COUNT,     Count occurrences of .TRUE. in an array
* `CPU_TIME':      CPU_TIME,  CPU time subroutine
* `CSHIFT':        CSHIFT,    Circular array shift function
* `CTIME':         CTIME,     Subroutine (or function) to convert a time into a string
* `DATE_AND_TIME': DATE_AND_TIME, Date and time subroutine
* `DBLE':          DBLE,      Double precision conversion function
* `DCMPLX':        DCMPLX,    Double complex conversion function
* `DFLOAT':        DFLOAT,    Double precision conversion function
* `DIGITS':        DIGITS,    Significant digits function
* `DIM':           DIM,       Dim function
* `DOT_PRODUCT':   DOT_PRODUCT, Dot product function
* `DPROD':         DPROD,     Double product function
* `DREAL':         DREAL,     Double real part function
* `DTIME':         DTIME,     Execution time subroutine (or function)
* `EOSHIFT':       EOSHIFT,   End-off shift function
* `EPSILON':       EPSILON,   Epsilon function
* `ERF':           ERF,       Error function
* `ERFC':          ERFC,      Complementary error function
* `ETIME':         ETIME,     Execution time subroutine (or function)
* `EXIT':          EXIT,      Exit the program with status.
* `EXP':           EXP,       Exponential function
* `EXPONENT':      EXPONENT,  Exponent function
* `FDATE':         FDATE,     Subroutine (or function) to get the current time as a string
* `FLOOR':         FLOOR,     Integer floor function
* `FNUM':          FNUM,      File number function
* `LOG':           LOG,       Logarithm function
* `LOG10':         LOG10,     Base 10 logarithm function
* `SECNDS':        SECNDS,    Time function
* `SQRT':          SQRT,      Square-root function
* `SIN':           SIN,       Sine function
* `SINH':          SINH,      Hyperbolic sine function
* `TAN':           TAN,       Tangent function
* `TANH':          TANH,      Hyperbolic tangent function


File: gfortran.info,  Node: Introduction,  Next: ABORT,  Up: Intrinsic Procedures

7.1 Introduction to intrinsic procedures
========================================

Gfortran provides a rich set of intrinsic procedures that includes all
the intrinsic procedures required by the Fortran 95 standard, a set of
intrinsic procedures for backwards compatibility with Gnu Fortran 77
(i.e., `g77'), and a small selection of intrinsic procedures from the
Fortran 2003 standard.  Any description here, which conflicts with a
description in either the Fortran 95 standard or the Fortran 2003
standard, is unintentional and the standard(s) should be considered
authoritative.

   The enumeration of the `KIND' type parameter is processor defined in
the Fortran 95 standard.  Gfortran defines the default integer type and
default real type by `INTEGER(KIND=4)' and `REAL(KIND=4)',
respectively.  The standard mandates that both data types shall have
another kind, which have more precision.  On typical target
architectures supported by `gfortran', this kind type parameter is
`KIND=8'.  Hence, `REAL(KIND=8)' and `DOUBLE PRECISION' are equivalent.
In the description of generic intrinsic procedures, the kind type
parameter will be specified by `KIND=*', and in the description of
specific names for an intrinsic procedure the kind type parameter will
be explicitly given (e.g., `REAL(KIND=4)' or `REAL(KIND=8)').  Finally,
for brevity the optional `KIND=' syntax will be omitted.

   Many of the intrinsics procedures take one or more optional
arguments.  This document follows the convention used in the Fortran 95
standard, and denotes such arguments by square brackets.

   `Gfortran' offers the `-std=f95' and `-std=gnu' options, which can
be used to restrict the set of intrinsic procedures to a given
standard.  By default, `gfortran' sets the `-std=gnu' option, and so
all intrinsic procedures described here are accepted.  There is one
caveat.  For a select group of intrinsic procedures, `g77' implemented
both a function and a subroutine.  Both classes have been implemented
in `gfortran' for backwards compatibility with `g77'.  It is noted here
that these functions and subroutines cannot be intermixed in a given
subprogram.  In the descriptions that follow, the applicable option(s)
is noted.


File: gfortran.info,  Node: ABORT,  Next: ABS,  Prev: Introduction,  Up: Intrinsic Procedures

7.2 `ABORT' -- Abort the program
================================

_Description_:
     `ABORT' causes immediate termination of the program.  On operating
     systems that support a core dump, `ABORT' will produce a core dump,
     which is suitable for debugging purposes.

_Option_:
     gnu

_Class_:
     non-elemental subroutine

_Syntax_:
     `CALL ABORT'

_Return value_:
     Does not return.

_Example_:
          program test_abort
            integer :: i = 1, j = 2
            if (i /= j) call abort
          end program test_abort


File: gfortran.info,  Node: ABS,  Next: ACHAR,  Prev: ABORT,  Up: Intrinsic Procedures

7.3 `ABS' -- Absolute value
===========================

_Description_:
     `ABS(X)' computes the absolute value of `X'.

_Option_:
     f95, gnu

_Class_:
     elemental function

_Syntax_:
     `X = ABS(X)'

_Arguments_:
     X          The type of the argument shall be an `INTEGER(*)',
                `REAL(*)', or `COMPLEX(*)'.

_Return value_:
     The return value is of the same type and kind as the argument
     except the return value is `REAL(*)' for a `COMPLEX(*)' argument.

_Example_:
          program test_abs
            integer :: i = -1
            real :: x = -1.e0
            complex :: z = (-1.e0,0.e0)
            i = abs(i)
            x = abs(x)
            x = abs(z)
          end program test_abs

_Specific names_:
     Name             Argument         Return type      Option
     `CABS(Z)'        `COMPLEX(4) Z'   `REAL(4)'        f95, gnu
     `DABS(X)'        `REAL(8)    X'   `REAL(8)'        f95, gnu
     `IABS(I)'        `INTEGER(4) I'   `INTEGER(4)'     f95, gnu
     `ZABS(Z)'        `COMPLEX(8) Z'   `COMPLEX(8)'     gnu
     `CDABS(Z)'       `COMPLEX(8) Z'   `COMPLEX(8)'     gnu


File: gfortran.info,  Node: ACHAR,  Next: ACOS,  Prev: ABS,  Up: Intrinsic Procedures

7.4 `ACHAR' -- Character in ASCII collating sequence
====================================================

_Description_:
     `ACHAR(I)' returns the character located at position `I' in the
     ASCII collating sequence.

_Option_:
     f95, gnu

_Class_:
     elemental function

_Syntax_:
     `C = ACHAR(I)'

_Arguments_:
     I          The type shall be `INTEGER(*)'.

_Return value_:
     The return value is of type `CHARACTER' with a length of one.  The
     kind type parameter is the same as  `KIND('A')'.

_Example_:
          program test_achar
            character c
            c = achar(32)
          end program test_achar


File: gfortran.info,  Node: ACOS,  Next: ADJUSTL,  Prev: ACHAR,  Up: Intrinsic Procedures

7.5 `ACOS' -- Arc cosine function
=================================

_Description_:
     `ACOS(X)' computes the arc cosine of X.

_Option_:
     f95, gnu

_Class_:
     elemental function

_Syntax_:
     `X = ACOS(X)'

_Arguments_:
     X          The type shall be `REAL(*)' with a magnitude that is
                less than one.

_Return value_:
     The return value is of type `REAL(*)' and it lies in the range  0
     \leq \arccos (x) \leq \pi.  The kind type parameter is the same as
     X.

_Example_:
          program test_acos
            real(8) :: x = 0.866_8
            x = achar(x)
          end program test_acos

_Specific names_:
     Name             Argument         Return type      Option
     `DACOS(X)'       `REAL(8) X'      `REAL(8)'        f95, gnu


File: gfortran.info,  Node: ADJUSTL,  Next: ADJUSTR,  Prev: ACOS,  Up: Intrinsic Procedures

7.6 `ADJUSTL' -- Left adjust a string
=====================================

_Description_:
     `ADJUSTL(STR)' will left adjust a string by removing leading
     spaces.  Spaces are inserted at the end of the string as needed.

_Option_:
     f95, gnu

_Class_:
     elemental function

_Syntax_:
     `STR = ADJUSTL(STR)'

_Arguments_:
     STR        The type shall be `CHARACTER'.

_Return value_:
     The return value is of type `CHARACTER' where leading spaces are
     removed and the same number of spaces are inserted on the end of
     STR.

_Example_:
          program test_adjustl
            character(len=20) :: str = '   gfortran'
            str = adjustl(str)
            print *, str
          end program test_adjustl


File: gfortran.info,  Node: ADJUSTR,  Next: AIMAG,  Prev: ADJUSTL,  Up: Intrinsic Procedures

7.7 `ADJUSTR' -- Right adjust a string
======================================

_Description_:
     `ADJUSTR(STR)' will right adjust a string by removing trailing
     spaces.  Spaces are inserted at the start of the string as needed.

_Option_:
     f95, gnu

_Class_:
     elemental function

_Syntax_:
     `STR = ADJUSTR(STR)'

_Arguments_:
     STR        The type shall be `CHARACTER'.

_Return value_:
     The return value is of type `CHARACTER' where trailing spaces are
     removed and the same number of spaces are inserted at the start of
     STR.

_Example_:
          program test_adjustr
            character(len=20) :: str = 'gfortran'
            str = adjustr(str)
            print *, str
          end program test_adjustr


File: gfortran.info,  Node: AIMAG,  Next: AINT,  Prev: ADJUSTR,  Up: Intrinsic Procedures

7.8 `AIMAG' -- Imaginary part of complex number
===============================================

_Description_:
     `AIMAG(Z)' yields the imaginary part of complex argument `Z'.

_Option_:
     f95, gnu

_Class_:
     elemental function

_Syntax_:
     `X = AIMAG(Z)'

_Arguments_:
     Z          The type of the argument shall be `COMPLEX(*)'.

_Return value_:
     The return value is of type real with the kind type parameter of
     the argument.

_Example_:
          program test_aimag
            complex(4) z4
            complex(8) z8
            z4 = cmplx(1.e0_4, 0.e0_4)
            z8 = cmplx(0.e0_8, 1.e0_8)
            print *, aimag(z4), dimag(z8)
          end program test_aimag

_Specific names_:
     Name             Argument         Return type      Option
     `DIMAG(Z)'       `COMPLEX(8) Z'   `REAL(8)'        f95, gnu


File: gfortran.info,  Node: AINT,  Next: ALL,  Prev: AIMAG,  Up: Intrinsic Procedures

7.9 `AINT' -- Imaginary part of complex number
==============================================

_Description_:
     `AINT(X [, KIND])' truncates its argument to a whole number.

_Option_:
     f95, gnu

_Class_:
     elemental function

_Syntax_:
     `X = AINT(X)' `X = AINT(X, KIND)'

_Arguments_:
     X          The type of the argument shall be `REAL(*)'.
     KIND       (Optional) KIND shall be a scalar integer
                initialization expression.

_Return value_:
     The return value is of type real with the kind type parameter of
     the argument if the optional KIND is absent; otherwise, the kind
     type parameter will be given by KIND.  If the magnitude of X is
     less than one, then `AINT(X)' returns zero.  If the magnitude is
     equal to or greater than one, then it returns the largest whole
     number that does not exceed its magnitude.  The sign is the same
     as the sign of X.

_Example_:
          program test_aint
            real(4) x4
            real(8) x8
            x4 = 1.234E0_4
            x8 = 4.321_8
            print *, aint(x4), dint(x8)
            x8 = aint(x4,8)
          end program test_aint

_Specific names_:
     Name             Argument         Return type      Option
     `DINT(X)'        `REAL(8) X'      `REAL(8)'        f95, gnu


File: gfortran.info,  Node: ALL,  Next: ALLOCATED,  Prev: AINT,  Up: Intrinsic Procedures

7.10 `ALL' -- All values in MASK along DIM are true
===================================================

_Description_:
     `ALL(MASK [, DIM])' determines if all the values are true in MASK
     in the array along dimension DIM.

_Option_:
     f95, gnu

_Class_:
     transformational function

_Syntax_:
     `L = ALL(MASK)' `L = ALL(MASK, DIM)'

_Arguments_:
     MASK       The type of the argument shall be `LOGICAL(*)' and it
                shall not be scalar.
     DIM        (Optional) DIM shall be a scalar integer with a value
                that lies between one and the rank of MASK.

_Return value_:
     `ALL(MASK)' returns a scalar value of type `LOGICAL(*)' where the
     kind type parameter is the same as the kind type parameter of
     MASK.  If DIM is present, then `ALL(MASK, DIM)' returns an array
     with the rank of MASK minus 1.  The shape is determined from the
     shape of MASK where the DIM dimension is elided.

    (A)
          `ALL(MASK)' is true if all elements of MASK are true.  It
          also is true if MASK has zero size; otherwise, it is false.

    (B)
          If the rank of MASK is one, then `ALL(MASK,DIM)' is equivalent
          to `ALL(MASK)'.  If the rank is greater than one, then
          `ALL(MASK,DIM)' is determined by applying `ALL' to the array
          sections.

_Example_:
          program test_all
            logical l
            l = all((/.true., .true., .true./))
            print *, l
            call section
            contains
              subroutine section
                integer a(2,3), b(2,3)
                a = 1
                b = 1
                b(2,2) = 2
                print *, all(a .eq. b, 1)
                print *, all(a .eq. b, 2)
              end subroutine section
          end program test_all


File: gfortran.info,  Node: ALLOCATED,  Next: ANINT,  Prev: ALL,  Up: Intrinsic Procedures

7.11 `ALLOCATED' -- Status of an allocatable entity
===================================================

_Description_:
     `ALLOCATED(X)' checks the status of whether X is allocated.

_Option_:
     f95, gnu

_Class_:
     inquiry function

_Syntax_:
     `L = ALLOCATED(X)'

_Arguments_:
     X          The argument shall be an `ALLOCATABLE' array.

_Return value_:
     The return value is a scalar `LOGICAL' with the default logical
     kind type parameter.  If X is allocated, `ALLOCATED(X)' is
     `.TRUE.'; otherwise, it returns the `.TRUE.'

_Example_:
          program test_allocated
            integer :: i = 4
            real(4), allocatable :: x(:)
            if (allocated(x) .eqv. .false.) allocate(x(i)
          end program test_allocated


File: gfortran.info,  Node: ANINT,  Next: ANY,  Prev: ALLOCATED,  Up: Intrinsic Procedures

7.12 `ANINT' -- Imaginary part of complex number
================================================

_Description_:
     `ANINT(X [, KIND])' rounds its argument to the nearest whole
     number.

_Option_:
     f95, gnu

_Class_:
     elemental function

_Syntax_:
     `X = ANINT(X)' `X = ANINT(X, KIND)'

_Arguments_:
     X          The type of the argument shall be `REAL(*)'.
     KIND       (Optional) KIND shall be a scalar integer
                initialization expression.

_Return value_:
     The return value is of type real with the kind type parameter of
     the argument if the optional KIND is absent; otherwise, the kind
     type parameter will be given by KIND.  If X is greater than zero,
     then `ANINT(X)' returns `AINT(X+0.5)'.  If X is less than or equal
     to zero, then return `AINT(X-0.5)'.

_Example_:
          program test_anint
            real(4) x4
            real(8) x8
            x4 = 1.234E0_4
            x8 = 4.321_8
            print *, anint(x4), dnint(x8)
            x8 = anint(x4,8)
          end program test_anint

_Specific names_:
     Name             Argument         Return type      Option
     `DNINT(X)'       `REAL(8) X'      `REAL(8)'        f95, gnu


File: gfortran.info,  Node: ANY,  Next: ASIN,  Prev: ANINT,  Up: Intrinsic Procedures

7.13 `ANY' -- Any value in MASK along DIM is true
=================================================

_Description_:
     `ANY(MASK [, DIM])' determines if any of the values in the logical
     array MASK along dimension DIM are `.TRUE.'.

_Option_:
     f95, gnu

_Class_:
     transformational function

_Syntax_:
     `L = ANY(MASK)' `L = ANY(MASK, DIM)'

_Arguments_:
     MASK       The type of the argument shall be `LOGICAL(*)' and it
                shall not be scalar.
     DIM        (Optional) DIM shall be a scalar integer with a value
                that lies between one and the rank of MASK.

_Return value_:
     `ANY(MASK)' returns a scalar value of type `LOGICAL(*)' where the
     kind type parameter is the same as the kind type parameter of
     MASK.  If DIM is present, then `ANY(MASK, DIM)' returns an array
     with the rank of MASK minus 1.  The shape is determined from the
     shape of MASK where the DIM dimension is elided.

    (A)
          `ANY(MASK)' is true if any element of MASK is true;
          otherwise, it is false.  It also is false if MASK has zero
          size.

    (B)
          If the rank of MASK is one, then `ANY(MASK,DIM)' is equivalent
          to `ANY(MASK)'.  If the rank is greater than one, then
          `ANY(MASK,DIM)' is determined by applying `ANY' to the array
          sections.

_Example_:
          program test_any
            logical l
            l = any((/.true., .true., .true./))
            print *, l
            call section
            contains
              subroutine section
                integer a(2,3), b(2,3)
                a = 1
                b = 1
                b(2,2) = 2
                print *, any(a .eq. b, 1)
                print *, any(a .eq. b, 2)
              end subroutine section
          end program test_any


File: gfortran.info,  Node: ASIN,  Next: ASSOCIATED,  Prev: ANY,  Up: Intrinsic Procedures

7.14 `ASIN' -- Arcsine function
===============================

_Description_:
     `ASIN(X)' computes the arcsine of its X.

_Option_:
     f95, gnu

_Class_:
     elemental function

_Syntax_:
     `X = ASIN(X)'

_Arguments_:
     X          The type shall be `REAL(*)', and a magnitude that is
                less than one.

_Return value_:
     The return value is of type `REAL(*)' and it lies in the range
     -\pi / 2 \leq \arccos (x) \leq \pi / 2.  The kind type parameter
     is the same as X.

_Example_:
          program test_asin
            real(8) :: x = 0.866_8
            x = asin(x)
          end program test_asin

_Specific names_:
     Name             Argument         Return type      Option
     `DASIN(X)'       `REAL(8) X'      `REAL(8)'        f95, gnu


File: gfortran.info,  Node: ASSOCIATED,  Next: ATAN,  Prev: ASIN,  Up: Intrinsic Procedures

7.15 `ASSOCIATED' -- Status of a pointer or pointer/target pair
===============================================================

_Description_:
     `ASSOCIATED(PTR [, TGT])' determines the status of the pointer PTR
     or if PTR is associated with the target TGT.

_Option_:
     f95, gnu

_Class_:
     inquiry function

_Syntax_:
     `L = ASSOCIATED(PTR)' `L = ASSOCIATED(PTR [, TGT])'

_Arguments_:
     PTR        PTR shall have the `POINTER' attribute and it can be
                of any type.
     TGT        (Optional) TGT shall be a `POINTER' or a `TARGET'.
                It must have the same type, kind type parameter, and
                array rank as PTR.
     The status of neither PTR nor TGT can be undefined.

_Return value_:
     `ASSOCIATED(PTR)' returns a scalar value of type `LOGICAL(4)'.
     There are several cases:
    (A) If the optional TGT is not present, then `ASSOCIATED(PTR)'
          is true if PTR is associated with a target; otherwise, it
          returns false.

    (B) If TGT is present and a scalar target, the result is true if
          TGT is not a 0 sized storage sequence and the target
          associated with PTR occupies the same storage units.  If PTR
          is disassociated, then the result is false.

    (C) If TGT is present and an array target, the result is true if
          TGT and PTR have the same shape, are not 0 sized arrays, are
          arrays whose elements are not 0 sized storage sequences, and
          TGT and PTR occupy the same storage units in array element
          order.  As in case(B), the result is false, if PTR is
          disassociated.

    (D) If TGT is present and an scalar pointer, the result is true if
          target associated with PTR and the target associated with TGT
          are not 0 sized storage sequences and occupy the same storage
          units.  The result is false, if either TGT or PTR is
          disassociated.

    (E) If TGT is present and an array pointer, the result is true if
          target associated with PTR and the target associated with TGT
          have the same shape, are not 0 sized arrays, are arrays whose
          elements are not 0 sized storage sequences, and TGT and PTR
          occupy the same storage units in array element order.  The
          result is false, if either TGT or PTR is disassociated.

_Example_:
          program test_associated
             implicit none
             real, target  :: tgt(2) = (/1., 2./)
             real, pointer :: ptr(:)
             ptr => tgt
             if (associated(ptr)     .eqv. .false.) call abort
             if (associated(ptr,tgt) .eqv. .false.) call abort
          end program test_associated


File: gfortran.info,  Node: ATAN,  Next: ATAN2,  Prev: ASSOCIATED,  Up: Intrinsic Procedures

7.16 `ATAN' -- Arctangent function
==================================

_Description_:
     `ATAN(X)' computes the arctangent of X.

_Option_:
     f95, gnu

_Class_:
     elemental function

_Syntax_:
     `X = ATAN(X)'

_Arguments_:
     X          The type shall be `REAL(*)'.

_Return value_:
     The return value is of type `REAL(*)' and it lies in the range  -
     \pi / 2 \leq \arcsin (x) \leq \pi / 2.

_Example_:
          program test_atan
            real(8) :: x = 2.866_8
            x = atan(x)
          end program test_atan

_Specific names_:
     Name             Argument         Return type      Option
     `DATAN(X)'       `REAL(8) X'      `REAL(8)'        f95, gnu


File: gfortran.info,  Node: ATAN2,  Next: BESJ0,  Prev: ATAN,  Up: Intrinsic Procedures

7.17 `ATAN2' -- Arctangent function
===================================

_Description_:
     `ATAN2(Y,X)' computes the arctangent of the complex number X + i Y.

_Option_:
     f95, gnu

_Class_:
     elemental function

_Syntax_:
     `X = ATAN2(Y,X)'

_Arguments_:
     Y          The type shall be `REAL(*)'.
     X          The type and kind type parameter shall be the same as
                Y.  If Y is zero, then X must be nonzero.

_Return value_:
     The return value has the same type and kind type parameter as Y.
     It is the principle value of the complex number X + i Y.  If X is
     nonzero, then it lies in the range -\pi \le \arccos (x) \leq \pi.
     The sign is positive if Y is positive.  If Y is zero, then the
     return value is zero if X is positive and \pi if X is negative.
     Finally, if X is zero, then the magnitude of the result is \pi/2.

_Example_:
          program test_atan2
            real(4) :: x = 1.e0_4, y = 0.5e0_4
            x = atan2(y,x)
          end program test_atan2

_Specific names_:
     Name             Argument         Return type      Option
     `DATAN2(X)'      `REAL(8) X'      `REAL(8)'        f95, gnu


File: gfortran.info,  Node: BESJ0,  Next: BESJ1,  Prev: ATAN2,  Up: Intrinsic Procedures

7.18 `BESJ0' -- Bessel function of the first kind of order 0
============================================================

_Description_:
     `BESJ0(X)' computes the Bessel function of the first kind of order
     0 of X.

_Option_:
     gnu

_Class_:
     elemental function

_Syntax_:
     `X = BESJ0(X)'

_Arguments_:
     X          The type shall be `REAL(*)', and it shall be scalar.

_Return value_:
     The return value is of type `REAL(*)' and it lies in the range  -
     0.4027... \leq Bessel (0,x) \leq 1.

_Example_:
          program test_besj0
            real(8) :: x = 0.0_8
            x = besj0(x)
          end program test_besj0

_Specific names_:
     Name             Argument         Return type      Option
     `DBESJ0(X)'      `REAL(8) X'      `REAL(8)'        gnu


File: gfortran.info,  Node: BESJ1,  Next: BESJN,  Prev: BESJ0,  Up: Intrinsic Procedures

7.19 `BESJ1' -- Bessel function of the first kind of order 1
============================================================

_Description_:
     `BESJ1(X)' computes the Bessel function of the first kind of order
     1 of X.

_Option_:
     gnu

_Class_:
     elemental function

_Syntax_:
     `X = BESJ1(X)'

_Arguments_:
     X          The type shall be `REAL(*)', and it shall be scalar.

_Return value_:
     The return value is of type `REAL(*)' and it lies in the range  -
     0.5818... \leq Bessel (0,x) \leq 0.5818 .

_Example_:
          program test_besj1
            real(8) :: x = 1.0_8
            x = besj1(x)
          end program test_besj1

_Specific names_:
     Name             Argument         Return type      Option
     `DBESJ1(X)'      `REAL(8) X'      `REAL(8)'        gnu


File: gfortran.info,  Node: BESJN,  Next: BESY0,  Prev: BESJ1,  Up: Intrinsic Procedures

7.20 `BESJN' -- Bessel function of the first kind
=================================================

_Description_:
     `BESJN(N, X)' computes the Bessel function of the first kind of
     order N of X.

_Option_:
     gnu

_Class_:
     elemental function

_Syntax_:
     `Y = BESJN(N, X)'

_Arguments_:
     N          The type shall be `INTEGER(*)', and it shall be
                scalar.
     X          The type shall be `REAL(*)', and it shall be scalar.

_Return value_:
     The return value is a scalar of type `REAL(*)'.

_Example_:
          program test_besjn
            real(8) :: x = 1.0_8
            x = besjn(5,x)
          end program test_besjn

_Specific names_:
     Name             Argument         Return type      Option
     `DBESJN(X)'      `INTEGER(*) N'   `REAL(8)'        gnu
                      `REAL(8) X'                       


File: gfortran.info,  Node: BESY0,  Next: BESY1,  Prev: BESJN,  Up: Intrinsic Procedures

7.21 `BESY0' -- Bessel function of the second kind of order 0
=============================================================

_Description_:
     `BESY0(X)' computes the Bessel function of the second kind of
     order 0 of X.

_Option_:
     gnu

_Class_:
     elemental function

_Syntax_:
     `X = BESY0(X)'

_Arguments_:
     X          The type shall be `REAL(*)', and it shall be scalar.

_Return value_:
     The return value is a scalar of type `REAL(*)'.

_Example_:
          program test_besy0
            real(8) :: x = 0.0_8
            x = besy0(x)
          end program test_besy0

_Specific names_:
     Name             Argument         Return type      Option
     `DBESY0(X)'      `REAL(8) X'      `REAL(8)'        gnu


File: gfortran.info,  Node: BESY1,  Next: BESYN,  Prev: BESY0,  Up: Intrinsic Procedures

7.22 `BESY1' -- Bessel function of the second kind of order 1
=============================================================

_Description_:
     `BESY1(X)' computes the Bessel function of the second kind of
     order 1 of X.

_Option_:
     gnu

_Class_:
     elemental function

_Syntax_:
     `X = BESY1(X)'

_Arguments_:
     X          The type shall be `REAL(*)', and it shall be scalar.

_Return value_:
     The return value is a scalar of type `REAL(*)'.

_Example_:
          program test_besy1
            real(8) :: x = 1.0_8
            x = besy1(x)
          end program test_besy1

_Specific names_:
     Name             Argument         Return type      Option
     `DBESY1(X)'      `REAL(8) X'      `REAL(8)'        gnu


File: gfortran.info,  Node: BESYN,  Next: BIT_SIZE,  Prev: BESY1,  Up: Intrinsic Procedures

7.23 `BESYN' -- Bessel function of the second kind
==================================================

_Description_:
     `BESYN(N, X)' computes the Bessel function of the second kind of
     order N of X.

_Option_:
     gnu

_Class_:
     elemental function

_Syntax_:
     `Y = BESYN(N, X)'

_Arguments_:
     N          The type shall be `INTEGER(*)', and it shall be
                scalar.
     X          The type shall be `REAL(*)', and it shall be scalar.

_Return value_:
     The return value is a scalar of type `REAL(*)'.

_Example_:
          program test_besyn
            real(8) :: x = 1.0_8
            x = besyn(5,x)
          end program test_besyn

_Specific names_:
     Name             Argument         Return type      Option
     `DBESYN(N,X)'    `INTEGER(*) N'   `REAL(8)'        gnu
                      `REAL(8)    X'                    


File: gfortran.info,  Node: BIT_SIZE,  Next: BTEST,  Prev: BESYN,  Up: Intrinsic Procedures

7.24 `BIT_SIZE' -- Bit size inquiry function
============================================

_Description_:
     `BIT_SIZE(I)' returns the number of bits (integer precision plus
     sign bit) represented by the type of I.

_Option_:
     f95, gnu

_Class_:
     elemental function

_Syntax_:
     `I = BIT_SIZE(I)'

_Arguments_:
     I          The type shall be `INTEGER(*)'.

_Return value_:
     The return value is of type `INTEGER(*)'

_Example_:
          program test_bit_size
              integer :: i = 123
              integer :: size
              size = bit_size(i)
              print *, size
          end program test_bit_size


File: gfortran.info,  Node: BTEST,  Next: CEILING,  Prev: BIT_SIZE,  Up: Intrinsic Procedures

7.25 `BTEST' -- Bit test function
=================================

_Description_:
     `BTEST(I,POS)' returns logical `.TRUE.' if the bit at POS in I is
     set.

_Option_:
     f95, gnu

_Class_:
     elemental function

_Syntax_:
     `I = BTEST(I,POS)'

_Arguments_:
     I          The type shall be `INTEGER(*)'.
     POS        The type shall be `INTEGER(*)'.

_Return value_:
     The return value is of type `LOGICAL'

_Example_:
          program test_btest
              integer :: i = 32768 + 1024 + 64
              integer :: pos
              logical :: bool
              do pos=0,16
                  bool = btest(i, pos)
                  print *, pos, bool
              end do
          end program test_btest


File: gfortran.info,  Node: CEILING,  Next: CHAR,  Prev: BTEST,  Up: Intrinsic Procedures

7.26 `CEILING' -- Integer ceiling function
==========================================

_Description_:
     `CEILING(X)' returns the least integer greater than or equal to X.

_Option_:
     f95, gnu

_Class_:
     elemental function

_Syntax_:
     `I = CEILING(X[,KIND])'

_Arguments_:
     X          The type shall be `REAL(*)'.
     KIND       Optional scaler integer initialization expression.

_Return value_:
     The return value is of type `INTEGER(KIND)'

_Example_:
          program test_ceiling
              real :: x = 63.29
              real :: y = -63.59
              print *, ceiling(x) ! returns 64
              print *, ceiling(y) ! returns -63
          end program test_ceiling


File: gfortran.info,  Node: CHAR,  Next: CMPLX,  Prev: CEILING,  Up: Intrinsic Procedures

7.27 `CHAR' -- Character conversion function
============================================

_Description_:
     `CHAR(I,[KIND])' returns the character represented by the integer
     I.

_Option_:
     f95, gnu

_Class_:
     elemental function

_Syntax_:
     `C = CHAR(I[,KIND])'

_Arguments_:
     I          The type shall be `INTEGER(*)'.
     KIND       Optional scaler integer initialization expression.

_Return value_:
     The return value is of type `CHARACTER(1)'

_Example_:
          program test_char
              integer :: i = 74
              character(1) :: c
              c = char(i)
              print *, i, c ! returns 'J'
          end program test_char


File: gfortran.info,  Node: CMPLX,  Next: COMMAND_ARGUMENT_COUNT,  Prev: CHAR,  Up: Intrinsic Procedures

7.28 `CMPLX' -- Complex conversion function
===========================================

_Description_:
     `CMPLX(X,[Y,KIND])' returns a complex number where X is converted
     to the real component.  If Y is present it is converted to the
     imaginary component.  If Y is not present then the imaginary
     component is set to 0.0.  If X is complex then Y must not be
     present.

_Option_:
     f95, gnu

_Class_:
     elemental function

_Syntax_:
     `C = CMPLX(X[,Y,KIND])'

_Arguments_:
     X          The type may be `INTEGER(*)', `REAL(*)', or
                `COMPLEX(*)'.
     Y          Optional, allowed if X is not `COMPLEX(*)'.  May be
                `INTEGER(*)' or `REAL(*)'.
     KIND       Optional scaler integer initialization expression.

_Return value_:
     The return value is of type `COMPLEX(*)'

_Example_:
          program test_cmplx
              integer :: i = 42
              real :: x = 3.14
              complex :: z
              z = cmplx(i, x)
              print *, z, cmplx(x)
          end program test_cmplx


File: gfortran.info,  Node: COMMAND_ARGUMENT_COUNT,  Next: CONJG,  Prev: CMPLX,  Up: Intrinsic Procedures

7.29 `COMMAND_ARGUMENT_COUNT' -- Argument count function
========================================================

_Description_:
     `COMMAND_ARGUMENT_COUNT()' returns the number of arguments passed
     on the command line when the containing program was invoked.

_Option_:
     f2003, gnu

_Class_:
     non-elemental function

_Syntax_:
     `I = COMMAND_ARGUMENT_COUNT()'

_Arguments_:
     None       

_Return value_:
     The return value is of type `INTEGER(4)'

_Example_:
          program test_command_argument_count
              integer :: count
              count = command_argument_count()
              print *, count
          end program test_command_argument_count


File: gfortran.info,  Node: CONJG,  Next: COS,  Prev: COMMAND_ARGUMENT_COUNT,  Up: Intrinsic Procedures

7.30 `CONJG' -- Complex conjugate function
==========================================

_Description_:
     `CONJG(Z)' returns the conjugate of Z.  If Z is `(x, y)' then the
     result is `(x, -y)'

_Option_:
     f95, gnu

_Class_:
     elemental function

_Syntax_:
     `Z = CONJG(Z)'

_Arguments_:
     Z          The type shall be `COMPLEX(*)'.

_Return value_:
     The return value is of type `COMPLEX(*)'.

_Example_:
          program test_conjg
              complex :: z = (2.0, 3.0)
              complex(8) :: dz = (2.71_8, -3.14_8)
              z= conjg(z)
              print *, z
              dz = dconjg(dz)
              print *, dz
          end program test_conjg

_Specific names_:
     Name             Argument         Return type      Option
     `DCONJG(Z)'      `COMPLEX(8) Z'   `COMPLEX(8)'     gnu


File: gfortran.info,  Node: COS,  Next: COSH,  Prev: CONJG,  Up: Intrinsic Procedures

7.31 `COS' -- Cosine function
=============================

_Description_:
     `COS(X)' computes the cosine of X.

_Option_:
     f95, gnu

_Class_:
     elemental function

_Syntax_:
     `X = COS(X)'

_Arguments_:
     X          The type shall be `REAL(*)' or `COMPLEX(*)'.

_Return value_:
     The return value has the same type and kind as X.

_Example_:
          program test_cos
            real :: x = 0.0
            x = cos(x)
          end program test_cos

_Specific names_:
     Name             Argument         Return type      Option
     `DCOS(X)'        `REAL(8) X'      `REAL(8)'        f95, gnu
     `CCOS(X)'        `COMPLEX(4) X'   `COMPLEX(4)'     f95, gnu
     `ZCOS(X)'        `COMPLEX(8) X'   `COMPLEX(8)'     f95, gnu
     `CDCOS(X)'       `COMPLEX(8) X'   `COMPLEX(8)'     f95, gnu


File: gfortran.info,  Node: COSH,  Next: COUNT,  Prev: COS,  Up: Intrinsic Procedures

7.32 `COSH' -- Hyperbolic cosine function
=========================================

_Description_:
     `COSH(X)' computes the hyperbolic cosine of X.

_Option_:
     f95, gnu

_Class_:
     elemental function

_Syntax_:
     `X = COSH(X)'

_Arguments_:
     X          The type shall be `REAL(*)'.

_Return value_:
     The return value is of type `REAL(*)' and it is positive ( \cosh
     (x) \geq 0 .

_Example_:
          program test_cosh
            real(8) :: x = 1.0_8
            x = cosh(x)
          end program test_cosh

_Specific names_:
     Name             Argument         Return type      Option
     `DCOSH(X)'       `REAL(8) X'      `REAL(8)'        f95, gnu


File: gfortran.info,  Node: COUNT,  Next: CPU_TIME,  Prev: COSH,  Up: Intrinsic Procedures

7.33 `COUNT' -- Count function
==============================

_Description_:
     `COUNT(MASK[,DIM])' counts the number of `.TRUE.' elements of MASK
     along the dimension of DIM.  If DIM is omitted it is taken to be
     `1'.  DIM is a scaler of type `INTEGER' in the range of 1 /leq DIM
     /leq n) where n is the rank of MASK.

_Option_:
     f95, gnu

_Class_:
     transformational function

_Syntax_:
     `I = COUNT(MASK[,DIM])'

_Arguments_:
     MASK       The type shall be `LOGICAL'.
     DIM        The type shall be `INTEGER'.

_Return value_:
     The return value is of type `INTEGER' with rank equal to that of
     MASK.

_Example_:
          program test_count
              integer, dimension(2,3) :: a, b
              logical, dimension(2,3) :: mask
              a = reshape( (/ 1, 2, 3, 4, 5, 6 /), (/ 2, 3 /))
              b = reshape( (/ 0, 7, 3, 4, 5, 8 /), (/ 2, 3 /))
              print '(3i3)', a(1,:)
              print '(3i3)', a(2,:)
              print *
              print '(3i3)', b(1,:)
              print '(3i3)', b(2,:)
              print *
              mask = a.ne.b
              print '(3l3)', mask(1,:)
              print '(3l3)', mask(2,:)
              print *
              print '(3i3)', count(mask)
              print *
              print '(3i3)', count(mask, 1)
              print *
              print '(3i3)', count(mask, 2)
          end program test_count


File: gfortran.info,  Node: CPU_TIME,  Next: CSHIFT,  Prev: COUNT,  Up: Intrinsic Procedures

7.34 `CPU_TIME' -- CPU elapsed time in seconds
==============================================

_Description_:
     Returns a `REAL' value representing the elapsed CPU time in
     seconds.  This is useful for testing segments of code to determine
     execution time.

_Option_:
     f95, gnu

_Class_:
     subroutine

_Syntax_:
     `CPU_TIME(X)'

_Arguments_:
     X          The type shall be `REAL' with intent out.

_Return value_:
     None

_Example_:
          program test_cpu_time
              real :: start, finish
              call cpu_time(start)
                  ! put code to test here
              call cpu_time(finish)
              print '("Time = ",f6.3," seconds.")',finish-start
          end program test_cpu_time


File: gfortran.info,  Node: CSHIFT,  Next: CTIME,  Prev: CPU_TIME,  Up: Intrinsic Procedures

7.35 `CSHIFT' -- Circular shift function
========================================

_Description_:
     `CSHIFT(ARRAY, SHIFT[,DIM])' performs a circular shift on elements
     of ARRAY along the dimension of DIM.  If DIM is omitted it is
     taken to be `1'.  DIM is a scaler of type `INTEGER' in the range
     of 1 /leq DIM /leq n) where n is the rank of ARRAY.  If the rank
     of ARRAY is one, then all elements of ARRAY are shifted by SHIFT
     places.  If rank is greater than one, then all complete rank one
     sections of ARRAY along the given dimension are shifted.  Elements
     shifted out one end of each rank one section are shifted back in
     the other end.

_Option_:
     f95, gnu

_Class_:
     transformational function

_Syntax_:
     `A = CSHIFT(A, SHIFT[,DIM])'

_Arguments_:
     ARRAY      May be any type, not scaler.
     SHIFT      The type shall be `INTEGER'.
     DIM        The type shall be `INTEGER'.

_Return value_:
     Returns an array of same type and rank as the ARRAY argument.

_Example_:
          program test_cshift
              integer, dimension(3,3) :: a
              a = reshape( (/ 1, 2, 3, 4, 5, 6, 7, 8, 9 /), (/ 3, 3 /))
              print '(3i3)', a(1,:)
              print '(3i3)', a(2,:)
              print '(3i3)', a(3,:)
              a = cshift(a, SHIFT=(/1, 2, -1/), DIM=2)
              print *
              print '(3i3)', a(1,:)
              print '(3i3)', a(2,:)
              print '(3i3)', a(3,:)
          end program test_cshift


File: gfortran.info,  Node: CTIME,  Next: DATE_AND_TIME,  Prev: CSHIFT,  Up: Intrinsic Procedures

7.36 `CTIME' -- Convert a time into a string
============================================

_Description_:
     `CTIME(T,S)' converts T, a system time value, such as returned by
     `TIME8()', to a string of the form `Sat Aug 19 18:13:14 1995', and
     returns that string into S.

     If `CTIME' is invoked as a function, it can not be invoked as a
     subroutine, and vice versa.

     T is an `INTENT(IN)' `INTEGER(KIND=8)' variable.  S is an
     `INTENT(OUT)' `CHARACTER' variable.

_Option_:
     gnu

_Class_:
     subroutine

_Syntax_:
     `CALL CTIME(T,S)'.
     `S = CTIME(T)', (not recommended).

_Arguments_:
     S          The type shall be of type `CHARACTER'.
     T          The type shall be of type `INTEGER(KIND=8)'.

_Return value_:
     The converted date and time as a string.

_Example_:
          program test_ctime
              integer(8) :: i
              character(len=30) :: date
              i = time8()

              ! Do something, main part of the program

              call ctime(i,date)
              print *, 'Program was started on ', date
          end program test_ctime


File: gfortran.info,  Node: DATE_AND_TIME,  Next: DBLE,  Prev: CTIME,  Up: Intrinsic Procedures

7.37 `DATE_AND_TIME' -- Date and time subroutine
================================================

_Description_:
     `DATE_AND_TIME(DATE, TIME, ZONE, VALUES)' gets the corresponding
     date and time information from the real-time system clock.  DATE is
     `INTENT(OUT)' and has form ccyymmdd.  TIME is `INTENT(OUT)' and
     has form hhmmss.sss.  ZONE is `INTENT(OUT)' and has form (+-)hhmm,
     representing the difference with respect to Coordinated Universal
     Time (UTC).  Unavailable time and date parameters return blanks.

     VALUES is `INTENT(OUT)' and provides the following:

                `VALUE(1)':          The year
                `VALUE(2)':          The month
                `VALUE(3)':          The day of the month
                `VAlUE(4)':          Time difference with UTC in minutes
                `VALUE(5)':          The hour of the day
                `VALUE(6)':          The minutes of the hour
                `VALUE(7)':          The seconds of the minute
                `VALUE(8)':          The milliseconds of the second

_Option_:
     f95, gnu

_Class_:
     subroutine

_Syntax_:
     `CALL DATE_AND_TIME([DATE, TIME, ZONE, VALUES])'

_Arguments_:
     DATE       (Optional) The type shall be `CHARACTER(8)' or larger.
     TIME       (Optional) The type shall be `CHARACTER(10)' or
                larger.
     ZONE       (Optional) The type shall be `CHARACTER(5)' or larger.
     VALUES     (Optional) The type shall be `INTEGER(8)'.

_Return value_:
     None

_Example_:
          program test_time_and_date
              character(8)  :: date
              character(10) :: time
              character(5)  :: zone
              integer,dimension(8) :: values
              ! using keyword arguments
              call date_and_time(date,time,zone,values)
              call date_and_time(DATE=date,ZONE=zone)
              call date_and_time(TIME=time)
              call date_and_time(VALUES=values)
              print '(a,2x,a,2x,a)', date, time, zone
              print '(8i5))', values
          end program test_time_and_date


File: gfortran.info,  Node: DBLE,  Next: DCMPLX,  Prev: DATE_AND_TIME,  Up: Intrinsic Procedures

7.38 `DBLE' -- Double conversion function
=========================================

_Description_:
     `DBLE(X)' Converts X to double precision real type.  `DFLOAT' is
     an alias for `DBLE'

_Option_:
     f95, gnu

_Class_:
     elemental function

_Syntax_:
     `X = DBLE(X)' `X = DFLOAT(X)'

_Arguments_:
     X          The type shall be `INTEGER(*)', `REAL(*)', or
                `COMPLEX(*)'.

_Return value_:
     The return value is of type double precision real.

_Example_:
          program test_dble
              real    :: x = 2.18
              integer :: i = 5
              complex :: z = (2.3,1.14)
              print *, dble(x), dble(i), dfloat(z)
          end program test_dble


File: gfortran.info,  Node: DCMPLX,  Next: DFLOAT,  Prev: DBLE,  Up: Intrinsic Procedures

7.39 `DCMPLX' -- Double complex conversion function
===================================================

_Description_:
     `DCMPLX(X [,Y])' returns a double complex number where X is
     converted to the real component.  If Y is present it is converted
     to the imaginary component.  If Y is not present then the
     imaginary component is set to 0.0.  If X is complex then Y must
     not be present.

_Option_:
     f95, gnu

_Class_:
     elemental function

_Syntax_:
     `C = DCMPLX(X)' `C = DCMPLX(X,Y)'

_Arguments_:
     X          The type may be `INTEGER(*)', `REAL(*)', or
                `COMPLEX(*)'.
     Y          Optional if X is not `COMPLEX(*)'. May be
                `INTEGER(*)' or `REAL(*)'.

_Return value_:
     The return value is of type `COMPLEX(8)'

_Example_:
          program test_dcmplx
              integer :: i = 42
              real :: x = 3.14
              complex :: z
              z = cmplx(i, x)
              print *, dcmplx(i)
              print *, dcmplx(x)
              print *, dcmplx(z)
              print *, dcmplx(x,i)
          end program test_dcmplx


File: gfortran.info,  Node: DFLOAT,  Next: DIGITS,  Prev: DCMPLX,  Up: Intrinsic Procedures

7.40 `DFLOAT' -- Double conversion function
===========================================

_Description_:
     `DFLOAT(X)' Converts X to double precision real type.  `DFLOAT' is
     an alias for `DBLE'.  See `DBLE'.


File: gfortran.info,  Node: DIGITS,  Next: DIM,  Prev: DFLOAT,  Up: Intrinsic Procedures

7.41 `DIGITS' -- Significant digits function
============================================

_Description_:
     `DIGITS(X)' returns the number of significant digits of the
     internal model representation of X.  For example, on a system
     using a 32-bit floating point representation, a default real
     number would likely return 24.

_Option_:
     f95, gnu

_Class_:
     inquiry function

_Syntax_:
     `C = DIGITS(X)'

_Arguments_:
     X          The type may be `INTEGER(*)' or `REAL(*)'.

_Return value_:
     The return value is of type `INTEGER'.

_Example_:
          program test_digits
              integer :: i = 12345
              real :: x = 3.143
              real(8) :: y = 2.33
              print *, digits(i)
              print *, digits(x)
              print *, digits(y)
          end program test_digits


File: gfortran.info,  Node: DIM,  Next: DOT_PRODUCT,  Prev: DIGITS,  Up: Intrinsic Procedures

7.42 `DIM' -- Dim function
==========================

_Description_:
     `DIM(X,Y)' returns the difference `X-Y' if the result is positive;
     otherwise returns zero.

_Option_:
     f95, gnu

_Class_:
     elemental function

_Syntax_:
     `X = DIM(X,Y)'

_Arguments_:
     X          The type shall be `INTEGER(*)' or `REAL(*)'
     Y          The type shall be the same type and kind as X.

_Return value_:
     The return value is of type `INTEGER(*)' or `REAL(*)'.

_Example_:
          program test_dim
              integer :: i
              real(8) :: x
              i = dim(4, 15)
              x = dim(4.345_8, 2.111_8)
              print *, i
              print *, x
          end program test_dim

_Specific names_:
     Name             Argument         Return type      Option
     `IDIM(X,Y)'      `INTEGER(4)      `INTEGER(4)'     gnu
                      X,Y'                              
     `DDIM(X,Y)'      `REAL(8) X,Y'    `REAL(8)'        gnu


File: gfortran.info,  Node: DOT_PRODUCT,  Next: DPROD,  Prev: DIM,  Up: Intrinsic Procedures

7.43 `DOT_PRODUCT' -- Dot product function
==========================================

_Description_:
     `DOT_PRODUCT(X,Y)' computes the dot product multiplication of two
     vectors X and Y.  The two vectors may be either numeric or logical
     and must be arrays of rank one and of equal size. If the vectors
     are `INTEGER(*)' or `REAL(*)', the result is `SUM(X*Y)'. If the
     vectors are `COMPLEX(*)', the result is `SUM(CONJG(X)*Y)'. If the
     vectors are `LOGICAL', the result is `ANY(X.AND.Y)'.

_Option_:
     f95

_Class_:
     transformational function

_Syntax_:
     `S = DOT_PRODUCT(X,Y)'

_Arguments_:
     X          The type shall be numeric or `LOGICAL', rank 1.
     Y          The type shall be numeric or `LOGICAL', rank 1.

_Return value_:
     If the arguments are numeric, the return value is a scaler of
     numeric type, `INTEGER(*)', `REAL(*)', or `COMPLEX(*)'.  If the
     arguments are `LOGICAL', the return value is `.TRUE.' or `.FALSE.'.

_Example_:
          program test_dot_prod
              integer, dimension(3) :: a, b
              a = (/ 1, 2, 3 /)
              b = (/ 4, 5, 6 /)
              print '(3i3)', a
              print *
              print '(3i3)', b
              print *
              print *, dot_product(a,b)
          end program test_dot_prod


File: gfortran.info,  Node: DPROD,  Next: DREAL,  Prev: DOT_PRODUCT,  Up: Intrinsic Procedures

7.44 `DPROD' -- Double product function
=======================================

_Description_:
     `DPROD(X,Y)' returns the product `X*Y'.

_Option_:
     f95, gnu

_Class_:
     elemental function

_Syntax_:
     `D = DPROD(X,Y)'

_Arguments_:
     X          The type shall be `REAL'.
     Y          The type shall be `REAL'.

_Return value_:
     The return value is of type `REAL(8)'.

_Example_:
          program test_dprod
              integer :: i
              real :: x = 5.2
              real :: y = 2.3
              real(8) :: d
              d = dprod(x,y)
              print *, d
          end program test_dprod


File: gfortran.info,  Node: DREAL,  Next: DTIME,  Prev: DPROD,  Up: Intrinsic Procedures

7.45 `DREAL' -- Double real part function
=========================================

_Description_:
     `DREAL(Z)' returns the real part of complex variable Z.

_Option_:
     gnu

_Class_:
     elemental function

_Syntax_:
     `D = DREAL(Z)'

_Arguments_:
     Z          The type shall be `COMPLEX(8)'.

_Return value_:
     The return value is of type `REAL(8)'.

_Example_:
          program test_dreal
              complex(8) :: z = (1.3_8,7.2_8)
              print *, dreal(z)
          end program test_dreal


File: gfortran.info,  Node: DTIME,  Next: EOSHIFT,  Prev: DREAL,  Up: Intrinsic Procedures

7.46 `DTIME' -- Execution time subroutine (or function)
=======================================================

_Description_:
     `DTIME(TARRAY, RESULT)' initially returns the number of seconds of
     runtime since the start of the process's execution in RESULT.
     TARRAY returns the user and system components of this time in
     `TARRAY(1)' and `TARRAY(2)' respectively. RESULT is equal to
     `TARRAY(1) + TARRAY(2)'.

     Subsequent invocations of `DTIME' return values accumulated since
     the previous invocation.

     On some systems, the underlying timings are represented using
     types with sufficiently small limits that overflows (wraparounds)
     are possible, such as 32-bit types. Therefore, the values returned
     by this intrinsic might be, or become, negative, or numerically
     less than previous values, during a single run of the compiled
     program.

     If `DTIME' is invoked as a function, it can not be invoked as a
     subroutine, and vice versa.

     TARRAY and RESULT are `INTENT(OUT)' and provide the following:

                `TARRAY(1)':         User time in seconds.
                `TARRAY(2)':         System time in seconds.
                `RESULT':            Run time since start in seconds.

_Option_:
     gnu

_Class_:
     subroutine

_Syntax_:
     `CALL DTIME(TARRAY, RESULT)'.
     `RESULT = DTIME(TARRAY)', (not recommended).

_Arguments_:
     TARRAY     The type shall be `REAL, DIMENSION(2)'.
     RESULT     The type shall be `REAL'.

_Return value_:
     Elapsed time in seconds since the start of program execution.

_Example_:
          program test_dtime
              integer(8) :: i, j
              real, dimension(2) :: tarray
              real :: result
              call dtime(tarray, result)
              print *, result
              print *, tarray(1)
              print *, tarray(2)
              do i=1,100000000    ! Just a delay
                  j = i * i - i
              end do
              call dtime(tarray, result)
              print *, result
              print *, tarray(1)
              print *, tarray(2)
          end program test_dtime


File: gfortran.info,  Node: EOSHIFT,  Next: EPSILON,  Prev: DTIME,  Up: Intrinsic Procedures

7.47 `EOSHIFT' -- End-off shift function
========================================

_Description_:
     `EOSHIFT(ARRAY, SHIFT[,BOUNDARY, DIM])' performs an end-off shift
     on elements of ARRAY along the dimension of DIM.  If DIM is
     omitted it is taken to be `1'.  DIM is a scaler of type `INTEGER'
     in the range of 1 /leq DIM /leq n) where n is the rank of ARRAY.
     If the rank of ARRAY is one, then all elements of ARRAY are
     shifted by SHIFT places.  If rank is greater than one, then all
     complete rank one sections of ARRAY along the given dimension are
     shifted.  Elements shifted out one end of each rank one section
     are dropped.  If BOUNDARY is present then the corresponding value
     of from BOUNDARY is copied back in the other end.  If BOUNDARY is
     not present then the following are copied in depending on the type
     of ARRAY.

     _Array     _Boundary Value_
     Type_      
     Numeric    0 of the type and kind of ARRAY.
     Logical    `.FALSE.'.
     Character(LEN)LEN blanks.

_Option_:
     f95, gnu

_Class_:
     transformational function

_Syntax_:
     `A = EOSHIFT(A, SHIFT[,BOUNDARY, DIM])'

_Arguments_:
     ARRAY      May be any type, not scaler.
     SHIFT      The type shall be `INTEGER'.
     BOUNDARY   Same type as ARRAY.
     DIM        The type shall be `INTEGER'.

_Return value_:
     Returns an array of same type and rank as the ARRAY argument.

_Example_:
          program test_eoshift
              integer, dimension(3,3) :: a
              a = reshape( (/ 1, 2, 3, 4, 5, 6, 7, 8, 9 /), (/ 3, 3 /))
              print '(3i3)', a(1,:)
              print '(3i3)', a(2,:)
              print '(3i3)', a(3,:)
              a = EOSHIFT(a, SHIFT=(/1, 2, 1/), BOUNDARY=-5, DIM=2)
              print *
              print '(3i3)', a(1,:)
              print '(3i3)', a(2,:)
              print '(3i3)', a(3,:)
          end program test_eoshift


File: gfortran.info,  Node: EPSILON,  Next: ERF,  Prev: EOSHIFT,  Up: Intrinsic Procedures

7.48 `EPSILON' -- Epsilon function
==================================

_Description_:
     `EPSILON(X)' returns a nearly negligible number relative to `1'.

_Option_:
     f95, gnu

_Class_:
     inquiry function

_Syntax_:
     `C = EPSILON(X)'

_Arguments_:
     X          The type shall be `REAL(*)'.

_Return value_:
     The return value is of same type as the argument.

_Example_:
          program test_epsilon
              real :: x = 3.143
              real(8) :: y = 2.33
              print *, EPSILON(x)
              print *, EPSILON(y)
          end program test_epsilon


File: gfortran.info,  Node: ERF,  Next: ERFC,  Prev: EPSILON,  Up: Intrinsic Procedures

7.49 `ERF' -- Error function
============================

_Description_:
     `ERF(X)' computes the error function of X.

_Option_:
     gnu

_Class_:
     elemental function

_Syntax_:
     `X = ERF(X)'

_Arguments_:
     X          The type shall be `REAL(*)', and it shall be scalar.

_Return value_:
     The return value is a scalar of type `REAL(*)' and it is positive
     ( - 1 \leq erf (x) \leq 1 .

_Example_:
          program test_erf
            real(8) :: x = 0.17_8
            x = erf(x)
          end program test_erf

_Specific names_:
     Name             Argument         Return type      Option
     `DERF(X)'        `REAL(8) X'      `REAL(8)'        gnu


File: gfortran.info,  Node: ERFC,  Next: ETIME,  Prev: ERF,  Up: Intrinsic Procedures

7.50 `ERFC' -- Error function
=============================

_Description_:
     `ERFC(X)' computes the complementary error function of X.

_Option_:
     gnu

_Class_:
     elemental function

_Syntax_:
     `X = ERFC(X)'

_Arguments_:
     X          The type shall be `REAL(*)', and it shall be scalar.

_Return value_:
     The return value is a scalar of type `REAL(*)' and it is positive
     ( 0 \leq erfc (x) \leq 2 .

_Example_:
          program test_erfc
            real(8) :: x = 0.17_8
            x = erfc(x)
          end program test_erfc

_Specific names_:
     Name             Argument         Return type      Option
     `DERFC(X)'       `REAL(8) X'      `REAL(8)'        gnu


File: gfortran.info,  Node: ETIME,  Next: EXIT,  Prev: ERFC,  Up: Intrinsic Procedures

7.51 `ETIME' -- Execution time subroutine (or function)
=======================================================

_Description_:
     `ETIME(TARRAY, RESULT)' returns the number of seconds of runtime
     since the start of the process's execution in RESULT.  TARRAY
     returns the user and system components of this time in `TARRAY(1)'
     and `TARRAY(2)' respectively. RESULT is equal to `TARRAY(1) +
     TARRAY(2)'.

     On some systems, the underlying timings are represented using
     types with sufficiently small limits that overflows (wraparounds)
     are possible, such as 32-bit types. Therefore, the values returned
     by this intrinsic might be, or become, negative, or numerically
     less than previous values, during a single run of the compiled
     program.

     If `ETIME' is invoked as a function, it can not be invoked as a
     subroutine, and vice versa.

     TARRAY and RESULT are `INTENT(OUT)' and provide the following:

                `TARRAY(1)':         User time in seconds.
                `TARRAY(2)':         System time in seconds.
                `RESULT':            Run time since start in seconds.

_Option_:
     gnu

_Class_:
     subroutine

_Syntax_:
     `CALL ETIME(TARRAY, RESULT)'.
     `RESULT = ETIME(TARRAY)', (not recommended).

_Arguments_:
     TARRAY     The type shall be `REAL, DIMENSION(2)'.
     RESULT     The type shall be `REAL'.

_Return value_:
     Elapsed time in seconds since the start of program execution.

_Example_:
          program test_etime
              integer(8) :: i, j
              real, dimension(2) :: tarray
              real :: result
              call ETIME(tarray, result)
              print *, result
              print *, tarray(1)
              print *, tarray(2)
              do i=1,100000000    ! Just a delay
                  j = i * i - i
              end do
              call ETIME(tarray, result)
              print *, result
              print *, tarray(1)
              print *, tarray(2)
          end program test_etime


File: gfortran.info,  Node: EXIT,  Next: EXP,  Prev: ETIME,  Up: Intrinsic Procedures

7.52 `EXIT' -- Exit the program with status.
============================================

_Description_:
     `EXIT' causes immediate termination of the program with status.
     If status is omitted it returns the canonical _success_ for the
     system.  All Fortran I/O units are closed.

_Option_:
     gnu

_Class_:
     non-elemental subroutine

_Syntax_:
     `CALL EXIT([STATUS])'

_Arguments_:
     STATUS     The type of the argument shall be `INTEGER(*)'.

_Return value_:
     `STATUS' is passed to the parent process on exit.

_Example_:
          program test_exit
            integer :: STATUS = 0
            print *, 'This program is going to exit.'
            call EXIT(STATUS)
          end program test_exit


File: gfortran.info,  Node: EXP,  Next: EXPONENT,  Prev: EXIT,  Up: Intrinsic Procedures

7.53 `EXP' -- Exponential function
==================================

_Description_:
     `EXP(X)' computes the base e exponential of X.

_Option_:
     f95, gnu

_Class_:
     elemental function

_Syntax_:
     `X = EXP(X)'

_Arguments_:
     X          The type shall be `REAL(*)' or `COMPLEX(*)'.

_Return value_:
     The return value has same type and kind as X.

_Example_:
          program test_exp
            real :: x = 1.0
            x = exp(x)
          end program test_exp

_Specific names_:
     Name             Argument         Return type      Option
     `DEXP(X)'        `REAL(8) X'      `REAL(8)'        f95, gnu
     `CEXP(X)'        `COMPLEX(4) X'   `COMPLEX(4)'     f95, gnu
     `ZEXP(X)'        `COMPLEX(8) X'   `COMPLEX(8)'     f95, gnu
     `CDEXP(X)'       `COMPLEX(8) X'   `COMPLEX(8)'     f95, gnu


File: gfortran.info,  Node: EXPONENT,  Next: FDATE,  Prev: EXP,  Up: Intrinsic Procedures

7.54 `EXPONENT' -- Exponent function
====================================

_Description_:
     `EXPONENT(X)' returns the value of the exponent part of X. If X is
     zero the value returned is zero.

_Option_:
     f95, gnu

_Class_:
     elemental function

_Syntax_:
     `I = EXPONENT(X)'

_Arguments_:
     X          The type shall be `REAL(*)'.

_Return value_:
     The return value is of type default `INTEGER'.

_Example_:
          program test_exponent
            real :: x = 1.0
            integer :: i
            i = exponent(x)
            print *, i
            print *, exponent(0.0)
          end program test_exponent


File: gfortran.info,  Node: FDATE,  Next: FLOOR,  Prev: EXPONENT,  Up: Intrinsic Procedures

7.55 `FDATE' -- Get the current time as a string
================================================

_Description_:
     `FDATE(DATE)' returns the current date (using the same format as
     `CTIME') in DATE. It is equivalent to `CALL CTIME(DATE, TIME8())'.

     If `FDATE' is invoked as a function, it can not be invoked as a
     subroutine, and vice versa.

     DATE is an `INTENT(OUT)' `CHARACTER' variable.

_Option_:
     gnu

_Class_:
     subroutine

_Syntax_:
     `CALL FDATE(DATE)'.
     `DATE = FDATE()', (not recommended).

_Arguments_:
     DATE       The type shall be of type `CHARACTER'.

_Return value_:
     The current date and time as a string.

_Example_:
          program test_fdate
              integer(8) :: i, j
              character(len=30) :: date
              call fdate(date)
              print *, 'Program started on ', date
              do i = 1, 100000000 ! Just a delay
                  j = i * i - i
              end do
              call fdate(date)
              print *, 'Program ended on ', date
          end program test_fdate


File: gfortran.info,  Node: FLOOR,  Next: FNUM,  Prev: FDATE,  Up: Intrinsic Procedures

7.56 `FLOOR' -- Integer floor function
======================================

_Description_:
     `FLOOR(X)' returns the greatest integer less than or equal to X.

_Option_:
     f95, gnu

_Class_:
     elemental function

_Syntax_:
     `I = FLOOR(X[,KIND])'

_Arguments_:
     X          The type shall be `REAL(*)'.
     KIND       Optional scaler integer initialization expression.

_Return value_:
     The return value is of type `INTEGER(KIND)'

_Example_:
          program test_floor
              real :: x = 63.29
              real :: y = -63.59
              print *, floor(x) ! returns 63
              print *, floor(y) ! returns -64
          end program test_floor


File: gfortran.info,  Node: FNUM,  Next: LOG,  Prev: FLOOR,  Up: Intrinsic Procedures

7.57 `FNUM' -- File number function
===================================

_Description_:
     `FNUM(UNIT)' returns the Posix file descriptor number coresponding
     to the open Fortran I/O unit `UNIT'.

_Option_:
     gnu

_Class_:
     non-elemental function

_Syntax_:
     `I = FNUM(UNIT)'

_Arguments_:
     UNIT       The type shall be `INTEGER'.

_Return value_:
     The return value is of type `INTEGER'

_Example_:
          program test_fnum
            integer :: i
            open (unit=10, status = "scratch")
            i = fnum(10)
            print *, i
            close (10)
          end program test_fnum


File: gfortran.info,  Node: LOG,  Next: LOG10,  Prev: FNUM,  Up: Intrinsic Procedures

7.58 `LOG' -- Logarithm function
================================

_Description_:
     `LOG(X)' computes the logarithm of X.

_Option_:
     f95, gnu

_Class_:
     elemental function

_Syntax_:
     `X = LOG(X)'

_Arguments_:
     X          The type shall be `REAL(*)' or `COMPLEX(*)'.

_Return value_:
     The return value is of type `REAL(*)' or `COMPLEX(*)'.  The kind
     type parameter is the same as X.

_Example_:
          program test_log
            real(8) :: x = 1.0_8
            complex :: z = (1.0, 2.0)
            x = log(x)
            z = log(z)
          end program test_log

_Specific names_:
     Name             Argument         Return type      Option
     `ALOG(X)'        `REAL(4) X'      `REAL(4)'        f95, gnu
     `DLOG(X)'        `REAL(8) X'      `REAL(8)'        f95, gnu
     `CLOG(X)'        `COMPLEX(4) X'   `COMPLEX(4)'     f95, gnu
     `ZLOG(X)'        `COMPLEX(8) X'   `COMPLEX(8)'     f95, gnu
     `CDLOG(X)'       `COMPLEX(8) X'   `COMPLEX(8)'     f95, gnu


File: gfortran.info,  Node: LOG10,  Next: SECNDS,  Prev: LOG,  Up: Intrinsic Procedures

7.59 `LOG10' -- Base 10 logarithm function
==========================================

_Description_:
     `LOG10(X)' computes the base 10 logarithm of X.

_Option_:
     f95, gnu

_Class_:
     elemental function

_Syntax_:
     `X = LOG10(X)'

_Arguments_:
     X          The type shall be `REAL(*)' or `COMPLEX(*)'.

_Return value_:
     The return value is of type `REAL(*)' or `COMPLEX(*)'.  The kind
     type parameter is the same as X.

_Example_:
          program test_log10
            real(8) :: x = 10.0_8
            x = log10(x)
          end program test_log10

_Specific names_:
     Name             Argument         Return type      Option
     `ALOG10(X)'      `REAL(4) X'      `REAL(4)'        f95, gnu
     `DLOG10(X)'      `REAL(8) X'      `REAL(8)'        f95, gnu


File: gfortran.info,  Node: SECNDS,  Next: SQRT,  Prev: LOG10,  Up: Intrinsic Procedures

7.60 `SECNDS' -- Time subroutine
================================

_Description_:
     `SECNDS(X)' gets the time in seconds from the real-time system
     clock.  X is a reference time, also in seconds. If this is zero,
     the time in seconds from midnight is returned. This function is
     non-standard and its use is discouraged.

_Option_:
     gnu

_Class_:
     function

_Syntax_:
     `T = SECNDS (X)'

_Arguments_:
     Name       Type
     T          REAL(4)
     X          REAL(4)

_Return value_:
     None

_Example_:
          program test_secnds
              real(4) :: t1, t2
              print *, secnds (0.0)   ! seconds since midnight
              t1 = secnds (0.0)       ! reference time
              do i = 1, 10000000      ! do something
              end do
              t2 = secnds (t1)        ! elapsed time
              print *, "Something took ", t2, " seconds."
          end program test_secnds


File: gfortran.info,  Node: SIN,  Next: SINH,  Prev: SQRT,  Up: Intrinsic Procedures

7.61 `SIN' -- Sine function
===========================

_Description_:
     `SIN(X)' computes the sine of X.

_Option_:
     f95, gnu

_Class_:
     elemental function

_Syntax_:
     `X = SIN(X)'

_Arguments_:
     X          The type shall be `REAL(*)' or `COMPLEX(*)'.

_Return value_:
     The return value has same type and king than X.

_Example_:
          program test_sin
            real :: x = 0.0
            x = sin(x)
          end program test_sin

_Specific names_:
     Name             Argument         Return type      Option
     `DSIN(X)'        `REAL(8) X'      `REAL(8)'        f95, gnu
     `CSIN(X)'        `COMPLEX(4) X'   `COMPLEX(4)'     f95, gnu
     `ZSIN(X)'        `COMPLEX(8) X'   `COMPLEX(8)'     f95, gnu
     `CDSIN(X)'       `COMPLEX(8) X'   `COMPLEX(8)'     f95, gnu


File: gfortran.info,  Node: SINH,  Next: TAN,  Prev: SIN,  Up: Intrinsic Procedures

7.62 `SINH' -- Hyperbolic sine function
=======================================

_Description_:
     `SINH(X)' computes the hyperbolic sine of X.

_Option_:
     f95, gnu

_Class_:
     elemental function

_Syntax_:
     `X = SINH(X)'

_Arguments_:
     X          The type shall be `REAL(*)'.

_Return value_:
     The return value is of type `REAL(*)'.

_Example_:
          program test_sinh
            real(8) :: x = - 1.0_8
            x = sinh(x)
          end program test_sinh

_Specific names_:
     Name             Argument         Return type      Option
     `DSINH(X)'       `REAL(8) X'      `REAL(8)'        f95, gnu


File: gfortran.info,  Node: SQRT,  Next: SIN,  Prev: SECNDS,  Up: Intrinsic Procedures

7.63 `SQRT' -- Square-root function
===================================

_Description_:
     `SQRT(X)' computes the square root of X.

_Option_:
     f95, gnu

_Class_:
     elemental function

_Syntax_:
     `X = SQRT(X)'

_Arguments_:
     X          The type shall be `REAL(*)' or `COMPLEX(*)'.

_Return value_:
     The return value is of type `REAL(*)' or `COMPLEX(*)'.  The kind
     type parameter is the same as X.

_Example_:
          program test_sqrt
            real(8) :: x = 2.0_8
            complex :: z = (1.0, 2.0)
            x = sqrt(x)
            z = sqrt(z)
          end program test_sqrt

_Specific names_:
     Name             Argument         Return type      Option
     `DSQRT(X)'       `REAL(8) X'      `REAL(8)'        f95, gnu
     `CSQRT(X)'       `COMPLEX(4) X'   `COMPLEX(4)'     f95, gnu
     `ZSQRT(X)'       `COMPLEX(8) X'   `COMPLEX(8)'     f95, gnu
     `CDSQRT(X)'      `COMPLEX(8) X'   `COMPLEX(8)'     f95, gnu


File: gfortran.info,  Node: TAN,  Next: TANH,  Prev: SINH,  Up: Intrinsic Procedures

7.64 `TAN' -- Tangent function
==============================

_Description_:
     `TAN(X)' computes the tangent of X.

_Option_:
     f95, gnu

_Class_:
     elemental function

_Syntax_:
     `X = TAN(X)'

_Arguments_:
     X          The type shall be `REAL(*)'.

_Return value_:
     The return value is of type `REAL(*)'.  The kind type parameter is
     the same as X.

_Example_:
          program test_tan
            real(8) :: x = 0.165_8
            x = tan(x)
          end program test_tan

_Specific names_:
     Name             Argument         Return type      Option
     `DTAN(X)'        `REAL(8) X'      `REAL(8)'        f95, gnu


File: gfortran.info,  Node: TANH,  Prev: TAN,  Up: Intrinsic Procedures

7.65 `TANH' -- Hyperbolic tangent function
==========================================

_Description_:
     `TANH(X)' computes the hyperbolic tangent of X.

_Option_:
     f95, gnu

_Class_:
     elemental function

_Syntax_:
     `X = TANH(X)'

_Arguments_:
     X          The type shall be `REAL(*)'.

_Return value_:
     The return value is of type `REAL(*)' and lies in the range  - 1
     \leq tanh(x) \leq 1 .

_Example_:
          program test_tanh
            real(8) :: x = 2.1_8
            x = tanh(x)
          end program test_tanh

_Specific names_:
     Name             Argument         Return type      Option
     `DTANH(X)'       `REAL(8) X'      `REAL(8)'        f95, gnu


File: gfortran.info,  Node: Contributing,  Next: Standards,  Prev: Project Status,  Up: Top

8 Contributing
**************

Free software is only possible if people contribute to efforts to
create it.  We're always in need of more people helping out with ideas
and comments, writing documentation and contributing code.

   If you want to contribute to GNU Fortran 95, have a look at the long
lists of projects you can take on.  Some of these projects are small,
some of them are large; some are completely orthogonal to the rest of
what is happening on `gfortran', but others are "mainstream" projects
in need of enthusiastic hackers.  All of these projects are important!
We'll eventually get around to the things here, but they are also
things doable by someone who is willing and able.

* Menu:

* Contributors::
* Projects::


File: gfortran.info,  Node: Contributors,  Next: Projects,  Up: Contributing

8.1 Contributors to GNU Fortran 95
==================================

Most of the parser was hand-crafted by _Andy Vaught_, who is also the
initiator of the whole project.  Thanks Andy!  Most of the interface
with GCC was written by _Paul Brook_.

   The following individuals have contributed code and/or ideas and
significant help to the gfortran project (in no particular order):

   - Andy Vaught

   - Katherine Holcomb

   - Tobias Schlter

   - Steven Bosscher

   - Toon Moene

   - Tim Prince

   - Niels Kristian Bech Jensen

   - Steven Johnson

   - Paul Brook

   - Feng Wang

   - Bud Davis

   The following people have contributed bug reports, smaller or larger
patches, and much needed feedback and encouragement for the `gfortran'
project:

   - Erik Schnetter

   - Bill Clodius

   - Kate Hedstrom

   Many other individuals have helped debug, test and improve
`gfortran' over the past two years, and we welcome you to do the same!
If you already have done so, and you would like to see your name listed
in the list above, please contact us.


File: gfortran.info,  Node: Projects,  Prev: Contributors,  Up: Contributing

8.2 Projects
============

_Help build the test suite_
     Solicit more code for donation to the test suite.  We can keep
     code private on request.

_Bug hunting/squishing_
     Find bugs and write more test cases!  Test cases are especially
     very welcome, because it allows us to concentrate on fixing bugs
     instead of isolating them.

_Smaller projects ("bug" fixes):_
        - Allow init exprs to be numbers raised to integer powers.

        - Implement correct rounding.

        - Implement F restrictions on Fortran 95 syntax.

        - See about making Emacs-parsable error messages.

If you wish to work on the runtime libraries, please contact a project
maintainer.


File: gfortran.info,  Node: Standards,  Next: Extensions,  Prev: Contributing,  Up: Top

9 Standards
***********

The GNU Fortran 95 Compiler aims to be a conforming implementation of
ISO/IEC 1539:1997 (Fortran 95).

   In the future it may also support other variants and extensions to
the Fortran language.  This includes ANSI Fortran 77, Fortran 90,
Fortran 2000 (not yet finalized), and OpenMP.


File: gfortran.info,  Node: Index,  Prev: Intrinsic Procedures,  Up: Top

Index
*****

 [index ]
* Menu:

* -fbounds-check option:                 Code Gen Options.    (line 129)
* -fdefault-double-8, option:            Fortran Dialect Options.
                                                              (line  16)
* -fdefault-integer-8, option:           Fortran Dialect Options.
                                                              (line  19)
* -fdefault-real-8, option:              Fortran Dialect Options.
                                                              (line  23)
* -fdollar-ok option:                    Fortran Dialect Options.
                                                              (line  27)
* -fdump-parse-tree option:              Debugging Options.   (line   9)
* -ff2c option:                          Code Gen Options.    (line  20)
* -ffixed-line-length-N option:          Fortran Dialect Options.
                                                              (line  36)
* -ffortran-bounds-check option:         Code Gen Options.    (line 129)
* -ffree-form option:                    Fortran Dialect Options.
                                                              (line   9)
* -fimplicit-none option:                Fortran Dialect Options.
                                                              (line  53)
* -fmax-identifier-length=N option:      Fortran Dialect Options.
                                                              (line  49)
* -fmax-stack-var-size option:           Code Gen Options.    (line 138)
* -fno-automatic option:                 Code Gen Options.    (line  14)
* -fno-backslash option:                 Fortran Dialect Options.
                                                              (line  30)
* -fno-fixed-form option:                Fortran Dialect Options.
                                                              (line   9)
* -fno-underscoring option:              Code Gen Options.    (line  49)
* -fpackderived:                         Code Gen Options.    (line 148)
* -frepack-arrays option:                Code Gen Options.    (line 154)
* -fsecond-underscore option:            Code Gen Options.    (line 112)
* -fsyntax-only option:                  Warning Options.     (line  20)
* -Idir option:                          Directory Options.   (line  13)
* -Mdir option:                          Directory Options.   (line  28)
* -pedantic option:                      Warning Options.     (line  24)
* -pedantic-errors option:               Warning Options.     (line  42)
* -std=STD option:                       Fortran Dialect Options.
                                                              (line  58)
* -W option:                             Warning Options.     (line  98)
* -w option:                             Warning Options.     (line  46)
* -Waliasing option:                     Warning Options.     (line  55)
* -Wall option:                          Warning Options.     (line  49)
* -Wconversion option:                   Warning Options.     (line  62)
* -Werror:                               Warning Options.     (line  95)
* -Wimplicit-interface option:           Warning Options.     (line  65)
* -Wnonstd-intrinsic option:             Warning Options.     (line  71)
* -Wsurprising:                          Warning Options.     (line  75)
* -Wunderflow:                           Warning Options.     (line  88)
* -Wunused-labels option:                Warning Options.     (line  92)
* abort:                                 ABORT.               (line   6)
* ABORT:                                 ABORT.               (line   6)
* ABS intrinsic:                         ABS.                 (line   6)
* absolute value:                        ABS.                 (line   6)
* ACHAR intrinsic:                       ACHAR.               (line   6)
* ACOS intrinsic:                        ACOS.                (line   6)
* adjust string <1>:                     ADJUSTR.             (line   6)
* adjust string:                         ADJUSTL.             (line   6)
* ADJUSTL intrinsic:                     ADJUSTL.             (line   6)
* ADJUSTR intrinsic:                     ADJUSTR.             (line   6)
* AIMAG intrinsic:                       AIMAG.               (line   6)
* AINT intrinsic:                        AINT.                (line   6)
* aliasing:                              Warning Options.     (line  56)
* ALL intrinsic:                         ALL.                 (line   6)
* all warnings:                          Warning Options.     (line  50)
* ALLOCATED intrinsic:                   ALLOCATED.           (line   6)
* allocation status:                     ALLOCATED.           (line   6)
* ALOG intrinsic:                        LOG.                 (line   6)
* ALOG10 intrinsic:                      LOG10.               (line   6)
* ANINT intrinsic:                       ANINT.               (line   6)
* ANY intrinsic:                         ANY.                 (line   6)
* arc cosine:                            ACOS.                (line   6)
* arcsine:                               ASIN.                (line   6)
* arctangent <1>:                        ATAN2.               (line   6)
* arctangent:                            ATAN.                (line   6)
* array bounds checking:                 Code Gen Options.    (line 130)
* ASCII collating sequence:              ACHAR.               (line   6)
* ASIN intrinsic:                        ASIN.                (line   6)
* ASSOCIATED intrinsic:                  ASSOCIATED.          (line   6)
* ATAN intrinsic:                        ATAN.                (line   6)
* ATAN2 intrinsic:                       ATAN2.               (line   6)
* Authors:                               Contributors.        (line   6)
* backslash:                             Fortran Dialect Options.
                                                              (line  31)
* BESJ0 intrinsic:                       BESJ0.               (line   6)
* BESJ1 intrinsic:                       BESJ1.               (line   6)
* BESJN intrinsic:                       BESJN.               (line   6)
* Bessel <1>:                            BESYN.               (line   6)
* Bessel <2>:                            BESY1.               (line   6)
* Bessel <3>:                            BESY0.               (line   6)
* Bessel <4>:                            BESJN.               (line   6)
* Bessel <5>:                            BESJ1.               (line   6)
* Bessel:                                BESJ0.               (line   6)
* BESY0 intrinsic:                       BESY0.               (line   6)
* BESY1 intrinsic:                       BESY1.               (line   6)
* BESYN intrinsic:                       BESYN.               (line   6)
* bit_size:                              BIT_SIZE.            (line   6)
* BIT_SIZE intrinsic:                    BIT_SIZE.            (line   6)
* bounds checking:                       Code Gen Options.    (line 130)
* BTEST:                                 BTEST.               (line   6)
* BTEST intrinsic:                       BTEST.               (line   6)
* CABS intrinsic:                        ABS.                 (line   6)
* calling convention:                    Code Gen Options.    (line  21)
* card image:                            Fortran Dialect Options.
                                                              (line  41)
* CDABS intrinsic:                       ABS.                 (line   6)
* CDCOS intrinsic:                       COS.                 (line   6)
* CDEXP intrinsic:                       EXP.                 (line   6)
* CDLOG intrinsic:                       LOG.                 (line   6)
* CDSIN intrinsic:                       SIN.                 (line   6)
* CDSQRT intrinsic:                      SQRT.                (line   6)
* CEILING:                               CEILING.             (line   6)
* CEILING intrinsic:                     CEILING.             (line   6)
* CHAR:                                  CHAR.                (line   6)
* CHAR intrinsic:                        CHAR.                (line   6)
* character set:                         Fortran Dialect Options.
                                                              (line  28)
* checking subscripts:                   Code Gen Options.    (line 130)
* CLOG intrinsic:                        LOG.                 (line   6)
* CMPLX:                                 CMPLX.               (line   6)
* CMPLX intrinsic:                       CMPLX.               (line   6)
* code generation, conventions:          Code Gen Options.    (line   6)
* command argument count:                COMMAND_ARGUMENT_COUNT.
                                                              (line   6)
* command options:                       Invoking GFORTRAN.   (line   6)
* COMMAND_ARGUMENT_COUNT intrinsic:      COMMAND_ARGUMENT_COUNT.
                                                              (line   6)
* complex conjugate:                     CONJG.               (line   6)
* CONJG intrinsic:                       CONJG.               (line   6)
* Contributing:                          Contributing.        (line   6)
* Contributors:                          Contributors.        (line   6)
* conversion:                            Warning Options.     (line  63)
* COS intrinsic:                         COS.                 (line   6)
* COSH intrinsic:                        COSH.                (line   6)
* cosine:                                COS.                 (line   6)
* count:                                 COUNT.               (line   6)
* COUNT intrinsic:                       COUNT.               (line   6)
* CPU_TIME:                              CPU_TIME.            (line   6)
* CPU_TIME intrinsic:                    CPU_TIME.            (line   6)
* Credits:                               Contributors.        (line   6)
* cshift intrinsic:                      CSHIFT.              (line   6)
* CSHIFT intrinsic:                      CSHIFT.              (line   6)
* CSQRT intrinsic:                       SQRT.                (line   6)
* CTIME intrinsic:                       CTIME.               (line   6)
* ctime subroutine:                      CTIME.               (line   6)
* DABS intrinsic:                        ABS.                 (line   6)
* DACOS intrinsic:                       ACOS.                (line   6)
* DASIN intrinsic:                       ASIN.                (line   6)
* DATAN intrinsic:                       ATAN.                (line   6)
* DATAN2 intrinsic:                      ATAN2.               (line   6)
* DATE_AND_TIME:                         DATE_AND_TIME.       (line   6)
* DATE_AND_TIME intrinsic:               DATE_AND_TIME.       (line   6)
* DBESJ0 intrinsic:                      BESJ0.               (line   6)
* DBESJ1 intrinsic:                      BESJ1.               (line   6)
* DBESJN intrinsic:                      BESJN.               (line   6)
* DBESY0 intrinsic:                      BESY0.               (line   6)
* DBESY1 intrinsic:                      BESY1.               (line   6)
* DBESYN intrinsic:                      BESYN.               (line   6)
* DBLE intrinsic:                        DBLE.                (line   6)
* DCMPLX:                                DCMPLX.              (line   6)
* DCMPLX intrinsic:                      DCMPLX.              (line   6)
* DCONJG intrinsic:                      CONJG.               (line   6)
* DCOS intrinsic:                        COS.                 (line   6)
* DCOSH intrinsic:                       COSH.                (line   6)
* DDIM intrinsic:                        DIM.                 (line   6)
* debugging information options:         Debugging Options.   (line   6)
* DEXP intrinsic:                        EXP.                 (line   6)
* DFLOAT intrinsic:                      DFLOAT.              (line   6)
* dialect options:                       Fortran Dialect Options.
                                                              (line   6)
* DIGITS intrinsic:                      DIGITS.              (line   6)
* digits, significant:                   DIGITS.              (line   6)
* dim:                                   DIM.                 (line   6)
* DIM intrinsic:                         DIM.                 (line   6)
* DIMAG intrinsic:                       AIMAG.               (line   6)
* DINT intrinsic:                        AINT.                (line   6)
* directive, INCLUDE:                    Directory Options.   (line   6)
* directory, options:                    Directory Options.   (line   6)
* directory, search paths for inclusion: Directory Options.   (line  14)
* DLOG intrinsic:                        LOG.                 (line   6)
* DLOG10 intrinsic:                      LOG10.               (line   6)
* DNINT intrinsic:                       ANINT.               (line   6)
* dollar sign:                           Fortran Dialect Options.
                                                              (line  28)
* Dot product:                           DOT_PRODUCT.         (line   6)
* DOT_PRODUCT intrinsic:                 DOT_PRODUCT.         (line   6)
* double conversion:                     DBLE.                (line   6)
* double float conversion:               DFLOAT.              (line   6)
* Double product:                        DPROD.               (line   6)
* Double real part:                      DREAL.               (line   6)
* DPROD intrinsic:                       DPROD.               (line   6)
* DREAL intrinsic:                       DREAL.               (line   6)
* DSIN intrinsic:                        SIN.                 (line   6)
* DSINH intrinsic:                       SINH.                (line   6)
* DSQRT intrinsic:                       SQRT.                (line   6)
* DTAN intrinsic:                        TAN.                 (line   6)
* DTANH intrinsic:                       TANH.                (line   6)
* DTIME intrinsic:                       DTIME.               (line   6)
* dtime subroutine:                      DTIME.               (line   6)
* environment variables:                 Environment Variables.
                                                              (line   6)
* eoshift intrinsic:                     EOSHIFT.             (line   6)
* EOSHIFT intrinsic:                     EOSHIFT.             (line   6)
* EPSILON intrinsic:                     EPSILON.             (line   6)
* epsilon, significant:                  EPSILON.             (line   6)
* ERF intrinsic:                         ERF.                 (line   6)
* ERFC intrinsic:                        ERFC.                (line   6)
* error function <1>:                    ERFC.                (line   6)
* error function:                        ERF.                 (line   6)
* escape characters:                     Fortran Dialect Options.
                                                              (line  31)
* ETIME intrinsic:                       ETIME.               (line   6)
* ETIME subroutine:                      ETIME.               (line   6)
* exit:                                  EXIT.                (line   6)
* EXIT:                                  EXIT.                (line   6)
* EXP intrinsic:                         EXP.                 (line   6)
* exponent function:                     EXPONENT.            (line   6)
* EXPONENT intrinsic:                    EXPONENT.            (line   6)
* exponential:                           EXP.                 (line   6)
* extended-source option:                Fortran Dialect Options.
                                                              (line  41)
* Extension:                             Extensions.          (line   6)
* extra warnings:                        Warning Options.     (line  99)
* f2c calling convention:                Code Gen Options.    (line  21)
* FDATE intrinsic:                       FDATE.               (line   6)
* fdate subroutine:                      FDATE.               (line   6)
* FDL, GNU Free Documentation License:   GNU Free Documentation License.
                                                              (line   6)
* fixed form:                            Fortran Dialect Options.
                                                              (line   9)
* floor:                                 FLOOR.               (line   6)
* FLOOR intrinsic:                       FLOOR.               (line   6)
* fnum:                                  FNUM.                (line   6)
* FNUM intrinsic:                        FNUM.                (line   6)
* Fortran 77:                            GFORTRAN and G77.    (line   6)
* Fortran 90, features:                  Fortran Dialect Options.
                                                              (line   9)
* free form:                             Fortran Dialect Options.
                                                              (line   9)
* G77:                                   GFORTRAN and G77.    (line   6)
* g77 calling convention:                Code Gen Options.    (line  21)
* GNU Compiler Collection:               GFORTRAN and GCC.    (line   6)
* GNU Fortran 95 command options:        Invoking GFORTRAN.   (line   6)
* Hollerith constants:                   Hollerith constants support.
                                                              (line   6)
* hyperbolic cosine:                     COSH.                (line   6)
* hyperbolic sine:                       SINH.                (line   6)
* hyperbolic tangent:                    TANH.                (line   6)
* IABS intrinsic:                        ABS.                 (line   6)
* IDIM intrinsic:                        DIM.                 (line   6)
* Imaginary part:                        AIMAG.               (line   6)
* Implicitly interconvert LOGICAL and INTEGER: Implicitly interconvert LOGICAL and INTEGER.
                                                              (line   6)
* INCLUDE directive:                     Directory Options.   (line   6)
* inclusion, directory search paths for: Directory Options.   (line  14)
* Initialization:                        Old-style variable initialization.
                                                              (line   6)
* Intrinsic Procedures:                  Intrinsic Procedures.
                                                              (line   6)
* Introduction:                          Top.                 (line   6)
* Kind specifications:                   Old-style kind specifications.
                                                              (line   6)
* labels, unused:                        Warning Options.     (line  93)
* language, dialect options:             Fortran Dialect Options.
                                                              (line   6)
* length of source lines:                Fortran Dialect Options.
                                                              (line  37)
* libf2c calling convention:             Code Gen Options.    (line  21)
* limits, lengths of source lines:       Fortran Dialect Options.
                                                              (line  37)
* lines, length:                         Fortran Dialect Options.
                                                              (line  37)
* LOG intrinsic:                         LOG.                 (line   6)
* LOG10 intrinsic:                       LOG10.               (line   6)
* logarithm <1>:                         LOG10.               (line   6)
* logarithm:                             LOG.                 (line   6)
* messages, warning:                     Warning Options.     (line   6)
* module search path:                    Directory Options.   (line  14)
* Namelist:                              Extensions to namelist.
                                                              (line   6)
* negative forms of options:             Invoking GFORTRAN.   (line  24)
* option -fmax-identifier-length=N:      Fortran Dialect Options.
                                                              (line  49)
* option, -fdefault-double-8:            Fortran Dialect Options.
                                                              (line  16)
* option, -fdefault-integer-8:           Fortran Dialect Options.
                                                              (line  19)
* option, -fdefault-real-8:              Fortran Dialect Options.
                                                              (line  23)
* option, -fdump-parse-tree:             Debugging Options.   (line   9)
* option, -Mdir:                         Directory Options.   (line  28)
* option, -std=STD:                      Fortran Dialect Options.
                                                              (line  58)
* options, -fdollar-ok:                  Fortran Dialect Options.
                                                              (line  27)
* options, -ff2c:                        Code Gen Options.    (line  20)
* options, -ffixed-line-length-N:        Fortran Dialect Options.
                                                              (line  36)
* options, -ffree-form:                  Fortran Dialect Options.
                                                              (line   9)
* options, -fimplicit-none:              Fortran Dialect Options.
                                                              (line  53)
* options, -fno-automatic:               Code Gen Options.    (line  14)
* options, -fno-backslash:               Fortran Dialect Options.
                                                              (line  30)
* options, -fno-fixed-form:              Fortran Dialect Options.
                                                              (line   9)
* options, -fno-underscoring:            Code Gen Options.    (line  49)
* options, -fsecond-underscore:          Code Gen Options.    (line 112)
* options, -fsyntax-only:                Warning Options.     (line  20)
* options, -Idir:                        Directory Options.   (line  13)
* options, -pedantic:                    Warning Options.     (line  24)
* options, -pedantic-errors:             Warning Options.     (line  42)
* options, -W:                           Warning Options.     (line  98)
* options, -w:                           Warning Options.     (line  46)
* options, -Waliasing:                   Warning Options.     (line  55)
* options, -Wall:                        Warning Options.     (line  49)
* options, -Wconversion:                 Warning Options.     (line  62)
* options, -Werror:                      Warning Options.     (line  95)
* options, -Wimplicit-interface:         Warning Options.     (line  65)
* options, -Wnonstd-intrinsic:           Warning Options.     (line  71)
* options, -Wsurprising:                 Warning Options.     (line  75)
* options, -Wunderflow:                  Warning Options.     (line  88)
* options, -Wunused-labels:              Warning Options.     (line  92)
* options, code generation:              Code Gen Options.    (line   6)
* options, debugging:                    Debugging Options.   (line   6)
* options, dialect:                      Fortran Dialect Options.
                                                              (line   6)
* options, directory search:             Directory Options.   (line   6)
* options, GNU Fortran 95 command:       Invoking GFORTRAN.   (line   6)
* options, negative forms:               Invoking GFORTRAN.   (line  24)
* options, warnings:                     Warning Options.     (line   6)
* paths, search:                         Directory Options.   (line  14)
* pointer status:                        ASSOCIATED.          (line   6)
* range checking:                        Code Gen Options.    (line 130)
* Repacking arrays:                      Code Gen Options.    (line 155)
* run-time, options:                     Code Gen Options.    (line   6)
* SAVE statement:                        Code Gen Options.    (line  15)
* search path:                           Directory Options.   (line   6)
* search paths, for included files:      Directory Options.   (line  14)
* SECNDS:                                SECNDS.              (line   6)
* SECNDS intrinsic:                      SECNDS.              (line   6)
* SIN intrinsic:                         SIN.                 (line   6)
* sine:                                  SIN.                 (line   6)
* SINH intrinsic:                        SINH.                (line   6)
* source file format:                    Fortran Dialect Options.
                                                              (line   9)
* Source Form:                           Fortran Dialect Options.
                                                              (line   9)
* SQRT intrinsic:                        SQRT.                (line   6)
* square-root:                           SQRT.                (line   6)
* Standards:                             Standards.           (line   6)
* statements, SAVE:                      Code Gen Options.    (line  15)
* Structure packing:                     Code Gen Options.    (line 149)
* subscript checking:                    Code Gen Options.    (line 130)
* suppressing warnings:                  Warning Options.     (line   6)
* Suspicious:                            Warning Options.     (line  76)
* symbol names:                          Fortran Dialect Options.
                                                              (line  28)
* symbol names, transforming:            Code Gen Options.    (line  50)
* symbol names, underscores:             Code Gen Options.    (line  50)
* syntax checking:                       Warning Options.     (line  20)
* TAN intrinsic:                         TAN.                 (line   6)
* tangent:                               TAN.                 (line   6)
* TANH intrinsic:                        TANH.                (line   6)
* transforming symbol names:             Code Gen Options.    (line  50)
* true values <1>:                       ANY.                 (line   6)
* true values:                           ALL.                 (line   6)
* UNDERFLOW:                             Warning Options.     (line  89)
* underscore:                            Code Gen Options.    (line  50)
* unused labels:                         Warning Options.     (line  93)
* warnings, all:                         Warning Options.     (line  50)
* warnings, extra:                       Warning Options.     (line  99)
* warnings, suppressing:                 Warning Options.     (line   6)
* whole number <1>:                      ANINT.               (line   6)
* whole number:                          AINT.                (line   6)
* ZABS intrinsic:                        ABS.                 (line   6)
* ZCOS intrinsic:                        COS.                 (line   6)
* ZEXP intrinsic:                        EXP.                 (line   6)
* ZLOG intrinsic:                        LOG.                 (line   6)
* ZSIN intrinsic:                        SIN.                 (line   6)
* ZSQRT intrinsic:                       SQRT.                (line   6)



Tag Table:
Node: Top2139
Node: Copying3336
Node: GNU Free Documentation License22509
Node: Funding44911
Node: Getting Started47439
Node: GFORTRAN and GCC52146
Node: GFORTRAN and G7754126
Node: Invoking GFORTRAN55671
Node: Option Summary57877
Node: Fortran Dialect Options59717
Node: Warning Options61942
Node: Debugging Options65986
Node: Directory Options66586
Node: Code Gen Options67943
Node: Environment Variables75463
Node: Project Status75936
Node: Compiler Status76760
Node: Library Status77750
Node: Proposed Extensions79120
Node: Extensions82430
Node: Old-style kind specifications83358
Node: Old-style variable initialization83933
Node: Extensions to namelist85027
Node: Implicitly interconvert LOGICAL and INTEGER86682
Node: Hollerith constants support87391
Node: Intrinsic Procedures88516
Node: Introduction92587
Node: ABORT94887
Node: ABS95532
Node: ACHAR96749
Node: ACOS97480
Node: ADJUSTL98353
Node: ADJUSTR99188
Node: AIMAG100030
Node: AINT100970
Node: ALL102364
Node: ALLOCATED104265
Node: ANINT105123
Node: ANY106429
Node: ASIN108343
Node: ASSOCIATED109223
Node: ATAN112025
Node: ATAN2112811
Node: BESJ0114075
Node: BESJ1114962
Node: BESJN115855
Node: BESY0116814
Node: BESY1117645
Node: BESYN118476
Node: BIT_SIZE119441
Node: BTEST120180
Node: CEILING121010
Node: CHAR121807
Node: CMPLX122580
Node: COMMAND_ARGUMENT_COUNT123751
Node: CONJG124549
Node: COS125485
Node: COSH126389
Node: COUNT127160
Node: CPU_TIME128678
Node: CSHIFT129516
Node: CTIME131120
Node: DATE_AND_TIME132341
Node: DBLE134534
Node: DCMPLX135342
Node: DFLOAT136552
Node: DIGITS136863
Node: DIM137795
Node: DOT_PRODUCT138870
Node: DPROD140282
Node: DREAL141015
Node: DTIME141629
Node: EOSHIFT143874
Node: EPSILON145897
Node: ERF146581
Node: ERFC147351
Node: ETIME148139
Node: EXIT150269
Node: EXP151089
Node: EXPONENT152014
Node: FDATE152748
Node: FLOOR153921
Node: FNUM154696
Node: LOG155413
Node: LOG10156510
Node: SECNDS157392
Node: SIN158418
Node: SINH159313
Node: SQRT160034
Node: TAN161081
Node: TANH161820
Node: Contributing162589
Node: Contributors163422
Node: Projects164567
Node: Standards165339
Node: Index165741

End Tag Table
